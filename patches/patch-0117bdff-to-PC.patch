diff -ruN o/autogen.sh pc/autogen.sh
--- o/autogen.sh	2025-07-08 10:32:49.000000000 +0300
+++ pc/autogen.sh	1970-01-01 03:00:00.000000000 +0300
@@ -1,2 +0,0 @@
-#!/bin/sh
-autoreconf -i
diff -ruN o/configure.ac pc/configure.ac
--- o/configure.ac	2025-07-11 16:39:11.171578110 +0300
+++ pc/configure.ac	2025-07-11 16:39:46.941637711 +0300
@@ -1,4 +1,4 @@
-AC_INIT([enigma2],[4],[forum@openpli.org])
+AC_INIT([enigma2],[PC9.1],[forum@openpli.org])
 AM_INIT_AUTOMAKE([dist-bzip2 no-define tar-pax -Wno-portability])
 AC_CONFIG_HEADERS([enigma2_config.h])
 
@@ -43,6 +43,8 @@
 AC_SUBST(LIBJPEG_LIBS)
 AC_CHECK_LIB([ungif], [DGifOpen], [LIBGIF_LIBS="-lungif"], [AC_CHECK_LIB([gif], [DGifOpen], [LIBGIF_LIBS="-lgif"], [AC_MSG_ERROR([Could not find libgif or libungif])])])
 AC_SUBST(LIBGIF_LIBS)
+AC_CHECK_LIB([xmlccwrap], [exit], [LIBXMLCCWRAP_LIBS="-lxmlccwrap"], [AC_MSG_ERROR([Could not find libxmlccwrap])])
+AC_SUBST(LIBXMLCCWRAP_LIBS)
 
 AC_ARG_WITH(crashlogemail,
 	[  --with-crashlogemail=crash log email address],
@@ -110,6 +112,16 @@
 fi
 AM_CONDITIONAL(HAVE_LIBXINE, test "$with_libxine" = "yes")
 
+AC_ARG_WITH(xlib,
+	AS_HELP_STRING([--with-xlib],[use xlib, yes or no]),
+	[with_xlib=$withval],[with_xlib=no])
+if test "$with_xlib" = "yes"; then
+	PKG_CHECK_MODULES(LIBXINE, libxine)
+	PKG_CHECK_MODULES(X11, x11)
+	AC_DEFINE([WITH_XLIB],[1],[Define to 1 if you want to use xlib])
+fi
+AM_CONDITIONAL(HAVE_XLIB, test "$with_xlib" = "yes")
+
 AC_ARG_WITH(debug,
 	AS_HELP_STRING([--without-debug],[disable debugging code]),
 	[with_debug="$withval"],[with_debug="yes"])
@@ -248,20 +260,8 @@
 
 CPPFLAGS="$CPPFLAGS $PYTHON_CPPFLAGS"
 CFLAGS="$CFLAGS -Wall"
-CXXFLAGS="$CXXFLAGS -Wall -Wextra -Werror \
-	-Wformat=2 -Wformat-overflow=2 -Wformat-nonliteral -Wformat-security \
-	-Wimplicit-fallthrough=5 -Wduplicated-branches -Wtrampolines \
-	-Wdangling-else -Wshift-overflow=2 -Wswitch \
-	-Wunused-but-set-parameter -Wunused-const-variable=1 -Wuninitialized \
-	-Wstringop-overflow=3 -Woverlength-strings \
-	-Wunsafe-loop-optimizations -Wpointer-arith \
-	-Wfloat-equal -Wlogical-op \
-	-Wno-error=cast-align=strict -Wno-error=ignored-qualifiers \
-	-Wno-error=cast-function-type \
-	-Wno-error=stringop-truncation -Wno-error=shadow -Wno-error=cast-qual \
-	-Wno-error=aggregate-return -Wno-error=missing-field-initializers \
-	-Wno-error=packed -Wno-error=vla -Wno-error=clobbered -Wno-error=unused-parameter \
-	$BASE_CFLAGS $ENIGMA2_CFLAGS $PTHREAD_CFLAGS $OPENMP_CFLAGS $ALSA_CFLAGS"
+CXXFLAGS="$CXXFLAGS -Wall \
+$BASE_CFLAGS $ENIGMA2_CFLAGS $PTHREAD_CFLAGS $OPENMP_CFLAGS $ALSA_CFLAGS"
 
 ARFLAGS="cr"
 AC_SUBST(ARFLAGS)
diff -ruN o/data/keymap.xml pc/data/keymap.xml
--- o/data/keymap.xml	2025-07-11 16:39:11.171578110 +0300
+++ pc/data/keymap.xml	2025-07-11 16:39:46.942637656 +0300
@@ -36,7 +36,6 @@
 	-->
 
 	<map context="HelpActions">
-		<key id="KEY_HELP" mapto="displayHelp" flags="b" />
 		<key id="KEY_HELP" mapto="toggleConfig" flags="l" />
 		<!-- Keyboard specific buttons -->
 		<key id="KEY_F1" mapto="displayHelp" flags="b" />
@@ -245,6 +244,39 @@
 		<key id="KEY_PAGEDOWN" mapto="pageDown" flags="mr" />
 		<key id="KEY_CHANNELUP" mapto="pageUp" flags="mr" />
 		<key id="KEY_CHANNELDOWN" mapto="pageDown" flags="mr" />
+		<key id="KEY_EPG" mapto="e" flags="mr" />
+		<key id="KEY_RECORD" mapto="r" flags="mr" />
+		<key id="KEY_TV" mapto="t" flags="mr" />
+		<key id="KEY_INFO" mapto="i" flags="mr" />
+		<key id="KEY_PLAYPAUSE" mapto="p" flags="mr" />
+		<key id="KEY_VOLUMEUP" mapto="+" flags="mr" />
+		<key id="KEY_OK" mapto="ok" flags="mr" />
+		<key id="KEY_ENTER" mapto="ok" flags="mr" />
+		<key id="KEY_AUDIO" mapto="a" flags="mr" />
+		<key id="KEY_RADIO" mapto="d" flags="mr" />
+		<key id="KEY_VIDEO" mapto="v" flags="mr" />
+		<key id="KEY_MUTE" mapto="m" flags="mr" />
+		<key id="KEY_VOLUMEDOWN" mapto="-" flags="mr" />
+		<key id="KEY_MENU" mapto="Space" flags="mr" />
+		<key id="KEY_RED" mapto="F1" flags="mr" />
+		<key id="KEY_GREEN" mapto="F2" flags="mr" />
+		<key id="KEY_YELLOW" mapto="F3" flags="mr" />
+		<key id="KEY_BLUE" mapto="F4" flags="mr" />
+		<key id="KEY_INFO" mapto="F5" flags="mr" />
+		<key id="KEY_EPG" mapto="F6" flags="mr" />
+		<key id="KEY_POWER" mapto="F10" flags="mr" />
+<!--		<key id="KEY_UP" mapto="keyUp" flags="mr" />
+		<key id="KEY_DOWN" mapto="keyDown" flags="mr" />-->
+		<key id="1" mapto="1" flags="mr" />
+		<key id="2" mapto="2" flags="mr" />
+		<key id="3" mapto="3" flags="mr" />
+		<key id="4" mapto="4" flags="mr" />
+		<key id="5" mapto="5" flags="mr" />
+		<key id="6" mapto="6" flags="mr" />
+		<key id="7" mapto="7" flags="mr" />
+		<key id="8" mapto="8" flags="mr" />
+		<key id="9" mapto="9" flags="mr" />
+		<key id="0" mapto="0" flags="mr" />
 	</map>
 
 	<map context="SetupActions">
@@ -252,8 +284,6 @@
 		<key id="KEY_OK" mapto="ok" flags="m" />
 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
 		<key id="KEY_ESC" mapto="cancel" flags="m" />
-		<key id="KEY_LEFT" mapto="left" flags="mr" />
-		<key id="KEY_RIGHT" mapto="right" flags="mr" />
 		<key id="KEY_UP" mapto="up" flags="mr" />
 		<key id="KEY_DOWN" mapto="down" flags="mr" />
 		<key id="KEY_RED" mapto="cancel" flags="m" />
@@ -476,6 +506,7 @@
 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
+		<key id="KEY_EXIT" mapto="toggleSeek" flags="l" />
 	</map>
 
 	<map context="MediaPlayerSeekActions">
@@ -653,6 +684,15 @@
 		<key id="KEY_FASTFORWARD" mapto="nextDay" flags="m" />
 	</map>
 
+	<map context="EPGFilterActions">
+		<key id="KEY_STOP" mapto="filter" flags="m" />
+		<key id="KEY_0" mapto="saveTimes" flags="m" />
+		<key id="KEY_1" mapto="startUp" flags="m" />
+		<key id="KEY_4" mapto="startDown" flags="m" />
+		<key id="KEY_3" mapto="endUp" flags="m" />
+		<key id="KEY_6" mapto="endDown" flags="m" />
+	</map>
+
 	<map context="GMEPGSelectActions">
 		<key id="KEY_GREEN" mapto="timerAdd" flags="m" />
 		<key id="KEY_YELLOW" mapto="yellow" flags="mr" />
@@ -718,8 +758,6 @@
 		<key id="KEY_RIGHT" mapto="rightRepeated" flags="r" />
 		<key id="KEY_LEFT" mapto="leftUp" flags="b" />
 		<key id="KEY_RIGHT" mapto="rightUp" flags="b" />
-		<key id="KEY_UP" mapto="upUp" flags="b" />
-		<key id="KEY_DOWN" mapto="downUp" flags="b" />
 		<key id="KEY_PREVIOUS" mapto="moveUp" flags="m" />
 		<key id="KEY_NEXT" mapto="moveDown" flags="m" />
 	</map>
diff -ruN o/data/menu.xml pc/data/menu.xml
--- o/data/menu.xml	2025-07-08 10:32:49.000000000 +0300
+++ pc/data/menu.xml	2025-07-11 16:39:46.942637656 +0300
@@ -39,8 +39,7 @@
 				<item key="fallbacktuner_settings" text="Fallback remote receiver setup"><screen module="SetupFallbacktuner"/></item>
 			</menu>
 			<menu key="system" weight="5" level="0" text="System">
-				<menu key="video" level="0" text="Audio / Video">
-					<item key="av_setup" level="0" text="Video settings"><setup id="avsetup"/></item>
+				<menu key="video" level="0" text="Other A/V settings">
 					<item  key="subtitle_setup" level="2" text="Subtitles"><setup id="subtitlesetup"/></item>
 					<item key="autolanguage_setup" level="0" text="Automatic Language"><setup id="autolanguagesetup"/></item>
 				</menu>
@@ -77,21 +76,13 @@
 				<item key="ci_setup" weight="10" level="0" text="Common Interface" requires="CommonInterface"><screen module="Ci" screen="CiSelection"/></item>
 			</menu>
 			<item key="parental_setup" weight="15" level="0" text="Parental control"><screen module="ParentalControlSetup" screen="ParentalControlSetup"/></item>
-			<item key="factory_reset" weight="15" level="0" text="Factory reset"><screen module="FactoryReset" screen="FactoryReset"/></item>
-			<item key="flash_image" weight="15" level="0" text="Flash image" requires="canFlashWithOfgwrite" ><screen module="FlashImage" screen="SelectImage"/></item>
-			<item key="software_update" weight="15" level="0" text="Software update"><screen module="SoftwareUpdate" screen="UpdatePlugin"/></item>
 		</menu>
 		<menu key="shutdown" text="Standby / restart">
 			<item key="sleep" text="Sleep timer"><screen module="SleepTimerEdit" screen="SleepTimerEdit"/></item>
 			<item key="standby" text="Standby"><screen module="Standby" screen="Standby"/></item>
 			<item key="restart" text="Restart"><screen module="Standby" screen="TryQuitMainloop">2</screen></item>
-			<item key="dualboot" weight="24" level="0" text="Switch to Android" requires="canDualBoot"><screen module="Standby" screen="SwitchToAndroid" /></item>
-			<item key="restart_enigma_debug" text="Restart enigma" requires="InDebugMode"><screen module="Standby" screen="TryQuitMainloop">6</screen></item>
-			<item key="restart_enigma" text="Restart enigma" requires="!InDebugMode"><screen module="Standby" screen="TryQuitMainloop">3</screen></item>
-			<item key="restart_enigma" text="Restart enigma in standard mode" requires="InDebugMode"><screen module="Standby" screen="TryQuitMainloop">3</screen></item>
-			<item key="restart_enigma_debug" text="Restart enigma in debug mode" requires="!InDebugMode"><screen module="Standby" screen="TryQuitMainloop">6</screen></item>
-			<item key="multiboot" text="Multiboot image selector" requires="canMultiBoot"><screen module="FlashImage" screen="MultibootSelection">1</screen></item>
-			<item key="deep_standby" text="Deep standby" requires="DeepstandbySupport"><screen module="Standby" screen="TryQuitMainloop">1</screen></item>
-			<item key="deep_standby" text="Shutdown" requires="!DeepstandbySupport"><screen module="Standby" screen="TryQuitMainloop">1</screen></item>
+			<item key="deep_standby" text="Quit" requires="DeepstandbySupport"><screen module="Standby" screen="TryQuitMainloop">3</screen></item>
+			<item key="deep_standby" text="Shutdown" requires="DeepstandbySupport"><screen module="Standby" screen="TryQuitMainloop">1</screen></item>
 		</menu>
 </menu>
+
diff -ruN o/data/setup.xml pc/data/setup.xml
--- o/data/setup.xml	2025-07-11 16:39:11.172578055 +0300
+++ pc/data/setup.xml	2025-07-11 16:39:46.942637656 +0300
@@ -3,9 +3,6 @@
 		<item level="0" text="Time zone area" description="Select your time zone area or region.">config.timezone.area</item>
 		<item level="0" text="Time zone" description="Select the time zone within the area or region.">config.timezone.val</item>
 	</setup>
-	<setup key="avsetup">
-		<!-- this is just a placeholder, the Videomode plugin implements this submenu -->
-	</setup>
 	<setup key="usage" title="Customize">
 		<item level="1" text="Sort order for menu entries" description="This option allows you to hide and sort menu entries. When selecting user you can change order and hide menu items via the blue button. With the user defined hidden the blue button is not shown in the menus">config.usage.menu_sort_mode</item>
 		<item level="1" text="Sort order for setup entries" description="This option allows you to alphabetically sort setup menu entries.">config.usage.sort_settings</item>
@@ -270,4 +267,14 @@
 		<item level="0" text="Show picons in channel selection list" description="Configure if service picons will be shown in the channel selection list.">config.usage.service_icon_enable</item>
 		<item level="0" text="Enable HDMI-CEC" description="When enabled, HDMI-CEC is enabled with standard configuration" requires="HasHDMI-CEC">config.hdmicec.enabled</item>
 	</setup>
+	<setup key="pc" title="PC settings">
+		<item level="0" text="Fullscreen default">config.pc.default_fullscreen</item>
+		<item level="1" text="Zoom enable">config.pc.zoom_enable</item>
+ 		<item level="2" text="Zoom aspect 4:3 of X (%)">config.pc.image4_3_zoom_x</item>
+ 		<item level="2" text="Zoom aspect 4:3 of Y (%)">config.pc.image4_3_zoom_y</item>
+ 		<item level="2" text="Zoom aspect 16:9 of X (%)">config.pc.image16_9_zoom_x</item>
+ 		<item level="2" text="Zoom aspect 16:9 of Y (%)">config.pc.image16_9_zoom_y</item>
+		<!--item level="0" text="TV resolution width ">config.pc.initial_window_width</item>
+		<item level="0" text="TV resolution height">config.pc.initial_window_height</item-->
+	</setup>
 </setupxml>
diff -ruN o/lib/base/condVar.cpp pc/lib/base/condVar.cpp
--- o/lib/base/condVar.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/base/condVar.cpp	2025-07-11 16:39:46.943637602 +0300
@@ -0,0 +1,240 @@
+/*
+ * condVar.cpp: Mutexes, conditional vars.
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: thread.c 4.14 2018/03/05 22:38:10 kls Exp $
+ */
+
+#include <lib/base/condVar.h>
+
+#if !defined(max)
+#define max(a, b)       ((a) > (b) ? (a) : (b))
+#endif
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled) {
+     if (TimeoutMs) {
+        struct timespec abstime;
+        if (GetAbsTime(&abstime, TimeoutMs)) {
+           while (!signaled) {
+                 if (pthread_cond_timedwait(&cond, &mutex, &abstime) == ETIMEDOUT)
+                    break;
+                 }
+           }
+        }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implicit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled, false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implicit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  locked = 0;
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+  if (!--locked)
+     pthread_mutex_unlock(&mutex);
+}
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+     mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex) {
+     mutex = Mutex;
+     Mutex->Lock();
+     locked = true;
+     return true;
+     }
+  return false;
+}
+
+// --- cTimeMs ---------------------------------------------------------------
+
+cTimeMs::cTimeMs(int Ms)
+{
+  Set(Ms);
+}
+
+uint64_t cTimeMs::Now(void)
+{
+#if _POSIX_TIMERS > 0 && defined(_POSIX_MONOTONIC_CLOCK)
+#define MIN_RESOLUTION 5 // ms
+  static bool initialized = false;
+  static bool monotonic = false;
+  struct timespec tp;
+  if (!initialized) {
+     // check if monotonic timer is available and provides enough accurate resolution:
+     if (clock_getres(CLOCK_MONOTONIC, &tp) == 0) {
+      // long Resolution = tp.tv_nsec;
+        // require a minimum resolution:
+        if (tp.tv_sec == 0 && tp.tv_nsec <= MIN_RESOLUTION * 1000000) {
+           if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0) {
+              monotonic = true;
+           }
+        }
+     }
+     initialized = true;
+  }
+  if (monotonic) {
+     if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
+        return (uint64_t(tp.tv_sec)) * 1000 + tp.tv_nsec / 1000000;
+     monotonic = false;
+     // fall back to gettimeofday()
+  }
+#else
+#  warning Posix monotonic clock not available
+#endif
+  struct timeval t;
+  if (gettimeofday(&t, NULL) == 0)
+     return (uint64_t(t.tv_sec)) * 1000 + t.tv_usec / 1000;
+  return 0;
+}
+
+void cTimeMs::Set(int Ms)
+{
+  begin = Now() + Ms;
+}
+
+bool cTimeMs::TimedOut(void)
+{
+  return Now() >= begin;
+}
+
+uint64_t cTimeMs::Elapsed(void)
+{
+  return Now() - begin;
+}
diff -ruN o/lib/base/condVar.h pc/lib/base/condVar.h
--- o/lib/base/condVar.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/base/condVar.h	2025-07-11 16:39:46.943637602 +0300
@@ -0,0 +1,64 @@
+#ifndef __base_condVar_h
+#define __base_condVar_h
+
+#include <pthread.h>
+
+class cMutex {
+  friend class cCondVar;
+private:
+  pthread_mutex_t mutex;
+  int locked;
+public:
+  cMutex(void);
+  ~cMutex();
+  void Lock(void);
+  void Unlock(void);
+  };
+
+class cCondVar {
+private:
+  pthread_cond_t cond;
+public:
+  cCondVar(void);
+  ~cCondVar();
+  void Wait(cMutex &Mutex);
+  bool TimedWait(cMutex &Mutex, int TimeoutMs);
+  void Broadcast(void);
+  };
+
+class cCondWait {
+private:
+  pthread_mutex_t mutex;
+  pthread_cond_t cond;
+  bool signaled;
+public:
+  cCondWait(void);
+  ~cCondWait();
+  static void SleepMs(int TimeoutMs);
+  bool Wait(int TimeoutMs = 0);
+  void Signal(void);
+  };
+
+class cMutexLock {
+private:
+  cMutex *mutex;
+  bool locked;
+public:
+  cMutexLock(cMutex *Mutex = NULL);
+  ~cMutexLock();
+  bool Lock(cMutex *Mutex);
+  };
+
+class cTimeMs {
+private:
+  uint64_t begin;
+public:
+  cTimeMs(int Ms = 0);
+      ///< Creates a timer with ms resolution and an initial timeout of Ms.
+  static uint64_t Now(void);
+  void Set(int Ms = 0);
+  bool TimedOut(void);
+  uint64_t Elapsed(void);
+  };
+
+#endif
diff -ruN o/lib/base/Makefile.inc pc/lib/base/Makefile.inc
--- o/lib/base/Makefile.inc	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/base/Makefile.inc	2025-07-11 16:39:46.943637602 +0300
@@ -24,7 +24,9 @@
 	base/thread.cpp \
 	base/httpsstream.cpp \
 	base/httpstream.cpp \
-	base/wrappers.cpp
+	base/wrappers.cpp \
+	base/tsRingbuffer.cpp \
+	base/condVar.cpp
 
 EXTRA_DIST += \
 	base/eenv.cpp.in
@@ -59,4 +61,6 @@
 	base/thread.h \
 	base/httpsstream.h \
 	base/httpstream.h \
-	base/wrappers.h
+	base/wrappers.h \
+	base/tsRingbuffer.h \
+	base/condVar.h
diff -ruN o/lib/base/rawfile.cpp pc/lib/base/rawfile.cpp
--- o/lib/base/rawfile.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/base/rawfile.cpp	2025-07-11 16:39:46.943637602 +0300
@@ -3,6 +3,7 @@
 #include <fcntl.h>
 #include <lib/base/rawfile.h>
 #include <lib/base/eerror.h>
+#include <lib/gdi/xineLib.h>
 
 DEFINE_REF(eRawFile);
 
@@ -37,6 +38,13 @@
 	return m_fd;
 }
 
+void eRawFile::setfd(int fd)
+{
+	close();
+	m_nrfiles = 1;
+	m_fd = fd;
+}
+
 off_t eRawFile::lseek_internal(off_t offset)
 {
 //	eDebug("[eRawFile] lseek: %lld, %d", offset, whence);
@@ -171,3 +179,124 @@
 {
 	return m_last_offset;
 }
+
+#define KILOBYTE(n) ((n) * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
+#define AUDIO_STREAM_S   0xC0
+#define AUDIO_STREAM_E   0xDF
+#define VIDEO_STREAM_S   0xE0
+#define VIDEO_STREAM_E   0xEF
+
+eDecryptRawFile::eDecryptRawFile(int packetsize)
+ : eRawFile(packetsize)
+{
+	ringBuffer = new cRingBufferLinear(KILOBYTE(8192),TS_SIZE,true,"IN-TS");
+	ringBuffer->SetTimeouts(100,100);
+	bs_size = dvbcsa_bs_batch_size();
+	delivered=false;
+	lastPacketsCount = 0;
+	stream_correct = false;
+}
+
+eDecryptRawFile::~eDecryptRawFile()
+{
+	delete ringBuffer;
+}
+
+void eDecryptRawFile::setDemux(ePtr<eDVBDemux> _demux) {
+	demux = _demux;
+}
+
+uint8_t* eDecryptRawFile::getPackets(int &packetsCount) {
+	int Count=0;
+	if(delivered) {
+		ringBuffer->Del(lastPacketsCount*TS_SIZE);
+		delivered=false;
+	}
+	packetsCount = 0;
+
+	if (ringBuffer->Available()<bs_size*TS_SIZE)
+		return NULL;
+
+	uint8_t* p=ringBuffer->Get(Count);
+	if (Count>KILOBYTE(16))
+		Count = KILOBYTE(16);
+
+	if(p && Count>=TS_SIZE) {
+		if(*p!=TS_SYNC_BYTE) {
+			for(int i=1; i<Count; i++) {
+				if(p[i]==TS_SYNC_BYTE && (i+TS_SIZE==Count || (i+TS_SIZE>Count && p[i+TS_SIZE]==TS_SYNC_BYTE))) {
+					Count=i;
+					break;
+				}
+				ringBuffer->Del(Count);
+				eDebug("ERROR: skipped %d bytes to sync on TS packet", Count);
+				return NULL;
+			}
+		}
+		if(!demux->decrypt(p, Count, packetsCount)) {
+			cCondWait::SleepMs(20);
+			return NULL;
+		}
+		lastPacketsCount = packetsCount;
+		delivered=true;
+		return p;
+	}
+
+	return NULL;
+}
+
+ssize_t eDecryptRawFile::read(off_t offset, void *buf, size_t count)
+{
+	eSingleLocker l(m_lock);
+	int ret = 0;
+
+	while (ringBuffer->Available()<KILOBYTE(32)) {
+		ret = ringBuffer->Read(m_fd, KILOBYTE(16));
+		if (ret<0)
+			break;
+	}
+
+	int packetsCount = 0;
+
+	uint8_t *data = getPackets(packetsCount);
+
+	ret = -EBUSY;
+	if (data && packetsCount>0) {
+		if (!stream_correct) {
+			for (int i=0; i<packetsCount; i++) {
+				unsigned char* packet = data+i*TS_SIZE;
+				int adaptation_field_exist = (packet[3]&0x30)>>4;
+				unsigned char* wsk;
+				int len;
+
+				if (adaptation_field_exist==3) {
+					wsk = packet+5+packet[4];
+					len = 183-packet[4];
+				} else {
+					wsk = packet+4;
+					len = 184;
+				}
+
+				if (len>4 && wsk[0]==0 && wsk[1]==0 && wsk[2]==1
+						&& ((wsk[3]>=VIDEO_STREAM_S && wsk[3]<=VIDEO_STREAM_E)
+						|| (wsk[3]>=AUDIO_STREAM_S && wsk[3]<=AUDIO_STREAM_E))) {
+					stream_correct = true;
+					printf("**************** I HAVE PES (%02X)\n", wsk[3]);
+					ret = (packetsCount-i)*TS_SIZE;
+					memcpy(buf, packet, (packetsCount-i)*TS_SIZE);
+// When channel descramble, then start xineLib-playVideo()
+					cXineLib *xineLib = cXineLib::getInstance();
+					xineLib->setScrambled(false);
+					xineLib->playVideo();
+					break;
+				}
+			}
+		} else {
+			ret = packetsCount*TS_SIZE;
+			memcpy(buf, data, ret);
+		}
+	}
+
+	return ret;
+}
diff -ruN o/lib/base/rawfile.h pc/lib/base/rawfile.h
--- o/lib/base/rawfile.h	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/base/rawfile.h	2025-07-11 16:39:46.944637547 +0300
@@ -3,23 +3,27 @@
 
 #include <string>
 #include <lib/base/itssource.h>
+#include <lib/base/tsRingbuffer.h>
+#include <lib/dvb/edvbdemux.h>
 
 class eRawFile: public iTsSource
 {
 	DECLARE_REF(eRawFile);
-	eSingleLock m_lock;
 public:
 	eRawFile(int packetsize = 188);
 	~eRawFile();
 	int open(const char *filename);
+	void setfd(int fd);
 
 	// iTsSource
 	ssize_t read(off_t offset, void *buf, size_t count);
 	off_t length();
 	off_t offset();
 	int valid();
-private:
+protected:
+	eSingleLock m_lock;
 	int m_fd;
+private:
 	int m_nrfiles;
 	off_t m_splitsize;
 	off_t m_totallength;
@@ -36,4 +40,22 @@
 	int openFileUncached(int nr);
 };
 
+class eDecryptRawFile: public eRawFile
+{
+public:
+	eDecryptRawFile(int packetsize = 188);
+	~eDecryptRawFile();
+	void setDemux(ePtr<eDVBDemux> demux);
+	ssize_t read(off_t offset, void *buf, size_t count);
+private:
+	ePtr<eDVBDemux> demux;
+	cRingBufferLinear *ringBuffer;
+	int bs_size;
+	bool delivered;
+	int lastPacketsCount;
+	bool stream_correct;
+
+	uint8_t* getPackets(int &packetsCount);
+};
+
 #endif
diff -ruN o/lib/base/tsRingbuffer.cpp pc/lib/base/tsRingbuffer.cpp
--- o/lib/base/tsRingbuffer.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/base/tsRingbuffer.cpp	2025-07-11 16:39:46.944637547 +0300
@@ -0,0 +1,328 @@
+/*
+ * tsRingbuffer.cpp: A ring buffer
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ * Parts of this file were inspired by the 'ringbuffy.c' from the
+ * LinuxDVB driver (see linuxtv.org).
+ *
+ * $Id: TsRingbuffer.c 4.2 2017/03/19 12:43:36 kls Exp $
+ */
+
+#include "tsRingbuffer.h"
+#include <stdlib.h>
+#include <unistd.h>
+
+// --- cRingBuffer -----------------------------------------------------------
+
+#define OVERFLOWREPORTDELTA 5 // seconds between reports
+#define PERCENTAGEDELTA     10
+#define PERCENTAGETHRESHOLD 70
+
+cRingBuffer::cRingBuffer(int Size, bool Statistics)
+{
+	size = Size;
+	statistics = Statistics;
+	maxFill = 0;
+	lastPercent = 0;
+	putTimeout = getTimeout = 0;
+	lastOverflowReport = 0;
+	overflowCount = overflowBytes = 0;
+}
+
+cRingBuffer::~cRingBuffer()
+{
+	if (statistics)
+		printf("buffer stats: %d (%d%%) used", maxFill, maxFill * 100 / (size - 1));
+}
+
+void cRingBuffer::UpdatePercentage(int Fill)
+{
+	if (Fill > maxFill)
+		maxFill = Fill;
+	int percent = Fill * 100 / (Size() - 1) / PERCENTAGEDELTA * PERCENTAGEDELTA; // clamp down to nearest quantum
+	if (percent != lastPercent) {
+		if ((percent >= PERCENTAGETHRESHOLD && percent > lastPercent) || (percent < PERCENTAGETHRESHOLD && lastPercent >= PERCENTAGETHRESHOLD)) {
+			printf("buffer usage: %d%%", percent);
+			lastPercent = percent;
+		}
+	}
+}
+
+void cRingBuffer::WaitForPut(void)
+{
+	if (putTimeout)
+		readyForPut.Wait(putTimeout);
+}
+
+void cRingBuffer::WaitForGet(void)
+{
+	if (getTimeout)
+		readyForGet.Wait(getTimeout);
+}
+
+void cRingBuffer::EnablePut(void)
+{
+	if (putTimeout && Free() > Size() / 10)
+		readyForPut.Signal();
+}
+
+void cRingBuffer::EnableGet(void)
+{
+	if (getTimeout && Available() > Size() / 10)
+		readyForGet.Signal();
+}
+
+void cRingBuffer::SetTimeouts(int PutTimeout, int GetTimeout)
+{
+	putTimeout = PutTimeout;
+	getTimeout = GetTimeout;
+}
+
+void cRingBuffer::ReportOverflow(int Bytes)
+{
+	overflowCount++;
+	overflowBytes += Bytes;
+	if (time(NULL) - lastOverflowReport > OVERFLOWREPORTDELTA) {
+		printf("ERROR: %d ring buffer overflow%s (%d bytes dropped)", overflowCount, overflowCount > 1 ? "s" : "", overflowBytes);
+		overflowCount = overflowBytes = 0;
+		lastOverflowReport = time(NULL);
+	}
+}
+
+// --- cRingBufferLinear -----------------------------------------------------
+
+#ifdef DEBUGRINGBUFFERS
+#define MAXRBLS 30
+#define DEBUGRBLWIDTH 45
+
+cRingBufferLinear *cRingBufferLinear::RBLS[MAXRBLS] = { NULL };
+
+void cRingBufferLinear::AddDebugRBL(cRingBufferLinear *RBL)
+{
+	for (int i = 0; i < MAXRBLS; i++) {
+		if (!RBLS[i]) {
+			RBLS[i] = RBL;
+			break;
+		}
+	}
+}
+
+void cRingBufferLinear::DelDebugRBL(cRingBufferLinear *RBL)
+{
+	for (int i = 0; i < MAXRBLS; i++) {
+		if (RBLS[i] == RBL) {
+			RBLS[i] = NULL;
+			break;
+		}
+	}
+}
+
+void cRingBufferLinear::PrintDebugRBL(void)
+{
+	bool printed = false;
+	for (int i = 0; i < MAXRBLS; i++) {
+		cRingBufferLinear *p = RBLS[i];
+		if (p) {
+			printed = true;
+			int lh = p->lastHead;
+			int lt = p->lastTail;
+			int h = lh * DEBUGRBLWIDTH / p->Size();
+			int t = lt * DEBUGRBLWIDTH / p->Size();
+			char buf[DEBUGRBLWIDTH + 10];
+			memset(buf, '-', DEBUGRBLWIDTH);
+			if (lt <= lh)
+				memset(buf + t, '*', std::max(h - t, 1));
+			else {
+				memset(buf, '*', h);
+				memset(buf + t, '*', DEBUGRBLWIDTH - t);
+			}
+			buf[t] = '<';
+			buf[h] = '>';
+			buf[DEBUGRBLWIDTH] = 0;
+			printf("%2d %s %8d %8d %s\n", i, buf, p->lastPut, p->lastGet, p->description);
+		}
+	}
+	if (printed)
+		printf("\n");
+}
+#endif
+
+	cRingBufferLinear::cRingBufferLinear(int Size, int Margin, bool Statistics, const char *Description):cRingBuffer(Size, Statistics)
+{
+		description = Description ? strdup(Description) : NULL;
+		tail = head = margin = Margin;
+		gotten = 0;
+		buffer = NULL;
+		if (Size > 1) { // 'Size - 1' must not be 0!
+			if (Margin <= Size / 2) {
+				buffer = MALLOC(uchar, Size);
+			if (!buffer)
+				printf("ERROR: can't allocate ring buffer (size=%d)", Size);
+			Clear();
+			}
+			else
+				printf("ERROR: invalid margin for ring buffer (%d > %d)", Margin, Size / 2);
+		} else
+			printf("ERROR: invalid size for ring buffer (%d)", Size);
+#ifdef DEBUGRINGBUFFERS
+		lastHead = head;
+		lastTail = tail;
+		lastPut = lastGet = -1;
+		AddDebugRBL(this);
+#endif
+}
+
+cRingBufferLinear::~cRingBufferLinear()
+{
+#ifdef DEBUGRINGBUFFERS
+	DelDebugRBL(this);
+#endif
+	free(buffer);
+	free(description);
+}
+
+int cRingBufferLinear::DataReady(const uchar *Data, int Count)
+{
+	return Count >= margin ? Count : 0;
+}
+
+int cRingBufferLinear::Available(void)
+{
+	int diff = head - tail;
+	return (diff >= 0) ? diff : Size() + diff - margin;
+}
+
+void cRingBufferLinear::Clear(void)
+{
+	int Head = head;
+	tail = Head;
+#ifdef DEBUGRINGBUFFERS
+	lastHead = Head;
+	lastTail = tail;
+	lastPut = lastGet = -1;
+#endif
+	maxFill = 0;
+	EnablePut();
+}
+
+int cRingBufferLinear::Read(int FileHandle, int Max)
+{
+	int Tail = tail;
+	int diff = Tail - head;
+	int free = (diff > 0) ? diff - 1 : Size() - head;
+	if (Tail <= margin)
+		free--;
+	int Count = -1;
+	errno = EAGAIN;
+	if (free > 0) {
+		if (0 < Max && Max < free)
+			free = Max;
+		Count = read(FileHandle, buffer + head, free);
+		if (Count > 0) {
+			int Head = head + Count;
+			if (Head >= Size())
+				Head = margin;
+			head = Head;
+			if (statistics) {
+				int fill = head - Tail;
+				if (fill < 0)
+					fill = Size() + fill;
+				else if (fill >= Size())
+					fill = Size() - 1;
+				UpdatePercentage(fill);
+			}
+		}
+	}
+#ifdef DEBUGRINGBUFFERS
+	lastHead = head;
+	lastPut = Count;
+#endif
+	EnableGet();
+	if (free == 0)
+		WaitForPut();
+	return Count;
+}
+
+int cRingBufferLinear::Put(const uchar *Data, int Count)
+{
+	if (Count > 0) {
+		int Tail = tail;
+		int rest = Size() - head;
+		int diff = Tail - head;
+		int free = ((Tail < margin) ? rest : (diff > 0) ? diff : Size() + diff - margin) - 1;
+		if (statistics) {
+			int fill = Size() - free - 1 + Count;
+			if (fill >= Size())
+				fill = Size() - 1;
+			UpdatePercentage(fill);
+			}
+		if (free > 0) {
+			if (free < Count)
+				Count = free;
+			if (Count >= rest) {
+				memcpy(buffer + head, Data, rest);
+				if (Count - rest)
+					memcpy(buffer + margin, Data + rest, Count - rest);
+				head = margin + Count - rest;
+			} else {
+			memcpy(buffer + head, Data, Count);
+			head += Count;
+			}
+		}
+		else
+			Count = 0;
+#ifdef DEBUGRINGBUFFERS
+			lastHead = head;
+			lastPut = Count;
+#endif
+			EnableGet();
+			if (Count == 0)
+				WaitForPut();
+	}
+	return Count;
+}
+
+uchar *cRingBufferLinear::Get(int &Count)
+{
+	int Head = head;
+	int rest = Size() - tail;
+	if (rest < margin && Head < tail) {
+		int t = margin - rest;
+		memcpy(buffer + t, buffer + tail, rest);
+		tail = t;
+		rest = Head - tail;
+	}
+	int diff = Head - tail;
+	int cont = (diff >= 0) ? diff : Size() + diff - margin;
+	if (cont > rest)
+		cont = rest;
+	uchar *p = buffer + tail;
+	if ((cont = DataReady(p, cont)) > 0) {
+		Count = gotten = cont;
+		return p;
+	}
+	WaitForGet();
+	return NULL;
+}
+
+void cRingBufferLinear::Del(int Count)
+{
+	if (Count > gotten) {
+		printf("ERROR: invalid Count in cRingBufferLinear::Del: %d (limited to %d)", Count, gotten);
+		Count = gotten;
+	}
+	if (Count > 0) {
+		int Tail = tail;
+		Tail += Count;
+		gotten -= Count;
+		if (Tail >= Size())
+			Tail = margin;
+		tail = Tail;
+		EnablePut();
+	}
+#ifdef DEBUGRINGBUFFERS
+	lastTail = tail;
+	lastGet = Count;
+#endif
+}
diff -ruN o/lib/base/tsRingbuffer.h pc/lib/base/tsRingbuffer.h
--- o/lib/base/tsRingbuffer.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/base/tsRingbuffer.h	2025-07-11 16:39:46.944637547 +0300
@@ -0,0 +1,106 @@
+/*
+ * tsRingbuffer.h: A ring buffer
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: tsRingbuffer.h 4.2 2017/03/19 13:11:39 kls Exp $
+ */
+
+#ifndef __RINGBUFFER_H
+#define __RINGBUFFER_H
+#define MALLOC(type, size)  (type *)malloc(sizeof(type) * (size))
+
+#include "condVar.h"
+
+typedef unsigned char uchar;
+
+ssize_t safe_read(int filedes, void *buffer, size_t size);
+
+class cRingBuffer {
+private:
+	cCondWait readyForPut, readyForGet;
+	int putTimeout;
+	int getTimeout;
+	int size;
+	time_t lastOverflowReport;
+	int overflowCount;
+	int overflowBytes;
+protected:
+	int maxFill;//XXX
+	int lastPercent;
+	bool statistics;//XXX
+	void UpdatePercentage(int Fill);
+	void WaitForPut(void);
+	void WaitForGet(void);
+	void EnablePut(void);
+	void EnableGet(void);
+	virtual void Clear(void) = 0;
+	virtual int Available(void) = 0;
+	virtual int Free(void) { return Size() - Available() - 1; }
+	int Size(void) { return size; }
+public:
+	cRingBuffer(int Size, bool Statistics = false);
+	virtual ~cRingBuffer();
+	void SetTimeouts(int PutTimeout, int GetTimeout);
+	void ReportOverflow(int Bytes);
+};
+
+class cRingBufferLinear : public cRingBuffer {
+#define DEBUGRINGBUFFERS
+#ifdef DEBUGRINGBUFFERS
+private:
+	int lastHead, lastTail;
+	int lastPut, lastGet;
+	static cRingBufferLinear *RBLS[];
+	static void AddDebugRBL(cRingBufferLinear *RBL);
+	static void DelDebugRBL(cRingBufferLinear *RBL);
+public:
+	static void PrintDebugRBL(void);
+#endif
+private:
+	int margin, head, tail;
+	int gotten;
+	uchar *buffer;
+	char *description;
+protected:
+	virtual int DataReady(const uchar *Data, int Count);
+	/*< By default a ring buffer has data ready as soon as there are at least
+	< 'margin' bytes available. A derived class can reimplement this function
+	< if it has other conditions that define when data is ready.
+	< The return value is either 0 if there is not yet enough data available,
+	< or the number of bytes from the beginning of Data that are "ready".*/
+public:
+	cRingBufferLinear(int Size, int Margin = 0, bool Statistics = false, const char *Description = NULL);
+	/*< Creates a linear ring buffer.
+	< The buffer will be able to hold at most Size-Margin-1 bytes of data, and will
+	< be guaranteed to return at least Margin bytes in one consecutive block.
+	< The optional Description is used for debugging only.*/
+	virtual ~cRingBufferLinear();
+	virtual int Available(void);
+	virtual int Free(void) { return Size() - Available() - 1 - margin; }
+	virtual void Clear(void);
+	/*< Immediately clears the ring buffer.
+	< This function may safely be called from the reading thread without additional
+	< locking. If called from the writing thread, proper locking must be used.*/
+	int Read(int FileHandle, int Max = 0);
+	/*< Reads at most Max bytes from FileHandle and stores them in the
+	< ring buffer. If Max is 0, reads as many bytes as possible.
+	< Only one actual read() call is done.
+	< Returns the number of bytes actually read and stored, or
+	< an error value from the actual read() call.*/
+	int Put(const uchar *Data, int Count);
+	/*< Puts at most Count bytes of Data into the ring buffer.
+	< Returns the number of bytes actually stored.*/
+	uchar *Get(int &Count);
+	/*< Gets data from the ring buffer.
+	< The data will remain in the buffer until a call to Del() deletes it.
+	< Returns a pointer to the data, and stores the number of bytes
+	< actually available in Count. If the returned pointer is NULL, Count has no meaning.*/
+	void Del(int Count);
+	/*< Deletes at most Count bytes from the ring buffer.
+	< Count must be less or equal to the number that was returned by a previous
+	< call to Get().*/
+};
+
+#endif // __RINGBUFFER_H
diff -ruN o/lib/driver/avswitch.cpp pc/lib/driver/avswitch.cpp
--- o/lib/driver/avswitch.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/avswitch.cpp	2025-07-11 16:39:46.945637493 +0300
@@ -9,6 +9,7 @@
 #include <lib/base/eerror.h>
 #include <lib/base/ebase.h>
 #include <lib/driver/avswitch.h>
+#include <lib/gdi/xineLib.h>
 
 eAVSwitch *eAVSwitch::instance = 0;
 
@@ -21,7 +22,6 @@
 	m_fp_fd = open("/dev/dbox/fp0", O_RDONLY|O_NONBLOCK);
 	if (m_fp_fd == -1)
 	{
-		eDebug("[eAVSwitch] failed to open /dev/dbox/fp0 to monitor vcr scart slow blanking changed: %m");
 		m_fp_notifier=0;
 	}
 	else
@@ -184,6 +184,9 @@
 
 void eAVSwitch::setAspectRatio(int ratio)
 {
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->setAspectRatio(ratio);
+
 	/*
 	0-4:3 Letterbox
 	1-4:3 PanScan
@@ -302,5 +305,41 @@
 	close(fd);
 }
 
+void eAVSwitch::setPolicy43(int mode) {
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->setPolicy43(mode);
+}
+
+void eAVSwitch::setPolicy169(int mode) {
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->setPolicy169(mode);
+}
+
+void eAVSwitch::setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y) {
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->setZoom(zoom43_x, zoom43_y, zoom169_x, zoom169_y);
+}
+
+void eAVSwitch::updateScreen() {
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->adjust_policy();
+}
+
+void eAVSwitch::setDeinterlace(int global, int sd, int hd)
+{
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->setDeinterlace(global, sd, hd);
+}
+
+void eAVSwitch::setSDfeatures(int sharpness, int noise) {
+	cXineLib *xineLib = cXineLib::getInstance();
+	cXineLib::getInstance()->setSDfeatures(sharpness, noise);
+}
+
+void eAVSwitch::setBufMetronom(int hevc, int avc, int mpeg2) {
+        cXineLib *xineLib = cXineLib::getInstance();
+        cXineLib::getInstance()->setBufMetronom(hevc, avc, mpeg2);
+}
+
 //FIXME: correct "run/startlevel"
 eAutoInitP0<eAVSwitch> init_avswitch(eAutoInitNumbers::rc, "AVSwitch Driver");
diff -ruN o/lib/driver/avswitch.h pc/lib/driver/avswitch.h
--- o/lib/driver/avswitch.h	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/avswitch.h	2025-07-11 16:39:46.945637493 +0300
@@ -29,9 +29,16 @@
 	int getVCRSlowBlanking();
 	void setColorFormat(int format);
 	void setAspectRatio(int ratio);
+	void setPolicy43(int mode);
+	void setPolicy169(int mode);
+	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
+	void updateScreen();
 	void setVideomode(int mode);
 	void setInput(int val);
 	void setWSS(int val);
+	void setDeinterlace(int global, int sd, int hd);
+	void setSDfeatures(int sharpness, int noise);
+	void setBufMetronom(int hevc, int avc, int mpeg2);
 	bool isActive();
 	PSignal1<void, int> vcr_sb_notifier;
 };
diff -ruN o/lib/driver/hdmi_cec.cpp pc/lib/driver/hdmi_cec.cpp
--- o/lib/driver/hdmi_cec.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/hdmi_cec.cpp	2025-07-11 16:39:46.946637438 +0300
@@ -154,10 +154,6 @@
 		messageNotifier = eSocketNotifier::create(eApp, hdmiFd, eSocketNotifier::Read | eSocketNotifier::Priority);
 		CONNECT(messageNotifier->activated, eHdmiCEC::hdmiEvent);
 	}
-	else
-	{
-		eDebug("[eHdmiCEC] cannot open %s: %m", HDMIDEV);
-	}
 
 	getAddressInfo();
 }
diff -ruN o/lib/driver/Makefile.inc pc/lib/driver/Makefile.inc
--- o/lib/driver/Makefile.inc	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/Makefile.inc	2025-07-11 16:39:46.946637438 +0300
@@ -31,3 +31,12 @@
 	driver/rcsdl.cpp \
 	driver/rcsdl.h
 endif
+
+if HAVE_XLIB
+driver_libenigma_driver_a_SOURCES += \
+	driver/rclirc.cpp \
+	driver/rclirc.h \
+	driver/rcxlib.cpp \
+	driver/rcxlib.h
+endif
+
diff -ruN o/lib/driver/rcconsole.cpp pc/lib/driver/rcconsole.cpp
--- o/lib/driver/rcconsole.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/rcconsole.cpp	2025-07-11 16:39:46.946637438 +0300
@@ -111,4 +111,6 @@
 	}
 };
 
+#ifndef WITH_XLIB
 eAutoInitP0<eRCConsoleInit> init_rcconsole(eAutoInitNumbers::rc+1, "Console RC Driver");
+#endif
diff -ruN o/lib/driver/rcinput.cpp pc/lib/driver/rcinput.cpp
--- o/lib/driver/rcinput.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/rcinput.cpp	2025-07-11 16:39:46.947637384 +0300
@@ -208,6 +208,7 @@
 	}
 };
 
+#ifndef WITH_XLIB
 eAutoInitP0<eInputDeviceInit> init_rcinputdev(eAutoInitNumbers::rc+1, "input device driver");
 
 void addInputDevice(const char* filename)
@@ -219,3 +220,4 @@
 {
 	init_rcinputdev->remove(filename);
 }
+#endif
diff -ruN o/lib/driver/rclirc.cpp pc/lib/driver/rclirc.cpp
--- o/lib/driver/rclirc.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/driver/rclirc.cpp	2025-07-11 16:39:46.947637384 +0300
@@ -0,0 +1,586 @@
+/*
+ * LIRC support based on LIRC for VDR, which was written by
+ * Carsten Koch.
+ *
+ */
+
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <lib/driver/rclirc.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/base/condVar.h>
+#include <lib/driver/input_fake.h>
+
+
+static tKey keyTable[] = { // "Up" and "Down" must be the first two keys!
+	{ KEY_RESERVED,         "KEY_RESERVED"         },
+	{ KEY_ESC,              "KEY_ESC"              },
+	{ KEY_1,                "KEY_1"                },
+	{ KEY_2,                "KEY_2"                },
+	{ KEY_3,                "KEY_3"                },
+	{ KEY_4,                "KEY_4"                },
+	{ KEY_5,                "KEY_5"                },
+	{ KEY_6,                "KEY_6"                },
+	{ KEY_7,                "KEY_7"                },
+	{ KEY_8,                "KEY_8"                },
+	{ KEY_9,                "KEY_9"                },
+	{ KEY_0,                "KEY_0"                },
+	{ KEY_MINUS,            "KEY_MINUS"            },
+	{ KEY_EQUAL,            "KEY_EQUAL"            },
+	{ KEY_BACKSPACE,        "KEY_BACKSPACE"        },
+	{ KEY_TAB,              "KEY_TAB"              },
+	{ KEY_Q,                "KEY_Q"                },
+	{ KEY_W,                "KEY_W"                },
+	{ KEY_E,                "KEY_E"                },
+	{ KEY_R,                "KEY_R"                },
+	{ KEY_T,                "KEY_T"                },
+	{ KEY_Y,                "KEY_Y"                },
+	{ KEY_U,                "KEY_U"                },
+	{ KEY_I,                "KEY_I"                },
+	{ KEY_O,                "KEY_O"                },
+	{ KEY_P,                "KEY_P"                },
+	{ KEY_LEFTBRACE,        "KEY_LEFTBRACE"        },
+	{ KEY_RIGHTBRACE,       "KEY_RIGHTBRACE"       },
+	{ KEY_ENTER,            "KEY_ENTER"            },
+	{ KEY_LEFTCTRL,         "KEY_LEFTCTRL"         },
+	{ KEY_A,                "KEY_A"                },
+	{ KEY_S,                "KEY_S"                },
+	{ KEY_D,                "KEY_D"                },
+	{ KEY_F,                "KEY_F"                },
+	{ KEY_G,                "KEY_G"                },
+	{ KEY_H,                "KEY_H"                },
+	{ KEY_J,                "KEY_J"                },
+	{ KEY_K,                "KEY_K"                },
+	{ KEY_L,                "KEY_L"                },
+	{ KEY_SEMICOLON,        "KEY_SEMICOLON"        },
+	{ KEY_APOSTROPHE,       "KEY_APOSTROPHE"       },
+	{ KEY_GRAVE,            "KEY_GRAVE"            },
+	{ KEY_LEFTSHIFT,        "KEY_LEFTSHIFT"        },
+	{ KEY_BACKSLASH,        "KEY_BACKSLASH"        },
+	{ KEY_Z,                "KEY_Z"                },
+	{ KEY_X,                "KEY_X"                },
+	{ KEY_C,                "KEY_C"                },
+	{ KEY_V,                "KEY_V"                },
+	{ KEY_B,                "KEY_B"                },
+	{ KEY_N,                "KEY_N"                },
+	{ KEY_M,                "KEY_M"                },
+	{ KEY_COMMA,            "KEY_COMMA"            },
+	{ KEY_DOT,              "KEY_DOT"              },
+	{ KEY_SLASH,            "KEY_SLASH"            },
+	{ KEY_RIGHTSHIFT,       "KEY_RIGHTSHIFT"       },
+	{ KEY_KPASTERISK,       "KEY_KPASTERISK"       },
+	{ KEY_LEFTALT,          "KEY_LEFTALT"          },
+	{ KEY_SPACE,            "KEY_SPACE"            },
+	{ KEY_CAPSLOCK,         "KEY_CAPSLOCK"         },
+	{ KEY_F1,               "KEY_F1"               },
+	{ KEY_F2,               "KEY_F2"               },
+	{ KEY_F3,               "KEY_F3"               },
+	{ KEY_F4,               "KEY_F4"               },
+	{ KEY_F5,               "KEY_F5"               },
+	{ KEY_F6,               "KEY_F6"               },
+	{ KEY_F7,               "KEY_F7"               },
+	{ KEY_F8,               "KEY_F8"               },
+	{ KEY_F9,               "KEY_F9"               },
+	{ KEY_F10,              "KEY_F10"              },
+	{ KEY_NUMLOCK,          "KEY_NUMLOCK"          },
+	{ KEY_SCROLLLOCK,       "KEY_SCROLLLOCK"       },
+	{ KEY_KP7,              "KEY_KP7"              },
+	{ KEY_KP8,              "KEY_KP8"              },
+	{ KEY_KP9,              "KEY_KP9"              },
+	{ KEY_KPMINUS,          "KEY_KPMINUS"          },
+	{ KEY_KP4,              "KEY_KP4"              },
+	{ KEY_KP5,              "KEY_KP5"              },
+	{ KEY_KP6,              "KEY_KP6"              },
+	{ KEY_KP1,              "KEY_KP1"              },
+	{ KEY_KP2,              "KEY_KP2"              },
+	{ KEY_KP3,              "KEY_KP3"              },
+	{ KEY_KP0,              "KEY_KP0"              },
+	{ KEY_KPDOT,            "KEY_KPDOT"            },
+	{ KEY_ZENKAKUHANKAKU,   "KEY_ZENKAKUHANKAKU"   },
+	{ KEY_102ND,            "KEY_102ND"            },
+	{ KEY_F11,              "KEY_F11"              },
+	{ KEY_F12,              "KEY_F12"              },
+	{ KEY_RO,               "KEY_RO"               },
+	{ KEY_KATAKANA,         "KEY_KATAKANA"         },
+	{ KEY_HIRAGANA,         "KEY_HIRAGANA"         },
+	{ KEY_HENKAN,           "KEY_HENKAN"           },
+	{ KEY_KATAKANAHIRAGANA, "KEY_KATAKANAHIRAGANA" },
+	{ KEY_MUHENKAN,         "KEY_MUHENKAN"         },
+	{ KEY_KPJPCOMMA,        "KEY_KPJPCOMMA"        },
+	{ KEY_KPENTER,          "KEY_KPENTER"          },
+	{ KEY_RIGHTCTRL,        "KEY_RIGHTCTRL"        },
+	{ KEY_KPSLASH,          "KEY_KPSLASH"          },
+	{ KEY_SYSRQ,            "KEY_SYSRQ"            },
+	{ KEY_RIGHTALT,         "KEY_RIGHTALT"         },
+	{ KEY_LINEFEED,         "KEY_LINEFEED"         },
+	{ KEY_HOME,             "KEY_HOME"             },
+	{ KEY_UP,               "KEY_UP"               },
+	{ KEY_PAGEUP,           "KEY_PAGEUP"           },
+	{ KEY_LEFT,             "KEY_LEFT"             },
+	{ KEY_RIGHT,            "KEY_RIGHT"            },
+	{ KEY_END,              "KEY_END"              },
+	{ KEY_DOWN,             "KEY_DOWN"             },
+	{ KEY_PAGEDOWN,         "KEY_PAGEDOWN"         },
+	{ KEY_INSERT,           "KEY_INSERT"           },
+	{ KEY_DELETE,           "KEY_DELETE"           },
+	{ KEY_MACRO,            "KEY_MACRO"            },
+	{ KEY_MUTE,             "KEY_MUTE"             },
+	{ KEY_VOLUMEDOWN,       "KEY_VOLUMEDOWN"       },
+	{ KEY_VOLUMEUP,         "KEY_VOLUMEUP"         },
+	{ KEY_POWER,            "KEY_POWER"            },
+	{ KEY_KPEQUAL,          "KEY_KPEQUAL"          },
+	{ KEY_KPPLUSMINUS,      "KEY_KPPLUSMINUS"      },
+	{ KEY_PAUSE,            "KEY_PAUSE"            },
+	{ KEY_SCALE,            "KEY_SCALE"            },
+	{ KEY_KPCOMMA,          "KEY_KPCOMMA"          },
+	{ KEY_HANGEUL,          "KEY_HANGEUL"          },
+	{ KEY_HANGUEL,          "KEY_HANGUEL"          },
+	{ KEY_HANJA,            "KEY_HANJA"            },
+	{ KEY_YEN,              "KEY_YEN"              },
+	{ KEY_LEFTMETA,         "KEY_LEFTMETA"         },
+	{ KEY_RIGHTMETA,        "KEY_RIGHTMETA"        },
+	{ KEY_COMPOSE,          "KEY_COMPOSE"          },
+	{ KEY_STOP,             "KEY_STOP"             },
+	{ KEY_AGAIN,            "KEY_AGAIN"            },
+	{ KEY_PROPS,            "KEY_PROPS"            },
+	{ KEY_UNDO,             "KEY_UNDO"             },
+	{ KEY_FRONT,            "KEY_FRONT"            },
+	{ KEY_COPY,             "KEY_COPY"             },
+	{ KEY_OPEN,             "KEY_OPEN"             },
+	{ KEY_PASTE,            "KEY_PASTE"            },
+	{ KEY_FIND,             "KEY_FIND"             },
+	{ KEY_CUT,              "KEY_CUT"              },
+	{ KEY_HELP,             "KEY_HELP"             },
+	{ KEY_MENU,             "KEY_MENU"             },
+	{ KEY_CALC,             "KEY_CALC"             },
+	{ KEY_SETUP,            "KEY_SETUP"            },
+	{ KEY_SLEEP,            "KEY_SLEEP"            },
+	{ KEY_WAKEUP,           "KEY_WAKEUP"           },
+	{ KEY_FILE,             "KEY_FILE"             },
+	{ KEY_SENDFILE,         "KEY_SENDFILE"         },
+	{ KEY_DELETEFILE,       "KEY_DELETEFILE"       },
+	{ KEY_XFER,             "KEY_XFER"             },
+	{ KEY_PROG1,            "KEY_PROG1"            },
+	{ KEY_PROG2,            "KEY_PROG2"            },
+	{ KEY_WWW,              "KEY_WWW"              },
+	{ KEY_MSDOS,            "KEY_MSDOS"            },
+	{ KEY_COFFEE,           "KEY_COFFEE"           },
+	{ KEY_SCREENLOCK,       "KEY_SCREENLOCK"       },
+	{ KEY_DIRECTION,        "KEY_DIRECTION"        },
+	{ KEY_CYCLEWINDOWS,     "KEY_CYCLEWINDOWS"     },
+	{ KEY_MAIL,             "KEY_MAIL"             },
+	{ KEY_BOOKMARKS,        "KEY_BOOKMARKS"        },
+	{ KEY_COMPUTER,         "KEY_COMPUTER"         },
+	{ KEY_BACK,             "KEY_BACK"             },
+	{ KEY_FORWARD,          "KEY_FORWARD"          },
+	{ KEY_CLOSECD,          "KEY_CLOSECD"          },
+	{ KEY_EJECTCD,          "KEY_EJECTCD"          },
+	{ KEY_EJECTCLOSECD,     "KEY_EJECTCLOSECD"     },
+	{ KEY_NEXTSONG,         "KEY_NEXTSONG"         },
+	{ KEY_PLAYPAUSE,        "KEY_PLAYPAUSE"        },
+	{ KEY_PREVIOUSSONG,     "KEY_PREVIOUSSONG"     },
+	{ KEY_STOPCD,           "KEY_STOPCD"           },
+	{ KEY_RECORD,           "KEY_RECORD"           },
+	{ KEY_REWIND,           "KEY_REWIND"           },
+	{ KEY_PHONE,            "KEY_PHONE"            },
+	{ KEY_ISO,              "KEY_ISO"              },
+	{ KEY_CONFIG,           "KEY_CONFIG"           },
+	{ KEY_HOMEPAGE,         "KEY_HOMEPAGE"         },
+	{ KEY_REFRESH,          "KEY_REFRESH"          },
+	{ KEY_EXIT,             "KEY_EXIT"             },
+	{ KEY_MOVE,             "KEY_MOVE"             },
+	{ KEY_EDIT,             "KEY_EDIT"             },
+	{ KEY_SCROLLUP,         "KEY_SCROLLUP"         },
+	{ KEY_SCROLLDOWN,       "KEY_SCROLLDOWN"       },
+	{ KEY_KPLEFTPAREN,      "KEY_KPLEFTPAREN"      },
+	{ KEY_KPRIGHTPAREN,     "KEY_KPRIGHTPAREN"     },
+	{ KEY_NEW,              "KEY_NEW"              },
+	{ KEY_REDO,             "KEY_REDO"             },
+	{ KEY_F13,              "KEY_F13"              },
+	{ KEY_F14,              "KEY_F14"              },
+	{ KEY_F15,              "KEY_F15"              },
+	{ KEY_F16,              "KEY_F16"              },
+	{ KEY_F17,              "KEY_F17"              },
+	{ KEY_F18,              "KEY_F18"              },
+	{ KEY_F19,              "KEY_F19"              },
+	{ KEY_F20,              "KEY_F20"              },
+	{ KEY_F21,              "KEY_F21"              },
+	{ KEY_F22,              "KEY_F22"              },
+	{ KEY_F23,              "KEY_F23"              },
+	{ KEY_F24,              "KEY_F24"              },
+	{ KEY_PLAYCD,           "KEY_PLAYCD"           },
+	{ KEY_PAUSECD,          "KEY_PAUSECD"          },
+	{ KEY_PROG3,            "KEY_PROG3"            },
+	{ KEY_PROG4,            "KEY_PROG4"            },
+	{ KEY_DASHBOARD,        "KEY_DASHBOARD"        },
+	{ KEY_SUSPEND,          "KEY_SUSPEND"          },
+	{ KEY_CLOSE,            "KEY_CLOSE"            },
+	{ KEY_PLAY,             "KEY_PLAY"             },
+	{ KEY_FASTFORWARD,      "KEY_FASTFORWARD"      },
+	{ KEY_BASSBOOST,        "KEY_BASSBOOST"        },
+	{ KEY_PRINT,            "KEY_PRINT"            },
+	{ KEY_HP,               "KEY_HP"               },
+	{ KEY_CAMERA,           "KEY_CAMERA"           },
+	{ KEY_SOUND,            "KEY_SOUND"            },
+	{ KEY_QUESTION,         "KEY_QUESTION"         },
+	{ KEY_EMAIL,            "KEY_EMAIL"            },
+	{ KEY_CHAT,             "KEY_CHAT"             },
+	{ KEY_SEARCH,           "KEY_SEARCH"           },
+	{ KEY_CONNECT,          "KEY_CONNECT"          },
+	{ KEY_FINANCE,          "KEY_FINANCE"          },
+	{ KEY_SPORT,            "KEY_SPORT"            },
+	{ KEY_SHOP,             "KEY_SHOP"             },
+	{ KEY_ALTERASE,         "KEY_ALTERASE"         },
+	{ KEY_CANCEL,           "KEY_CANCEL"           },
+	{ KEY_BRIGHTNESSDOWN,   "KEY_BRIGHTNESSDOWN"   },
+	{ KEY_BRIGHTNESSUP,     "KEY_BRIGHTNESSUP"     },
+	{ KEY_MEDIA,            "KEY_MEDIA"            },
+	{ KEY_SWITCHVIDEOMODE,  "KEY_SWITCHVIDEOMODE"  },
+	{ KEY_KBDILLUMTOGGLE,   "KEY_KBDILLUMTOGGLE"   },
+	{ KEY_KBDILLUMDOWN,     "KEY_KBDILLUMDOWN"     },
+	{ KEY_KBDILLUMUP,       "KEY_KBDILLUMUP"       },
+	{ KEY_SEND,             "KEY_SEND"             },
+	{ KEY_REPLY,            "KEY_REPLY"            },
+	{ KEY_FORWARDMAIL,      "KEY_FORWARDMAIL"      },
+	{ KEY_SAVE,             "KEY_SAVE"             },
+	{ KEY_DOCUMENTS,        "KEY_DOCUMENTS"        },
+	{ KEY_BATTERY,          "KEY_BATTERY"          },
+	{ KEY_BLUETOOTH,        "KEY_BLUETOOTH"        },
+	{ KEY_WLAN,             "KEY_WLAN"             },
+	{ KEY_UWB,              "KEY_UWB"              },
+	{ KEY_UNKNOWN,          "KEY_UNKNOWN"          },
+	{ KEY_VIDEO_NEXT,       "KEY_VIDEO_NEXT"       },
+	{ KEY_VIDEO_PREV,       "KEY_VIDEO_PREV"       },
+	{ KEY_BRIGHTNESS_CYCLE, "KEY_BRIGHTNESS_CYCLE" },
+	{ KEY_BRIGHTNESS_ZERO,  "KEY_BRIGHTNESS_ZERO"  },
+	{ KEY_DISPLAY_OFF,      "KEY_DISPLAY_OFF"      },
+	{ KEY_WIMAX,            "KEY_WIMAX"            },
+//	{ KEY_RFKILL,           "KEY_RFKILL"           },
+
+	{ KEY_OK,               "KEY_OK"               },
+	{ KEY_SELECT,           "KEY_SELECT"           },
+	{ KEY_GOTO,             "KEY_GOTO"             },
+	{ KEY_CLEAR,            "KEY_CLEAR"            },
+	{ KEY_POWER2,           "KEY_POWER2"           },
+	{ KEY_OPTION,           "KEY_OPTION"           },
+	{ KEY_INFO,             "KEY_INFO"             },
+	{ KEY_TIME,             "KEY_TIME"             },
+	{ KEY_VENDOR,           "KEY_VENDOR"           },
+	{ KEY_ARCHIVE,          "KEY_ARCHIVE"          },
+	{ KEY_PROGRAM,          "KEY_PROGRAM"          },
+	{ KEY_CHANNEL,          "KEY_CHANNEL"          },
+	{ KEY_FAVORITES,        "KEY_FAVORITES"        },
+	{ KEY_EPG,              "KEY_EPG"              },
+	{ KEY_PVR,              "KEY_PVR"              },
+	{ KEY_MHP,              "KEY_MHP"              },
+	{ KEY_LANGUAGE,         "KEY_LANGUAGE"         },
+	{ KEY_TITLE,            "KEY_TITLE"            },
+	{ KEY_SUBTITLE,         "KEY_SUBTITLE"         },
+	{ KEY_ANGLE,            "KEY_ANGLE"            },
+	{ KEY_ZOOM,             "KEY_ZOOM"             },
+	{ KEY_MODE,             "KEY_MODE"             },
+	{ KEY_KEYBOARD,         "KEY_KEYBOARD"         },
+	{ KEY_SCREEN,           "KEY_SCREEN"           },
+	{ KEY_PC,               "KEY_PC"               },
+	{ KEY_TV,               "KEY_TV"               },
+	{ KEY_TV2,              "KEY_TV2"              },
+	{ KEY_VCR,              "KEY_VCR"              },
+	{ KEY_VCR2,             "KEY_VCR2"             },
+	{ KEY_SAT,              "KEY_SAT"              },
+	{ KEY_SAT2,             "KEY_SAT2"             },
+	{ KEY_CD,               "KEY_CD"               },
+	{ KEY_TAPE,             "KEY_TAPE"             },
+	{ KEY_RADIO,            "KEY_RADIO"            },
+	{ KEY_TUNER,            "KEY_TUNER"            },
+	{ KEY_PLAYER,           "KEY_PLAYER"           },
+	{ KEY_TEXT,             "KEY_TEXT"             },
+	{ KEY_DVD,              "KEY_DVD"              },
+	{ KEY_AUX,              "KEY_AUX"              },
+	{ KEY_MP3,              "KEY_MP3"              },
+	{ KEY_AUDIO,            "KEY_AUDIO"            },
+	{ KEY_VIDEO,            "KEY_VIDEO"            },
+	{ KEY_DIRECTORY,        "KEY_DIRECTORY"        },
+	{ KEY_LIST,             "KEY_LIST"             },
+	{ KEY_MEMO,             "KEY_MEMO"             },
+	{ KEY_CALENDAR,         "KEY_CALENDAR"         },
+	{ KEY_RED,              "KEY_RED"              },
+	{ KEY_GREEN,            "KEY_GREEN"            },
+	{ KEY_YELLOW,           "KEY_YELLOW"           },
+	{ KEY_BLUE,             "KEY_BLUE"             },
+	{ KEY_CHANNELUP,        "KEY_CHANNELUP"        },
+	{ KEY_CHANNELDOWN,      "KEY_CHANNELDOWN"      },
+	{ KEY_FIRST,            "KEY_FIRST"            },
+	{ KEY_LAST,             "KEY_LAST"             },
+	{ KEY_AB,               "KEY_AB"               },
+	{ KEY_PLAY,             "KEY_PLAY"             },
+	{ KEY_RESTART,          "KEY_RESTART"          },
+	{ KEY_SLOW,             "KEY_SLOW"             },
+	{ KEY_SHUFFLE,          "KEY_SHUFFLE"          },
+	{ KEY_FASTFORWARD,      "KEY_FASTFORWARD"      },
+	{ KEY_PREVIOUS,         "KEY_PREVIOUS"         },
+	{ KEY_NEXT,             "KEY_NEXT"             },
+	{ KEY_DIGITS,           "KEY_DIGITS"           },
+	{ KEY_TEEN,             "KEY_TEEN"             },
+	{ KEY_TWEN,             "KEY_TWEN"             },
+	{ KEY_BREAK,            "KEY_BREAK"            },
+
+	{ 0,                    NULL                   },
+};
+
+/*
+ * eLircInputDevice
+ */
+
+eLircInputDevice::eLircInputDevice(eRCDriver *driver) : eRCDevice("Lirc", driver), m_escape(false), m_unicode(0)
+{}
+
+eLircInputDevice::~eLircInputDevice()
+{}
+
+void eLircInputDevice::handleCode(long arg)
+{
+	const lircEvent* event = (const lircEvent*)arg;
+	int code, flags;
+
+	if (event->repeat == true) {
+		flags = eRCKey::flagRepeat;
+	} else if (event->release == true) {
+		flags = eRCKey::flagBreak;
+	} else {
+		flags = eRCKey::flagMake;
+	}
+
+	code = translateKey(event->name);
+
+	//eDebug("LIRC name=%s code=%d flags=%d", event->name, code, flags);
+	input->keyPressed(eRCKey(this, code, flags));
+	if (flags == eRCKey::flagMake) {
+		flags = eRCKey::flagBreak;
+		eDebug("LIRC name=%s code=%d flags=%d", event->name, code, flags);
+		input->keyPressed(eRCKey(this, code, flags));
+		flags = eRCKey::flagMake;
+	}
+
+}
+
+const char *eLircInputDevice::getDescription() const
+{
+	return "Lirc";
+}
+
+int eLircInputDevice::translateKey(const char* name)
+{
+	if (name==NULL)
+	{
+		eDebug("LIRC: translateKey ERROR");
+		return KEY_RESERVED;
+	}
+
+	for (int i=0;keyTable[i].name!=NULL;i++)
+	{
+		if (!strcmp(name, keyTable[i].name))
+		{
+			//printf("FOUND KEY CODE FOR %s: %04X\n", name, keyTable[i].code);
+			return keyTable[i].code;
+		}
+	}
+
+	eDebug("LIRC: unhandled key name: %s", name);
+	return KEY_RESERVED;
+}
+
+/*
+ * eLircInputDriver
+ */
+
+#define REPEATDELAY 350 // ms
+#define REPEATFREQ 100 // ms
+#define REPEATTIMEOUT 500 // ms
+#define RECONNECTDELAY 3000 // ms
+
+static bool fileReady(int FileDes, int TimeoutMs)
+{
+	fd_set set;
+	struct timeval timeout;
+	FD_ZERO(&set);
+	FD_SET(FileDes, &set);
+	if (TimeoutMs >= 0) {
+		if (TimeoutMs < 100)
+			TimeoutMs = 100;
+		timeout.tv_sec  = TimeoutMs / 1000;
+		timeout.tv_usec = (TimeoutMs % 1000) * 1000;
+	}
+	return select(FD_SETSIZE, &set, NULL, NULL, (TimeoutMs >= 0) ? &timeout : NULL) > 0 && FD_ISSET(FileDes, &set);
+}
+
+static ssize_t safe_read(int filedes, void *buffer, size_t size)
+{
+	for (;;) {
+//printf("AAread1\n");
+		ssize_t p = read(filedes, buffer, size);
+//printf("AAread2\n");
+		if (p < 0 && errno == EINTR) {
+			continue;
+		}
+		return p;
+	}
+}
+
+void eLircInputDriver::pumpEvent(const lircEvent &event)
+{
+	keyPressed(event);
+}
+
+eLircInputDriver *eLircInputDriver::instance;
+
+bool eLircInputDriver::Connect(void)
+{
+	if ((f = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0) {
+		if (connect(f, (struct sockaddr *)&addr, sizeof(addr)) >= 0)
+ 			return true;
+		eDebug("Lirc: Connect to %s error !!!", addr.sun_path);
+		close(f);
+		f = -1;
+	}
+	else
+		eDebug("Lirc: Connect to %s error !!!", addr.sun_path);
+
+	return false;
+}
+
+eLircInputDriver::eLircInputDriver() : eRCDriver(eRCInput::getInstance()), m_pump(eApp, 1)
+{
+	ASSERT(instance == 0);
+	instance = this;
+
+	CONNECT(m_pump.recv_msg, eLircInputDriver::pumpEvent);
+
+	addr.sun_family = AF_UNIX;
+	strcpy(addr.sun_path, "/var/run/lirc/lircd");
+	if (Connect()) {
+		run();
+		return;
+	}
+	f = -1;
+}
+
+eLircInputDriver::~eLircInputDriver()
+{
+	instance = 0;
+
+	int fh = f;
+	f = -1;
+
+	thread_stop = true;
+	sendSignal(SIGINT);
+	kill();
+
+	if (fh >= 0)
+		close(fh);
+}
+
+void eLircInputDriver::thread()
+{
+	cTimeMs FirstTime;
+	cTimeMs LastTime;
+	char buf[LIRC_BUFFER_SIZE];
+	char LastKeyName[LIRC_KEY_BUF] = "";
+	bool repeat = false;
+	int timeout = -1;
+	lircEvent event;
+
+	hasStarted();
+	thread_stop = false;
+
+	while (!thread_stop && f>=0) {
+		bool ready = fileReady(f, timeout);
+		int ret = ready ? safe_read(f, buf, sizeof(buf)) : -1;
+
+		if (ready && ret <= 0 ) {
+			eDebug("ERROR: lircd connection broken, trying to reconnect every %.1f seconds", float(RECONNECTDELAY) / 1000);
+			close(f);
+			f = -1;
+			while (!thread_stop && f < 0) {
+				cCondWait::SleepMs(RECONNECTDELAY);
+				if (Connect()) {
+					eDebug("reconnected to lircd");
+					break;
+				}
+			}
+		}
+
+		if (ready && ret > 21) {
+			int count;
+			char KeyName[LIRC_KEY_BUF];
+			if (sscanf(buf, "%*x %x %29s", &count, KeyName) != 2) { // '29' in '%29s' is LIRC_KEY_BUF-1!
+				eDebug("ERROR: unparseable lirc command: %s", buf);
+				continue;
+			}
+			if (count == 0) {
+				if (strcmp(KeyName, LastKeyName) == 0 && FirstTime.Elapsed() < REPEATDELAY)
+					continue; // skip keys coming in too fast
+				if (repeat) {
+					event.name = LastKeyName;
+					event.repeat = false;
+					event.release = true;
+					m_pump.send(event);
+				}
+				strcpy(LastKeyName, KeyName);
+				repeat = false;
+				FirstTime.Set();
+				timeout = -1;
+			}
+			else {
+				if (LastTime.Elapsed() < REPEATFREQ)
+					continue; // repeat function kicks in after a short delay (after last key instead of first key)
+				if (FirstTime.Elapsed() < REPEATDELAY)
+					continue; // skip keys coming in too fast (for count != 0 as well)
+				repeat = true;
+				timeout = REPEATDELAY;
+			}
+			LastTime.Set();
+			event.name = KeyName;
+			event.repeat = repeat;
+			event.release = false;
+			m_pump.send(event);
+		}
+		else if (repeat) { // the last one was a repeat, so let's generate a release
+			if (LastTime.Elapsed() >= REPEATTIMEOUT) {
+				event.name = LastKeyName;
+				event.repeat = false;
+				event.release = true;
+				m_pump.send(event);
+				repeat = false;
+				*LastKeyName = 0;
+				timeout = -1;
+			}
+		}
+	}
+}
+
+void eLircInputDriver::keyPressed(const lircEvent &event)
+{
+	if (!enabled || input->islocked())
+		return;
+
+	std::list<eRCDevice*>::iterator i(listeners.begin());
+	while (i != listeners.end()) {
+		(*i)->handleCode((long)&event);
+		++i;
+	}
+}
+
+class eRCLircInit
+{
+private:
+	eLircInputDriver driver;
+	eLircInputDevice device;
+
+public:
+	eRCLircInit(): driver(), device(&driver)
+	{
+	}
+};
+
+eAutoInitP0<eRCLircInit> init_rcLirc(eAutoInitNumbers::rc+1, "Lirc RC Driver");
diff -ruN o/lib/driver/rclirc.h pc/lib/driver/rclirc.h
--- o/lib/driver/rclirc.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/driver/rclirc.h	2025-07-11 16:39:46.947637384 +0300
@@ -0,0 +1,56 @@
+#ifndef __lib_driver_rclirc_h
+#define __lib_driver_rclirc_h
+
+#include <sys/un.h>
+#include <lib/driver/rc.h>
+#include <lib/base/thread.h>
+#include <lib/base/message.h>
+
+struct tKey {
+	uint16_t    code;
+	const char  *name;
+};
+
+struct lircEvent {
+	const char  *name;
+	bool        repeat;
+	bool        release;
+};
+
+class eLircInputDevice : public eRCDevice
+{
+private:
+	bool m_escape;
+	unsigned int m_unicode;
+	int translateKey(const char* name);
+
+public:
+	eLircInputDevice(eRCDriver *driver);
+	~eLircInputDevice();
+
+	virtual void handleCode(long arg);
+	virtual const char *getDescription() const;
+};
+
+class eLircInputDriver : public eRCDriver, public eThread
+{
+private:
+	enum { LIRC_KEY_BUF = 108, LIRC_BUFFER_SIZE = 128 };
+	static eLircInputDriver *instance;
+	eFixedMessagePump<lircEvent> m_pump;
+	void pumpEvent(const lircEvent &keyEvent);
+	int f;
+	struct sockaddr_un addr;
+	virtual void thread();
+	bool thread_stop;
+	bool Connect(void);
+
+public:
+	eLircInputDriver();
+	~eLircInputDriver();
+
+	static eLircInputDriver *getInstance() { return instance; }
+	void keyPressed(const lircEvent &keyEvent);
+};
+
+#endif
diff -ruN o/lib/driver/rcxlib.cpp pc/lib/driver/rcxlib.cpp
--- o/lib/driver/rcxlib.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/driver/rcxlib.cpp	2025-07-11 16:39:46.948637329 +0300
@@ -0,0 +1,215 @@
+#include <lib/driver/rcxlib.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/driver/input_fake.h>
+
+/*
+ * eXlibInputDevice
+ */
+
+eXlibInputDevice::eXlibInputDevice(eRCDriver *driver) : eRCDevice("Xlib", driver), m_escape(false), m_unicode(0)
+{
+}
+
+eXlibInputDevice::~eXlibInputDevice()
+{
+}
+
+void eXlibInputDevice::handleCode(long arg)
+{
+	const XKeyEvent* event = (const XKeyEvent*)arg;
+//	int km = input->getKeyboardMode();
+	int code, flags;
+
+	if (event->type == KeyPress) {
+		//m_unicode = key->unicode;
+		flags = eRCKey::flagMake;
+	} else {
+		flags = eRCKey::flagBreak;
+	}
+
+	if (1/*km == eRCInput::kmNone*/) {
+		//eDebug("eRCInput::kmNone\n");
+		code = translateKey(event->keycode);
+	} else {
+		eDebug("eRCInput::kmNone NO\n");
+		// ASCII keys should only generate key press events
+		if (flags == eRCKey::flagBreak)
+			return;
+
+		/*eDebug("unicode=%04x scancode=%02x", m_unicode, key->scancode);
+		if (m_unicode & 0xff80) {
+			eDebug("SDL: skipping unicode character");
+			return;
+		}
+		code = m_unicode & ~0xff80;
+		// unicode not set...!? use key symbol
+		if (code == 0) {
+			// keysym is ascii
+			if (key >= 128) {
+				eDebug("SDL: cannot emulate ASCII");
+				return;
+			}
+			eDebug("SDL: emulate ASCII");
+			code = key;
+		}
+		if (km == eRCInput::kmAscii) {
+			// skip ESC c or ESC '[' c
+			if (m_escape) {
+				if (code != '[')
+					m_escape = false;
+				return;
+			}
+
+			if (code == SDLK_ESCAPE)
+				m_escape = true;
+
+			if ((code < SDLK_SPACE) ||
+			    (code == 0x7e) ||	// really?
+			    (code == SDLK_DELETE))
+				return;
+		}*/
+		flags |= eRCKey::flagAscii;
+	}
+
+	//eDebug("SDL code=%d flags=%d", code, flags);
+	input->keyPressed(eRCKey(this, code, flags));
+}
+
+const char *eXlibInputDevice::getDescription() const
+{
+	return "Xlib";
+}
+
+int eXlibInputDevice::translateKey(int key)
+{
+
+	switch (key) {
+	case 9:
+		return KEY_ESC;
+	case 10:
+		return KEY_1;
+	case 11:
+		return KEY_2;
+	case 12:
+		return KEY_3;
+	case 13:
+		return KEY_4;
+	case 14:
+		return KEY_5;
+	case 15:
+		return KEY_6;
+	case 16:
+		return KEY_7;
+	case 17:
+		return KEY_8;
+	case 18:
+		return KEY_9;
+	case 19:
+		return KEY_0;
+	case 26: // E
+		return KEY_EPG;
+	case 27: // R
+		return KEY_RECORD;
+	case 28: // T
+		return KEY_TV;
+	case 31: // I
+		return KEY_INFO;
+	case 33: // P
+		return KEY_PLAYPAUSE;
+	case 36:
+		return KEY_OK;
+	case 38: // A
+		return KEY_AUDIO;
+	case 40: // D
+		return KEY_RADIO;
+	case 55: // V
+		return KEY_VIDEO;
+	case 111:
+		return KEY_UP;
+	case 113:
+		return KEY_LEFT;
+	case 114:
+		return KEY_RIGHT;
+	case 116:
+		return KEY_DOWN;
+	case 58: // M
+		return KEY_MUTE;
+	case 65: // SPACE
+		return KEY_MENU;
+	case 67:
+		return KEY_RED;
+	case 68:
+		return KEY_GREEN;
+	case 69:
+		return KEY_YELLOW;
+	case 70:
+		return KEY_BLUE;
+	case 71: //F5
+		return KEY_INFO;
+	case 72: //F6
+		return KEY_EPG;
+	case 82:
+	case 61: // -
+		return KEY_VOLUMEDOWN;
+	case 86:
+	case 35: // +
+		return KEY_VOLUMEUP;
+	case 112: // Page Up
+		return KEY_CHANNELUP;
+	case 117: // Page Down
+		return KEY_CHANNELDOWN;
+	case	76: //F10
+		return KEY_POWER;
+	default:
+		eDebug("unhandled KEYBOARD keycode: %d", key);
+		return KEY_RESERVED;
+	}
+
+}
+
+/*
+ * eXlibInputDriver
+ */
+
+eXlibInputDriver *eXlibInputDriver::instance;
+
+eXlibInputDriver::eXlibInputDriver() : eRCDriver(eRCInput::getInstance())
+{
+	ASSERT(instance == 0);
+	instance = this;
+}
+
+eXlibInputDriver::~eXlibInputDriver()
+{
+	instance = 0;
+}
+
+void eXlibInputDriver::keyPressed(const XKeyEvent &keyEvent)
+{
+	/*eDebug("km=%d enabled=%d locked=%d",
+		input->getKeyboardMode(), enabled, input->islocked());*/
+
+	if (!enabled || input->islocked())
+		return;
+
+	std::list<eRCDevice*>::iterator i(listeners.begin());
+	while (i != listeners.end()) {
+		(*i)->handleCode((long)&keyEvent);
+		++i;
+	}
+}
+
+class eRCXlibInit
+{
+private:
+	eXlibInputDriver driver;
+	eXlibInputDevice device;
+
+public:
+	eRCXlibInit(): driver(), device(&driver)
+	{
+	}
+};
+
+eAutoInitP0<eRCXlibInit> init_rcXlib(eAutoInitNumbers::rc+1, "Xlib RC Driver");
diff -ruN o/lib/driver/rcxlib.h pc/lib/driver/rcxlib.h
--- o/lib/driver/rcxlib.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/driver/rcxlib.h	2025-07-11 16:39:46.948637329 +0300
@@ -0,0 +1,35 @@
+#ifndef __lib_driver_rcxlib_h
+#define __lib_driver_rcxlib_h
+
+#include <lib/driver/rc.h>
+#include <X11/Xlib.h>
+
+class eXlibInputDevice : public eRCDevice
+{
+private:
+	bool m_escape;
+	unsigned int m_unicode;
+	int translateKey(int key);
+
+public:
+	eXlibInputDevice(eRCDriver *driver);
+	~eXlibInputDevice();
+
+	virtual void handleCode(long arg);
+	virtual const char *getDescription() const;
+};
+
+class eXlibInputDriver : public eRCDriver
+{
+private:
+	static eXlibInputDriver *instance;
+
+public:
+	eXlibInputDriver();
+	~eXlibInputDriver();
+
+	static eXlibInputDriver *getInstance() { return instance; }
+	void keyPressed(const XKeyEvent &keyEvent);
+};
+
+#endif
diff -ruN o/lib/driver/rfmod.cpp pc/lib/driver/rfmod.cpp
--- o/lib/driver/rfmod.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/driver/rfmod.cpp	2025-07-11 16:39:46.948637329 +0300
@@ -23,8 +23,6 @@
 	instance = this;
 
 	fd = open("/dev/rfmod0", O_RDWR);
-	if (fd < 0)
-		eDebug("[eRFmod] couldnt open /dev/rfmod0: %m");
 }
 
 eRFmod::~eRFmod()
diff -ruN o/lib/dvb/ca_connector.cpp pc/lib/dvb/ca_connector.cpp
--- o/lib/dvb/ca_connector.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/dvb/ca_connector.cpp	2025-07-11 16:39:46.948637329 +0300
@@ -0,0 +1,123 @@
+#include <lib/dvb/ca_connector.h>
+#include <lib/dvb/dvb.h>
+#include <lib/actions/action.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+
+caConnector *caConnector::instance;
+
+DEFINE_REF(caConnector)
+
+caConnector::caConnector()
+{
+	int family;
+	struct nl_msg *msg;
+	
+	sock = nl_socket_alloc();
+	genl_connect(sock);
+
+	family = genl_ctrl_resolve(sock, "CA_SEND");
+	if (family<0) {
+		eDebug("Cannot resolve family name of generic netlink socket");
+		return;
+	}
+
+	ca_policy[ATTR_CA_SIZE].type = NLA_U32;
+	ca_policy[ATTR_CA_NUM].type = NLA_U16;
+	ca_policy[ATTR_CA_DESCR].type = NLA_UNSPEC;
+	ca_policy[ATTR_CA_PID].type = NLA_UNSPEC;
+
+	ASSERT(instance == 0);
+	instance = this;
+
+	msg = nlmsg_alloc();
+	genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family, 0, NLM_F_ECHO,
+			CMD_ASK_CA_SIZE, 1);
+	nl_send_auto_complete(sock, msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_recvmsgs_default(sock);
+	nlmsg_free(msg);
+	nl_socket_modify_cb(sock, NL_CB_VALID, NL_CB_CUSTOM, parse_cb, NULL);
+	nl_socket_disable_seq_check(sock);
+
+	run();
+}
+
+caConnector::~caConnector()
+{
+	instance = 0;
+	abort_badly();
+	kill();
+
+	nl_close(sock);
+	nl_socket_free(sock);
+}
+
+void caConnector::thread()
+{
+	hasStarted();
+
+	while (1) {
+		nl_recvmsgs_default(sock);
+	}
+}
+
+int caConnector::parse_cb(struct nl_msg *msg, void *arg) {
+	caConnector *connector = caConnector::getInstance();
+	ePtr<eDVBResourceManager> res_mgr;
+	int ret;
+
+	eDVBResourceManager::getInstance(res_mgr);
+	if (!res_mgr) {
+		eDebug("no resource manager !!!!!!!");
+		return -1;
+	}
+
+	struct nlmsghdr *nlh = nlmsg_hdr(msg);
+	struct nlattr *attrs[ATTR_MAX+1];
+
+	genlmsg_parse(nlh, 0, attrs, ATTR_MAX, connector->ca_policy);
+
+	if (attrs[ATTR_CA_SIZE]) {
+		uint32_t value = nla_get_u32(attrs[ATTR_CA_SIZE]);
+		connector->ca_size = value;
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_DESCR]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_descr_t *ca = (ca_descr_t*)nla_data(attrs[ATTR_CA_DESCR]);
+		eDebug("CA_SET_DESCR ca_num %04X, idx %d, parity %d, cw %02X...%02X", ca_num, ca->index,
+				ca->parity, ca->cw[0], ca->cw[7]);
+
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaDescr(ca,0)) {
+			eDebug("CA_SET_DESCR failed (%s). Expect a black screen.",strerror(errno));
+		}
+	}
+	if (attrs[ATTR_CA_NUM] && attrs[ATTR_CA_PID]) {
+		unsigned short ca_num = nla_get_u16(attrs[ATTR_CA_NUM]);
+		ca_pid_t *ca_pid = (ca_pid_t*)nla_data(attrs[ATTR_CA_PID]);
+
+		eDebug("CA_PID ca_num %04X, pid %04X, index %d", ca_num, ca_pid->pid, ca_pid->index);
+		
+		ePtr<eDVBDemux> demux;
+		ret = res_mgr->getAdapterDemux(demux, (ca_num>>8)&0xFF, ca_num&0xFF);
+		if (ret) {
+			eDebug("caConnector: DEMUX NOT FOUND !!");
+			return -1;
+		}
+
+		if(!demux->setCaPid(ca_pid)) {
+			eDebug("CA_SET_PID failed");
+		}
+	}
+
+	return 0;
+}
+
+eAutoInitPtr<caConnector> init_caConnector(eAutoInitNumbers::dvb-1, "caConnector");
diff -ruN o/lib/dvb/ca_connector.h pc/lib/dvb/ca_connector.h
--- o/lib/dvb/ca_connector.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/dvb/ca_connector.h	2025-07-11 16:39:46.949637275 +0300
@@ -0,0 +1,50 @@
+#ifndef __lib_dvb_ca_connector_h
+#define __lib_dvb_ca_connector_h
+
+#include "../dvbsoftwareca/ca.h"
+#include <lib/base/thread.h>
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+
+#include <lib/gdi/gmaindc.h>
+#include <lib/dvb/idvb.h>
+
+// attributes
+enum {
+	ATTR_UNSPEC,
+	ATTR_CA_SIZE,
+	ATTR_CA_NUM,
+	ATTR_CA_DESCR,
+	ATTR_CA_PID,
+        __ATTR_MAX
+};
+#define ATTR_MAX (__ATTR_MAX - 1)
+
+// commands
+enum {
+	CMD_UNSPEC,
+	CMD_ASK_CA_SIZE,
+	CMD_SET_CW,
+	CMD_SET_PID,
+	CMD_MAX
+};
+
+class caConnector: public eThread, sigc::trackable
+{
+	DECLARE_REF(caConnector);
+private:
+	int ca_size;
+	struct nla_policy ca_policy[ATTR_MAX + 1];
+	struct nl_sock *sock;
+	static caConnector *instance;
+
+	virtual void thread();
+	static int parse_cb(struct nl_msg *msg, void *arg);
+	static caConnector *getInstance() { return instance; }
+public:
+	caConnector();
+	~caConnector();
+};
+
+#endif
diff -ruN o/lib/dvb/decoder.cpp pc/lib/dvb/decoder.cpp
--- o/lib/dvb/decoder.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/decoder.cpp	2025-07-11 16:39:46.949637275 +0300
@@ -7,6 +7,7 @@
 #include <linux/dvb/audio.h>
 #include <linux/dvb/video.h>
 #include <linux/dvb/dmx.h>
+#include <lib/gdi/xineLib.h>
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -36,16 +37,11 @@
 	:m_demux(demux), m_dev(dev)
 {
 	char filename[128] = {};
-	sprintf(filename, "/dev/dvb/adapter%d/audio%d", demux ? demux->adapter : 0, dev);
 	m_fd = ::open(filename, O_RDWR | O_CLOEXEC);
-	if (m_fd < 0)
-		eWarning("[eDVBAudio] %s: %m", filename);
 	if (demux)
 	{
 		sprintf(filename, "/dev/dvb/adapter%d/demux%d", demux->adapter, demux->demux);
 		m_fd_demux = ::open(filename, O_RDWR | O_CLOEXEC);
-		if (m_fd_demux < 0)
-			eWarning("[eDVBAudio] %s: %m", filename);
 	}
 	else
 	{
@@ -60,8 +56,27 @@
 #endif
 }
 
-int eDVBAudio::startPid(int pid, int type)
+#define STREAM_SPU_BITMAP_HDMV                    0x90 /* Presentation Graphics */
+#define ISO_13818_AUDIO                           0x04 /* ISO/IEC 13818-3 Audi */
+#define STREAM_VIDEO_VC1                          0xEA /* VC-1 Video */
+#define HDMV_AUDIO_80_PCM                         0x80 /* BluRay PCM */
+#define STREAM_AUDIO_AC3                          0x81 /* ?????????? */
+#define HDMV_AUDIO_82_DTS                         0x82 /* DTS */
+#define HDMV_AUDIO_83_TRUEHD                      0x83 /* Dolby TrueHD, primary audio */
+#define HDMV_AUDIO_84_EAC3                        0x84 /* Dolby Digital plus, primary audio */
+#define HDMV_AUDIO_85_DTS_HRA                     0x85 /* DTS-HRA */
+#define HDMV_AUDIO_86_DTS_HD_MA                   0x86 /* DTS-HD Master audio */
+#define ISO_IEC_13818_7_ADTS_AAC_MPEG2_LOWER      0x0F /* AAC 'Xtra TV'. ISO/IEC 13818-7 Audio with ADTS transport sytax */
+#define ISO_14496_PART3_AUDIO                     0x11 /* ISO/IEC 14496-3 Audio with LATM transport syntax */
+//#define   ISO_11172_AUDIO                         0x03 /* ISO/IEC 11172 Audio */
+//#define ISO_IEC_13818_7_ADTS_AAC                  0x2B /* ?????????? */
+//#define ISO_IEC_13818_7_ADTS_AAC_AES_128_CBC      0xCF /* ?????????? */
+//#define AAC_LATM                                  0x11 /* ?????????? */
+
+int eDVBAudio::startPid(int pid, int type, bool mode)
 {
+	cXineLib *xineLib = cXineLib::getInstance();
+
 	if (m_fd_demux >= 0)
 	{
 		dmx_pes_filter_params pes = {};
@@ -89,70 +104,55 @@
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 		eDebugNoNewLineStart("[eDVBAudio%d] DEMUX_START ", m_dev);
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 	}
 
-	if (m_fd >= 0)
-	{
-		int bypass = 0;
+		int xine_type = 0;
 
 		switch (type)
 		{
 		case aMPEG:
-			bypass = 1;
+			xine_type = ISO_13818_AUDIO;
 			break;
 		case aAC3:
 		case aAC4: /* FIXME: AC4 most probably will use other bypass value */
-			bypass = 0;
+			xine_type = STREAM_AUDIO_AC3;
 			break;
 		case aDTS:
-			bypass = 2;
+			xine_type = HDMV_AUDIO_82_DTS;
 			break;
 		case aAAC:
-			bypass = 8;
+			xine_type = ISO_IEC_13818_7_ADTS_AAC_MPEG2_LOWER;
 			break;
 		case aAACHE:
-			bypass = 9;
+			xine_type = ISO_14496_PART3_AUDIO;
 			break;
 		case aLPCM:
-			bypass = 6;
+			xine_type = HDMV_AUDIO_80_PCM;
 			break;
 		case aDTSHD:
-			bypass = 0x10;
+			xine_type = HDMV_AUDIO_86_DTS_HD_MA;
 			break;
 		case aDRA:
-			bypass = 0x40;
+			/* xine_type = ? */
 			break;
 		case aDDP:
-#ifdef DREAMBOX
-		bypass = 7;
-#else
-		bypass = 0x22;
-#endif
-		break;
+			xine_type = HDMV_AUDIO_84_EAC3;
+			break;
 		}
 
-		eDebugNoNewLineStart("[eDVBAudio%d] AUDIO_SET_BYPASS bypass=%d ", m_dev, bypass);
-		if (::ioctl(m_fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
-			eDebugNoNewLine("failed: %m\n");
-		else
-			eDebugNoNewLine("ok\n");
 		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
-		eDebugNoNewLineStart("[eDVBAudio%d] AUDIO_PLAY ", m_dev);
-		if (::ioctl(m_fd, AUDIO_PLAY) < 0)
-			eDebugNoNewLine("failed: %m\n");
-		else
-			eDebugNoNewLine("ok\n");
-	}
+		xineLib->setAudioType(pid, xine_type);
+		/* Radio mode */
+		if (mode)
+			xineLib->playVideo();
 	return 0;
 }
 
@@ -260,24 +260,13 @@
 	m_width(-1), m_height(-1), m_framerate(-1), m_aspect(-1), m_progressive(-1), m_gamma(-1)
 {
 	char filename[128] = {};
-	sprintf(filename, "/dev/dvb/adapter%d/video%d", demux ? demux->adapter : 0, dev);
 	m_fd = ::open(filename, O_RDWR | O_CLOEXEC);
-	if (m_fd < 0)
-		eWarning("[eDVBVideo] %s: %m", filename);
-	else
-	{
-		eDebug("[eDVBVideo] Video Device: %s", filename);
-		m_sn = eSocketNotifier::create(eApp, m_fd, eSocketNotifier::Priority);
-		CONNECT(m_sn->activated, eDVBVideo::video_event);
-	}
+	m_sn = eSocketNotifier::create(eApp, m_fd, eSocketNotifier::Priority);
+	CONNECT(m_sn->activated, eDVBVideo::video_event);
 	if (demux)
 	{
 		sprintf(filename, "/dev/dvb/adapter%d/demux%d", demux->adapter, demux->demux);
 		m_fd_demux = ::open(filename, O_RDWR | O_CLOEXEC);
-		if (m_fd_demux < 0)
-			eWarning("[eDVBVideo] %s: %m", filename);
-		else
-			eDebug("[eDVBVideo] demux device: %s", filename);
 	}
 	else
 	{
@@ -322,12 +311,22 @@
 #define VIDEO_STREAMTYPE_AVS 16
 #define VIDEO_STREAMTYPE_AVS2 40
 
-int eDVBVideo::startPid(int pid, int type)
+/*#define VIDEO_STREAMTYPE_MPEG2       0x02
+#define VIDEO_STREAMTYPE_MPEG4_H264  0x1B
+#define VIDEO_STREAMTYPE_VC1         0xEA
+#define VIDEO_STREAMTYPE_MPEG4_Part2 0x10
+#define VIDEO_STREAMTYPE_VC1_SM      0xEA
+#define VIDEO_STREAMTYPE_MPEG1       0x01
+#define VIDEO_STREAMTYPE_H265_HEVC   0x24
+#define VIDEO_STREAMTYPE_AVS         0x42
+#define VIDEO_STREAMTYPE_AVS2        0xD2*/
+
+int eDVBVideo::startPid(int pid, int type, bool is_pvr)
 {
 	if (m_fcc_enable)
 		return 0;
 
-	if (m_fd >= 0)
+	if (is_pvr)
 	{
 		int streamtype = VIDEO_STREAMTYPE_MPEG2;
 		switch (type)
@@ -361,11 +360,7 @@
 			break;
 		}
 
-		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_SET_STREAMTYPE %d - ", m_dev, streamtype);
-		if (::ioctl(m_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
-			eDebugNoNewLine("failed: %m\n");
-		else
-			eDebugNoNewLine("ok\n");
+		type = streamtype;
 	}
 
 	if (m_fd_demux >= 0)
@@ -394,41 +389,38 @@
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_START ", m_dev);
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
 			eDebugNoNewLine("failed: %m\n");
-			return -errno;
 		}
 		eDebugNoNewLine("ok\n");
 	}
 
-	if (m_fd >= 0)
-	{
-		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
-		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_PLAY ", m_dev);
-		if (::ioctl(m_fd, VIDEO_PLAY) < 0)
-			eDebugNoNewLine("failed: %m\n");
-		else
-			eDebugNoNewLine("ok\n");
-	}
+	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+	cXineLib *xineLib = cXineLib::getInstance();
+	eDebug("**************** VIDEO SET STREAMTYPE: (%x)", type);
+	xineLib->setVideoType(pid, type);
+
+	eDebug("**************** VIDEO PLAY");
+	xineLib->playVideo();
+
 	return 0;
 }
 
 void eDVBVideo::stop()
 {
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->stopVideo();
+
 	if (m_fcc_enable)
 		return;
 
 	if (m_fd_demux >= 0)
 	{
 		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_STOP  ", m_dev);
-		if (::ioctl(m_fd_demux, DMX_STOP) < 0)
-			eDebugNoNewLine("failed: %m\n");
-		else
 			eDebugNoNewLine("ok\n");
 	}
 
@@ -456,6 +448,10 @@
 
 void eDVBVideo::freeze()
 {
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoPause();
+	eDebug("VIDEO PAUSE");
+
 	if (m_fd >= 0)
 	{
 		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_FREEZE ", m_dev);
@@ -468,6 +464,10 @@
 
 void eDVBVideo::unfreeze()
 {
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoResume();
+	eDebug("VIDEO CONTINUE");
+
 	if (m_fd >= 0)
 	{
 		eDebugNoNewLineStart("[eDVBVideo%d] VIDEO_CONTINUE ", m_dev);
@@ -510,11 +510,10 @@
 
 int eDVBVideo::getPTS(pts_t &now)
 {
-	if (m_fd >= 0)
-	{
-		int ret = ::ioctl(m_fd, VIDEO_GET_PTS, &now);
-		if (ret < 0)
-			eDebug("[eDVBVideo%d] VIDEO_GET_PTS failed: %m", m_dev);
+	cXineLib *xineLib = cXineLib::getInstance();
+	int ret = xineLib->getPTS(now);
+	if (ret < 0) {
+		eDebug("VIDEO_GET_PTS failed: %m");
 		return ret;
 	}
 	return 0;
@@ -526,7 +525,6 @@
 		::close(m_fd);
 	if (m_fd_demux >= 0)
 		::close(m_fd_demux);
-	eDebug("[eDVBVideo%d] destroy", m_dev);
 }
 
 void eDVBVideo::video_event(int)
@@ -899,7 +897,7 @@
 		if ((m_apid >= 0) && (m_apid < 0x1FFF) && !noaudio)
 		{
 			m_audio = new eDVBAudio(m_demux, m_decoder);
-			if (m_audio->startPid(m_apid, m_atype))
+			if (m_audio->startPid(m_apid, m_atype, m_is_radio))
 				res = -1;
 		}
 		m_changed &= ~changeAudio;
@@ -910,8 +908,16 @@
 		{
 			m_video = new eDVBVideo(m_demux, m_decoder, m_fcc_enable);
 			m_video->connectEvent(sigc::mem_fun(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
-			if (m_video->startPid(m_vpid, m_vtype))
-				res = -1;
+			if (m_vstreamtype != 0)
+			{
+				if (m_video->startPid(m_vpid, m_vstreamtype, m_is_pvr))
+					res = -1;
+			}
+			else
+			{
+				if (m_video->startPid(m_vpid, m_vtype, m_is_pvr))
+					res = -1;
+			}
 		}
 		m_changed &= ~changeVideo;
 	}
@@ -1016,7 +1022,7 @@
 
 eTSMPEGDecoder::eTSMPEGDecoder(eDVBDemux *demux, int decoder)
 	: m_demux(demux),
-		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
+		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1), m_vstreamtype(-1), m_is_pvr(false), m_is_radio(false),
 		m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp)),
 		m_fcc_fd(-1), m_fcc_enable(false), m_fcc_state(fcc_state_stop), m_fcc_feid(-1), m_fcc_vpid(-1), m_fcc_vtype(-1), m_fcc_pcrpid(-1)
 {
@@ -1028,7 +1034,6 @@
 	m_state = stateStop;
 
 	char filename[128] = {};
-	sprintf(filename, "/dev/dvb/adapter%d/audio%d", m_demux ? m_demux->adapter : 0, m_decoder);
 	m_has_audio = !access(filename, W_OK);
 
 	if (m_demux && m_decoder == 0)	// Tuxtxt caching actions only on primary decoder
@@ -1048,27 +1053,33 @@
 		eTuxtxtApp::getInstance()->freeCache();
 }
 
-RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
+RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type, int streamtype)
 {
-	if ((m_vpid != vpid) || (m_vtype != type))
+	printf("eTSMPEGDecoder setVideoPID %d\n", vpid);
+	if ((m_vpid != vpid) || (m_vtype != type) || (m_vstreamtype != streamtype))
 	{
 		m_changed |= changeVideo;
 		m_vpid = vpid;
 		m_vtype = type;
+		m_vstreamtype = streamtype;
+
+		if (m_vstreamtype == 0)
+			m_is_pvr = true;
+		else
+			m_is_pvr = false;
 	}
 	return 0;
 }
 
-RESULT eTSMPEGDecoder::setAudioPID(int apid, int type)
+RESULT eTSMPEGDecoder::setAudioPID(int apid, int type, bool amode)
 {
-	/* do not set an audio pid on decoders without audio support */
-	if (!m_has_audio) apid = -1;
-
+	printf("eTSMPEGDecoder setAudioPID %d\n", apid);
 	if ((m_apid != apid) || (m_atype != type))
 	{
 		m_changed |= changeAudio;
 		m_atype = type;
 		m_apid = apid;
+		m_is_radio = amode;
 	}
 	return 0;
 }
@@ -1260,8 +1271,6 @@
 		{
 			struct stat s = {};
 			fstat(f, &s);
-			if (m_video_clip_fd == -1)
-				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
 			{
 				bool seq_end_avail = false;
diff -ruN o/lib/dvb/decoder.h pc/lib/dvb/decoder.h
--- o/lib/dvb/decoder.h	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/decoder.h	2025-07-11 16:39:46.950637221 +0300
@@ -3,6 +3,7 @@
 
 #include <lib/base/object.h>
 #include <lib/dvb/demux.h>
+#include <lib/gdi/gxlibdc.h>
 
 class eSocketNotifier;
 
@@ -18,7 +19,7 @@
 	enum { aMonoLeft, aStereo, aMonoRight };
 	void setChannel(int channel);
 	void stop();
-	int startPid(int pid, int type);
+	int startPid(int pid, int type, bool mode);
 	void flush();
 	void freeze();
 	void unfreeze();
@@ -44,7 +45,7 @@
 	enum { UNKNOWN = -1, MPEG2, MPEG4_H264, VC1 = 3, MPEG4_Part2, VC1_SM, MPEG1, H265_HEVC, AVS = 16, AVS2 = 40 };
 	eDVBVideo(eDVBDemux *demux, int dev, bool fcc_enable=false);
 	void stop();
-	int startPid(int pid, int type=MPEG2);
+	int startPid(int pid, int type=MPEG2, bool is_pvr=false);
 	void flush();
 	void freeze();
 	int setSlowMotion(int repeat);
@@ -100,7 +101,8 @@
 	ePtr<eDVBVideo> m_video;
 	ePtr<eDVBPCR> m_pcr;
 	ePtr<eDVBTText> m_text;
-	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid;
+	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid, m_vstreamtype;
+	bool m_is_pvr, m_is_radio;
 	enum
 	{
 		changeVideo = 1,
@@ -134,8 +136,8 @@
 	enum { pidNone = -1 };
 	eTSMPEGDecoder(eDVBDemux *demux, int decoder);
 	virtual ~eTSMPEGDecoder();
-	RESULT setVideoPID(int vpid, int type);
-	RESULT setAudioPID(int apid, int type);
+	RESULT setVideoPID(int vpid, int type, int streamtype);
+	RESULT setAudioPID(int apid, int type, bool amode);
 	RESULT setAudioChannel(int channel);
 	int getAudioChannel();
 	RESULT setPCMDelay(int delay);
diff -ruN o/lib/dvb/decsa.cpp pc/lib/dvb/decsa.cpp
--- o/lib/dvb/decsa.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/dvb/decsa.cpp	2025-07-11 16:39:46.951637166 +0300
@@ -0,0 +1,247 @@
+/*
+ * Based on "Softcam plugin to VDR (C++)"
+ */
+
+#include <lib/dvb/decsa.h>
+
+static bool CheckNull(const unsigned char *data, int len)
+{
+  while(--len>=0)
+    if(data[len])
+      return false;
+  return true;
+}
+
+cDeCSA::cDeCSA(int _adapter, int _demux)
+  :stall(MAX_STALL_MS)
+{
+  adapter = _adapter;
+  demux = _demux;
+
+  cs=dvbcsa_bs_batch_size();
+  cs_tsbbatch_even = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
+  cs_tsbbatch_odd = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
+  memset(cs_key_even, 0, sizeof(cs_key_even));
+  memset(cs_key_odd, 0, sizeof(cs_key_odd));
+  memset(pidmap, 0, sizeof(pidmap));
+
+  ResetState();
+}
+
+cDeCSA::~cDeCSA()
+{
+  for(int i=0; i<MAX_CSA_IDX; i++) {
+    if (cs_key_even[i])
+      dvbcsa_bs_key_free(cs_key_even[i]);
+    if (cs_key_odd[i])
+      dvbcsa_bs_key_free(cs_key_odd[i]);
+  }
+  free(cs_tsbbatch_even);
+  free(cs_tsbbatch_odd);
+}
+
+void cDeCSA::ResetState(void)
+{
+  printf("adapter%d/demux%d: reset state", adapter, demux);
+  memset(even_odd,0,sizeof(even_odd));
+  memset(flags,0,sizeof(flags));
+//  memset(usedPids,0,sizeof(usedPids));
+  lastData=0;
+}
+
+bool cDeCSA::GetKeyStruct(int idx)
+{
+  if (!cs_key_even[idx])
+    cs_key_even[idx] = dvbcsa_bs_key_alloc();
+  if (!cs_key_odd[idx])
+    cs_key_odd[idx] = dvbcsa_bs_key_alloc();
+  return (cs_key_even[idx] != 0) && (cs_key_odd[idx] != 0);
+}
+
+bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
+{
+  cMutexLock lock(&mutex);
+
+  int idx=ca_descr->index;
+  if(idx<MAX_CSA_IDX && GetKeyStruct(idx)) {
+    if(!initial && ca_descr->parity==(even_odd[idx]&0x40)>>6) {
+      if(flags[idx] & (ca_descr->parity?FL_ODD_GOOD:FL_EVEN_GOOD)) {
+        printf("adapter%d/demux%d idx %d: %s key in use (%d ms)", adapter, demux ,idx,ca_descr->parity?"odd":"even",MAX_REL_WAIT);
+        if(wait.TimedWait(mutex,MAX_REL_WAIT))
+          printf("adapter%d/demux%d idx %d: successfully waited for release\n", adapter, demux, idx);
+        else
+          printf("adapter%d/demux%d idx %d: timed out. setting anyways\n", adapter, demux, idx);
+      }
+      else
+        printf("adapter%d/demux%d idx %d: late key set...\n", adapter, demux, idx);
+    }
+    if(ca_descr->parity==0) {
+      dvbcsa_bs_key_set(ca_descr->cw, cs_key_even[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_EVEN_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx %d: zero even CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    } else {
+      dvbcsa_bs_key_set(ca_descr->cw, cs_key_odd[idx]);
+
+      if(!CheckNull(ca_descr->cw,8))
+        flags[idx] |= FL_ODD_GOOD|FL_ACTIVITY;
+      else
+        printf("adapter%d/demux%d idx%d: zero odd CW\n", adapter, demux, idx);
+      wait.Broadcast();
+    }
+  }
+
+  return true;
+}
+
+bool cDeCSA::SetCaPid(ca_pid_t *ca_pid)
+{
+  cMutexLock lock(&mutex);
+
+  if(ca_pid->index<MAX_CSA_IDX && ca_pid->pid<MAX_CSA_PIDS) {
+
+    pidmap[ca_pid->pid] = ca_pid->index;
+    printf("adapter%d/demux%d idx %d: set pid %04x\n", adapter, demux, ca_pid->index, ca_pid->pid);
+    //printf("adapter%d/demux%d idx %d: udedPids %d\n", adapter, demux, idx, usedPids[idx]);
+  }
+
+  return true;
+}
+
+unsigned char ts_packet_get_payload_offset(unsigned char *ts_packet)
+{
+  if (ts_packet[0] != TS_SYNC_BYTE)
+    return 0;
+
+  unsigned char adapt_field   = (ts_packet[3] &~ 0xDF) >> 5; // 11x11111
+  unsigned char payload_field = (ts_packet[3] &~ 0xEF) >> 4; // 111x1111
+
+  if (!adapt_field && !payload_field)     // Not allowed
+    return 0;
+
+  if (adapt_field)
+  {
+    unsigned char adapt_len = ts_packet[4];
+    if (payload_field && adapt_len > 182) // Validity checks
+      return 0;
+    if (!payload_field && adapt_len > 183)
+      return 0;
+    if (adapt_len + 4 > TS_SIZE)  // adaptation field takes the whole packet
+      return 0;
+    return 4 + 1 + adapt_len;     // ts header + adapt_field_len_byte + adapt_field_len
+  }
+  else
+  {
+    return 4; // No adaptation, data starts directly after TS header
+  }
+}
+
+bool cDeCSA::Decrypt(unsigned char *data, int len, int& packetsCount)
+{
+  cMutexLock lock(&mutex);
+//  printf("Begin Decrypting %d\n", len);
+  if (!cs_tsbbatch_even || !cs_tsbbatch_odd)
+  {
+    printf("Error allocating memory for DeCSA\n");
+    return false;
+  }
+
+  int ccs = 0, currIdx=-1;
+  int payload_len, offset;
+  int cs_fill_even = 0;
+  int cs_fill_odd = 0;
+  len-=(TS_SIZE-1);
+  int l;
+  int packets=0;
+
+  for(l=0; l<len; l+=TS_SIZE) {
+    if (data[l] != TS_SYNC_BYTE)
+    {                           // let higher level cope with that
+      break;
+    }
+    unsigned int ev_od=data[l+3]&0xC0;
+    if(ev_od==0x80 || ev_od==0xC0) { // encrypted
+      offset = ts_packet_get_payload_offset(data + l);
+      payload_len = TS_SIZE - offset;
+      int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
+      if(currIdx<0 || idx==currIdx) { // same or no index
+        data[l + 3] &= 0x3F;
+        currIdx=idx;
+        if(ccs == 0 && ev_od!=even_odd[idx]) {
+//          if (cryptedPackets==0) {
+            even_odd[idx]=ev_od;
+            wait.Broadcast();
+            printf("adapter%d/demux%d idx %d: change to %s key\n", adapter, demux, idx, (ev_od&0x40)?"odd":"even");
+          
+            bool doWait=false;
+            if(ev_od&0x40) {
+              flags[idx]&=~FL_EVEN_GOOD;
+              if(!(flags[idx]&FL_ODD_GOOD)) doWait=true;
+            }
+            else {
+              flags[idx]&=~FL_ODD_GOOD;
+              if(!(flags[idx]&FL_EVEN_GOOD)) doWait=true;
+            }
+            if(doWait) {
+              printf("adapter%d/demux%d idx %d: %s key not ready (%d ms)\n",
+                  adapter, demux, idx, (ev_od&0x40)?"odd":"even", MAX_KEY_WAIT);
+              if(flags[idx]&FL_ACTIVITY) {
+                flags[idx]&=~FL_ACTIVITY;
+                if(wait.TimedWait(mutex,MAX_KEY_WAIT))
+                  printf("adapter%d/demux%d idx %d: successfully waited for key\n", adapter, demux, idx);
+                else
+                  printf("adapter%d/demux%d idx %d: timed out. proceeding anyways\n", adapter, demux, idx);
+              } else
+                printf("adapter%d/demux%d idx %d: not active. wait skipped\n", adapter, demux, idx);
+            }
+//          } else {
+//            break;
+//          }
+        }
+      }
+//      else
+//        break;
+
+      if (((ev_od & 0x40) >> 6) == 0) {
+          cs_tsbbatch_even[cs_fill_even].data = &data[l + offset];
+          cs_tsbbatch_even[cs_fill_even].len = payload_len;
+          cs_fill_even++;
+      } else {
+          cs_tsbbatch_odd[cs_fill_odd].data = &data[l + offset];
+          cs_tsbbatch_odd[cs_fill_odd].len = payload_len;
+          cs_fill_odd++;
+      }
+
+      if(++ccs >= cs)
+        break;
+    }
+
+    packets++;
+  }
+
+  if (GetKeyStruct(currIdx)) {
+   if (cs_fill_even)
+    {
+      cs_tsbbatch_even[cs_fill_even].data = NULL;
+      dvbcsa_bs_decrypt(cs_key_even[currIdx], cs_tsbbatch_even, 184);
+      cs_fill_even = 0;
+    }
+    if (cs_fill_odd)
+    {
+      cs_tsbbatch_odd[cs_fill_odd].data = NULL;
+      dvbcsa_bs_decrypt(cs_key_odd[currIdx], cs_tsbbatch_odd, 184);
+      cs_fill_odd = 0;
+    }
+    stall.Set(MAX_STALL_MS);
+
+  }
+
+  packetsCount = packets;
+
+  return true;
+}
+
+
diff -ruN o/lib/dvb/decsa.h pc/lib/dvb/decsa.h
--- o/lib/dvb/decsa.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/dvb/decsa.h	2025-07-11 16:39:46.951637166 +0300
@@ -0,0 +1,50 @@
+#ifndef __dvb_decsa_h
+#define __dvb_decsa_h
+
+#include "../dvbsoftwareca/ca.h"
+#include <lib/base/condVar.h>
+
+extern "C" {
+#include <dvbcsa/dvbcsa.h>
+}
+
+#define TS_SIZE          188
+#define TS_SYNC_BYTE     0x47
+
+#define MAX_REL_WAIT 100 // time to wait if key in used on set
+#define MAX_KEY_WAIT 500 // time to wait if key not ready on change
+#define MAX_STALL_MS 70
+
+#define MAX_CSA_PIDS 8192
+#define MAX_CSA_IDX  16
+#define FL_EVEN_GOOD 1
+#define FL_ODD_GOOD  2
+#define FL_ACTIVITY  4
+
+class cDeCSA {
+private:
+  int cs;
+  unsigned char *lastData;
+  unsigned char pidmap[MAX_CSA_PIDS];
+  unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX], usedPids[MAX_CSA_IDX];
+  cMutex mutex;
+  cCondVar wait;
+  cTimeMs stall;
+  int adapter, demux;
+  struct dvbcsa_bs_key_s *cs_key_even[MAX_CSA_IDX];
+  struct dvbcsa_bs_key_s *cs_key_odd[MAX_CSA_IDX];
+  struct dvbcsa_bs_batch_s *cs_tsbbatch_even;
+  struct dvbcsa_bs_batch_s *cs_tsbbatch_odd;
+
+  bool GetKeyStruct(int idx);
+  void ResetState(void);
+public:
+  cDeCSA(int _adapter, int _demux);
+  ~cDeCSA();
+  bool Decrypt(unsigned char *data, int len, int& packetsCount);
+
+  bool SetDescr(ca_descr_t *ca_descr, bool initial);
+  bool SetCaPid(ca_pid_t *ca_pid);
+};
+
+#endif
diff -ruN o/lib/dvb/demux.cpp pc/lib/dvb/demux.cpp
--- o/lib/dvb/demux.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/demux.cpp	2025-07-11 16:39:46.953637057 +0300
@@ -44,7 +44,11 @@
 	}
 	unsigned int megabytes = si.totalram >> 20;
 	int result;
-	if (megabytes > 400)
+	if (megabytes > 1600)
+		result = 160; // 4096MB systems: Use 32MB IO buffers (PC)
+	else if (megabytes > 800)
+		result = 80; // 2048MB systems: Use 16MB IO buffers (PC)
+	else if (megabytes > 400)
 		result = 40; // 1024MB systems: Use 8MB IO buffers (vusolo2, vuduo2, ...)
 	else if (megabytes > 200)
 		result = 20; // 512MB systems: Use 4MB IO buffers (et9x00, vuultimo, ...)
@@ -67,11 +71,12 @@
 {
 	if (CFile::parseInt(&m_dvr_source_offset, "/proc/stb/frontend/dvr_source_offset") == 0)
 		eDebug("[eDVBDemux] using %d for PVR DMX_SET_SOURCE", m_dvr_source_offset);
-
+	decsa = new cDeCSA(adapter, demux);
 }
 
 eDVBDemux::~eDVBDemux()
 {
+	delete decsa;
 }
 
 int eDVBDemux::openDemux(void)
@@ -99,7 +104,7 @@
 	int n = DMX_SOURCE_FRONT0 + fenum;
 	int res = ::ioctl(fd, DMX_SET_SOURCE, &n);
 	if (res)
-		eDebug("[eDVBDemux] DMX_SET_SOURCE Frontend%d failed: %m", fenum);
+		eDebug("[eDVBDemux] DMX_SET_SOURCE demux%d");
 	else
 		source = fenum;
 	::close(fd);
@@ -192,6 +197,20 @@
 	return 0;
 }
 
+RESULT eDVBDemux::setCaDescr(ca_descr_t *ca_descr, bool initial)
+{
+	return decsa->SetDescr(ca_descr, initial);
+}
+
+RESULT eDVBDemux::setCaPid(ca_pid_t *ca_pid)
+{
+	return decsa->SetCaPid(ca_pid);
+}
+
+bool eDVBDemux::decrypt(uint8_t *data, int len, int &packetsCount) {
+	return decsa->Decrypt(data, len, packetsCount);
+}
+
 void eDVBSectionReader::data(int)
 {
 	uint8_t data[4096] = {}; // max. section size
@@ -781,6 +800,7 @@
 
 RESULT eDVBTSRecorder::start()
 {
+	eDebug("eDVBTSRecorder::start");
 	std::map<int,int>::iterator i(m_pids.begin());
 
 	if (m_running)
@@ -794,6 +814,7 @@
 
 	char filename[128];
 	snprintf(filename, 128, "/dev/dvb/adapter%d/demux%d", m_demux->adapter, m_demux->demux);
+	eDebug("eDVBTSRecorder::start %s", filename);
 
 	m_source_fd = ::open(filename, O_RDONLY | O_CLOEXEC);
 
@@ -826,14 +847,14 @@
 	if (!m_target_filename.empty())
 		m_thread->startSaveMetaInformation(m_target_filename);
 
-	m_thread->start(m_source_fd);
-	m_running = 1;
-
 	while (i != m_pids.end()) {
 		startPID(i->first);
 		++i;
 	}
 
+	m_thread->start(m_source_fd, m_demux);
+	m_running = 1;
+
 	return 0;
 }
 
diff -ruN o/lib/dvb/demux.h pc/lib/dvb/demux.h
--- o/lib/dvb/demux.h	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/demux.h	2025-07-11 16:39:46.953637057 +0300
@@ -6,52 +6,7 @@
 #include <lib/dvb/idemux.h>
 #include <lib/dvb/pvrparse.h>
 #include "filepush.h"
-
-class eDVBDemux: public iDVBDemux
-{
-	DECLARE_REF(eDVBDemux);
-public:
-	enum {
-		evtFlush
-	};
-	eDVBDemux(int adapter, int demux);
-	virtual ~eDVBDemux();
-
-	RESULT setSourceFrontend(int fenum);
-	int getSource() { return source; }
-	RESULT setSourcePVR(int pvrnum);
-	int getDvrId() { return m_dvr_id; }
-
-	RESULT createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader);
-	RESULT createPESReader(eMainloop *context, ePtr<iDVBPESReader> &reader);
-	RESULT createTSRecorder(ePtr<iDVBTSRecorder> &recorder, int packetsize = 188, bool streaming=false);
-	RESULT getMPEGDecoder(ePtr<iTSMPEGDecoder> &reader, int index);
-	RESULT getSTC(pts_t &pts, int num);
-	RESULT getCADemuxID(uint8_t &id) { id = demux; return 0; }
-	RESULT getCAAdapterID(uint8_t &id) { id = adapter; return 0; }
-	RESULT flush();
-	RESULT connectEvent(const sigc::slot<void(int)> &event, ePtr<eConnection> &conn);
-	int openDVR(int flags);
-
-	int getRefCount() { return ref; }
-private:
-	int adapter, demux, source;
-
-	int m_dvr_busy;
-	int m_dvr_id;
-	int m_dvr_source_offset;
-	friend class eDVBSectionReader;
-	friend class eDVBPESReader;
-	friend class eDVBAudio;
-	friend class eDVBVideo;
-	friend class eDVBPCR;
-	friend class eDVBTText;
-	friend class eDVBTSRecorder;
-	friend class eDVBCAService;
-	friend class eTSMPEGDecoder;
-	sigc::signal<void(int)> m_event;
-	int openDemux(void);
-};
+#include <lib/dvb/edvbdemux.h>
 
 class eDVBSectionReader: public iDVBSectionReader, public sigc::trackable
 {
diff -ruN o/lib/dvb/dvb.cpp pc/lib/dvb/dvb.cpp
--- o/lib/dvb/dvb.cpp	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/dvb.cpp	2025-07-11 16:39:46.954637003 +0300
@@ -100,7 +100,14 @@
 		if (eDVBAdapterLinux::isusb(num_adapter))
 		{
 			eDVBAdapterLinux *adapter = new eDVBUsbAdapter(num_adapter);
-			addAdapter(adapter);
+			adapter->scanDevices();
+			addAdapter(adapter, true);
+		}
+		else
+		{
+			eDVBAdapterLinux *adapter = new eDVBAdapterLinux(num_adapter);
+			adapter->scanDevices();
+			addAdapter(adapter, true);
 		}
 		num_adapter++;
 	}
@@ -1632,6 +1639,22 @@
 	return false;
 }
 
+/* openpliPC */
+RESULT eDVBResourceManager::getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr)
+{
+	eSmartPtrList<iDVBAdapter>::iterator i(m_adapter.begin());
+
+	while (adapter_nr && (i != m_adapter.end())) {
+		--adapter_nr;
+		++i;
+	}
+
+	if (i != m_adapter.end())
+		return i->getDemux(demux, demux_nr);
+	else
+		return -1;
+}
+
 class eDVBChannelFilePush: public eFilePushThread
 {
 public:
@@ -2253,7 +2276,7 @@
 
 RESULT eDVBChannel::getDemux(ePtr<iDVBDemux> &demux, int cap)
 {
-	ePtr<eDVBAllocatedDemux> &our_demux = (cap & capDecode) ? m_decoder_demux : m_demux;
+	ePtr<eDVBAllocatedDemux> &our_demux = m_demux; /* openpliPC */
 
 	eDebug("[eDVBChannel] getDemux cap=%02X", cap);
 
@@ -2327,23 +2350,11 @@
 	m_source = source;
 	m_tstools.setSource(m_source, streaminfo_file);
 
+	m_pvr_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
 	if (m_pvr_fd_dst < 0)
 	{
-		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
-		if (demux)
-		{
-			m_pvr_fd_dst = demux->get().openDVR(O_WRONLY);
-			if (m_pvr_fd_dst < 0)
-			{
-				eDebug("[eDVBChannel] can't open /dev/dvb/adapterX/dvrX: %m");
-				return -ENODEV;
-			}
-		}
-		else
-		{
-			eDebug("[eDVBChannel] no demux allocated yet.. so its not possible to open the dvr device!!");
-			return -ENODEV;
-		}
+		eDebug("can't open DVR device - FIFO file (%m)");
+		return -ENODEV;
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
@@ -2371,7 +2382,7 @@
 	}
 	if (m_pvr_fd_dst >= 0)
 	{
-		::close(m_pvr_fd_dst);
+/* Pipe '/tmp/ENIGMA_FIFO' closed in eDVBServicePlay::stop() (lib/service/servicedvb.cpp) */
 		m_pvr_fd_dst = -1;
 	}
 	m_source = NULL;
diff -ruN o/lib/dvb/dvb.h pc/lib/dvb/dvb.h
--- o/lib/dvb/dvb.h	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/dvb.h	2025-07-11 16:39:46.955636948 +0300
@@ -244,6 +244,7 @@
 	bool frontendIsMultistream(int index);
 	std::string getFrontendCapabilities(int index);
 	void setFrontendType(int index, const char *types);
+	RESULT getAdapterDemux(ePtr<eDVBDemux> &demux, int adapter_nr, int demux_nr);
 };
 SWIG_TEMPLATE_TYPEDEF(ePtr<eDVBResourceManager>, eDVBResourceManager);
 SWIG_EXTEND(ePtr<eDVBResourceManager>,
diff -ruN o/lib/dvb/edvbdemux.h pc/lib/dvb/edvbdemux.h
--- o/lib/dvb/edvbdemux.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/dvb/edvbdemux.h	2025-07-11 16:39:46.956636894 +0300
@@ -0,0 +1,59 @@
+#ifndef __dvb_edvbdemux_h
+#define __dvb_edvbdemux_h
+
+#include <lib/dvb/idvb.h>
+#include <lib/dvb/idemux.h>
+#include <lib/dvb/decsa.h>
+
+class eDVBDemux: public iDVBDemux
+{
+	DECLARE_REF(eDVBDemux);
+public:
+	enum {
+		evtFlush
+	};
+	eDVBDemux(int adapter, int demux);
+	virtual ~eDVBDemux();
+
+	RESULT setSourceFrontend(int fenum);
+	int getSource() { return source; }
+	RESULT setSourcePVR(int pvrnum);
+	int getDvrId() { return m_dvr_id; }
+
+	RESULT createSectionReader(eMainloop *context, ePtr<iDVBSectionReader> &reader);
+	RESULT createPESReader(eMainloop *context, ePtr<iDVBPESReader> &reader);
+	RESULT createTSRecorder(ePtr<iDVBTSRecorder> &recorder, int packetsize = 188, bool streaming=false);
+	RESULT getMPEGDecoder(ePtr<iTSMPEGDecoder> &reader, int index);
+	RESULT getSTC(pts_t &pts, int num);
+	RESULT getCADemuxID(uint8_t &id) { id = demux; return 0; }
+	RESULT getCAAdapterID(uint8_t &id) { id = adapter; return 0; }
+	RESULT flush();
+	RESULT connectEvent(const sigc::slot<void(int)> &event, ePtr<eConnection> &conn);
+	int openDVR(int flags);
+
+	int getRefCount() { return ref; }
+
+	RESULT setCaDescr(ca_descr_t *ca_descr, bool initial);
+	RESULT setCaPid(ca_pid_t *ca_pid);
+	bool decrypt(uint8_t *data, int len, int &packetsCount);
+private:
+	int adapter, demux, source;
+	cDeCSA *decsa;
+
+	int m_dvr_busy;
+	int m_dvr_id;
+	int m_dvr_source_offset;
+	friend class eDVBSectionReader;
+	friend class eDVBPESReader;
+	friend class eDVBAudio;
+	friend class eDVBVideo;
+	friend class eDVBPCR;
+	friend class eDVBTText;
+	friend class eDVBTSRecorder;
+	friend class eDVBCAService;
+	friend class eTSMPEGDecoder;
+	sigc::signal<void(int)> m_event;
+	int openDemux(void);
+};
+
+#endif
diff -ruN o/lib/dvb/filepush.cpp pc/lib/dvb/filepush.cpp
--- o/lib/dvb/filepush.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/dvb/filepush.cpp	2025-07-11 16:39:46.957636839 +0300
@@ -359,11 +359,6 @@
 
 void eFilePushThreadRecorder::thread()
 {
-	ssize_t bytes;
-	int rv;
-	struct pollfd pfd = {};
-	sigset_t sigmask;
-
 	eDebug("[eFilePushThreadRecorder] THREAD START");
 
 	setIoPrio(IOPRIO_CLASS_RT, 7);
@@ -371,16 +366,22 @@
 	/* Only allow SIGUSR1 to be delivered to our thread, don't let any
 	 * other signals (like SIGHCHLD) interrupt our system calls.
 	 * NOTE: signal block masks are per thread, so set it in the thread itself. */
-	sigfillset(&sigmask);
+/*	sigfillset(&sigmask);
 	sigdelset(&sigmask, SIGUSR1);
-	pthread_sigmask(SIG_SETMASK, &sigmask, nullptr);
+	pthread_sigmask(SIG_SETMASK, &sigmask, nullptr);*/
+
+	/* we set the signal to not restart syscalls, so we can detect our signal. */
+	struct sigaction act;
+	act.sa_handler = signal_handler; // no, SIG_IGN doesn't do it. we want to receive the -EINTR
+	act.sa_flags = 0;
+	sigaction(SIGUSR1, &act, 0);
 
 	hasStarted();
 
 	/* m_stop must be evaluated after each syscall. */
 	while (!m_stop)
 	{
-		bytes = ::read(m_fd_source, m_buffer, m_buffersize);
+		ssize_t bytes = m_source->read(0, m_buffer, 0);
 
 		if (bytes < 0)
 		{
@@ -389,7 +390,7 @@
 			/* EAGAIN can happen on the Broadcom encoder, even though the fd is not opened nonblocking */
 			if(errno == EAGAIN)
 			{
-				pfd.fd = m_fd_source;
+/*				pfd.fd = m_fd_source;
 				pfd.events = POLLIN;
 				pfd.revents = 0;
 
@@ -438,7 +439,7 @@
 					sendEvent(evtWriteError);
 
 					break;
-				}
+				} */
 
 				continue;
 			}
@@ -497,14 +498,25 @@
 	 * NOTE: signal options and handlers (except for a block mask) are
 	 * global for the process, so install the handler here and not
 	 * in the thread. */
-	struct sigaction act = {};
+/*	struct sigaction act;
 	act.sa_handler = signal_handler;
 	act.sa_flags = 0;
-	sigaction(SIGUSR1, &act, nullptr);
+	sigaction(SIGUSR1, &act, nullptr);*/
 
 	run();
 }
 
+void eFilePushThreadRecorder::start(int fd, ePtr<eDVBDemux> &demux)
+{
+	eDecryptRawFile *f = new eDecryptRawFile();
+	m_source = f;
+	f->setfd(fd);
+	f->setDemux(demux);
+	m_fd_source = 0;
+	m_stop = 0;
+	run();
+}
+
 void eFilePushThreadRecorder::stop()
 {
 	static const struct timespec timespec_1 = { .tv_sec =  0, .tv_nsec = 1000000000 / 10 };
diff -ruN o/lib/dvb/filepush.h pc/lib/dvb/filepush.h
--- o/lib/dvb/filepush.h	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/dvb/filepush.h	2025-07-11 16:39:46.957636839 +0300
@@ -70,6 +70,7 @@
 	void thread();
 	void stop();
 	void start(int sourcefd);
+	void start(int fd, ePtr<eDVBDemux> &demux);
 
 	enum { evtEOF, evtReadError, evtWriteError, evtUser, evtStopped };
 	sigc::signal<void(int)> m_event;
@@ -92,6 +93,7 @@
 	int m_stop;
 	bool m_stopped;
 	eFixedMessagePump<int> m_messagepump;
+	ePtr<iTsSource> m_source;
 	void recvEvent(const int &evt);
 };
 
diff -ruN o/lib/dvb/frontend.cpp pc/lib/dvb/frontend.cpp
--- o/lib/dvb/frontend.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/dvb/frontend.cpp	2025-07-11 16:39:46.959636730 +0300
@@ -562,6 +562,7 @@
 	,m_state(stateClosed), m_timeout(0), m_tuneTimer(0)
 {
 	m_filename = devicenodename;
+	sscanf(devicenodename, "/dev/dvb/adapter%d", &m_dvbid);
 
 	m_timeout = eTimer::create(eApp);
 	CONNECT(m_timeout->timeout, eDVBFrontend::timeout);
@@ -1680,7 +1681,6 @@
 	int fp=::open("/dev/dbox/fp0", O_RDWR);
 	if (fp < 0)
 	{
-		eDebug("[eDVBFrontend] Failed to open /dev/dbox/fp0");
 		return -1;
 	}
 	static bool old_fp = (::ioctl(fp, FP_IOCTL_GET_ID) < 0);
@@ -3240,6 +3240,7 @@
 		case SYS_DVBT2:		ss << " DVBT2"; break;
 		case SYS_TURBO:		ss << " TURBO"; break;
 		case SYS_DTMB:		ss << " DTMB"; break;
+		case SYS_DVBC2:		ss << " DVBC2"; break;
 		}
 	}
 
diff -ruN o/lib/dvb/idvb.h pc/lib/dvb/idvb.h
--- o/lib/dvb/idvb.h	2025-07-11 16:39:11.173578001 +0300
+++ pc/lib/dvb/idvb.h	2025-07-11 16:39:46.959636730 +0300
@@ -728,11 +728,11 @@
 public:
 	enum { pidDisabled = -1 };
 		/** Set Displayed Video PID and type */
-	virtual RESULT setVideoPID(int vpid, int type)=0;
+	virtual RESULT setVideoPID(int vpid, int type, int streamtype)=0;
 
 	enum { af_MPEG, af_AC3, af_DTS, af_AAC, af_DTSHD };
 		/** Set Displayed Audio PID and type */
-	virtual RESULT setAudioPID(int apid, int type)=0;
+	virtual RESULT setAudioPID(int apid, int type, bool mode)=0;
 
 	enum { ac_left, ac_stereo, ac_right };
 		/** Set Displayed Audio Channel */
diff -ruN o/lib/dvb/Makefile.inc pc/lib/dvb/Makefile.inc
--- o/lib/dvb/Makefile.inc	2025-07-08 10:32:49.000000000 +0300
+++ pc/lib/dvb/Makefile.inc	2025-07-11 16:39:46.960636676 +0300
@@ -37,7 +37,9 @@
 	dvb/fbc.cpp \
 	dvb/atsc.cpp \
 	dvb/fcc.cpp \
-	dvb/fccdecoder.cpp
+	dvb/fccdecoder.cpp \
+	dvb/ca_connector.cpp \
+	dvb/decsa.cpp
 
 dvbincludedir = $(pkgincludedir)/lib/dvb
 dvbinclude_HEADERS = \
@@ -83,4 +85,7 @@
 	dvb/fbc.h \
 	dvb/atsc.h \
 	dvb/fcc.h \
-	dvb/fccdecoder.h
+	dvb/fccdecoder.h \
+	dvb/edvbdemux.h \
+	dvb/ca_connector.h \
+	dvb/decsa.h
diff -ruN o/lib/dvb/pmtparse.cpp pc/lib/dvb/pmtparse.cpp
--- o/lib/dvb/pmtparse.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/dvb/pmtparse.cpp	2025-07-11 16:39:46.960636676 +0300
@@ -103,6 +103,7 @@
 				video.type = videoStream::vtMPEG2;
 				audio.type = audioStream::atMPEG;
 				audio.rdsPid = -1;
+				video.orig_streamtype= streamtype;
 
 				switch (streamtype)
 				{
diff -ruN o/lib/dvb/pmtparse.h pc/lib/dvb/pmtparse.h
--- o/lib/dvb/pmtparse.h	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/dvb/pmtparse.h	2025-07-11 16:39:46.960636676 +0300
@@ -26,6 +26,7 @@
 		int component_tag;
 		enum { vtMPEG2, vtMPEG4_H264, vtVC1 = 3, vtMPEG4_Part2, vtVC1_SM, vtMPEG1, vtH265_HEVC, vtCAVS = 16, vtAVS2 = 40 };
 		int type;
+		int orig_streamtype;
 	};
 
 	struct audioStream
diff -ruN o/lib/dvb/volume.cpp pc/lib/dvb/volume.cpp
--- o/lib/dvb/volume.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/dvb/volume.cpp	2025-07-11 16:39:46.960636676 +0300
@@ -5,16 +5,15 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <unistd.h>
+#include <lib/gdi/xineLib.h>
 
 #include <linux/dvb/version.h>
 #if DVB_API_VERSION < 3
-#define VIDEO_DEV "/dev/dvb/card0/video0"
-#define AUDIO_DEV "/dev/dvb/card0/audio0"
+#define AUDIO_DEV "/dev/snd/controlC0"
 #include <ost/audio.h>
 #include <ost/video.h>
 #else
-#define VIDEO_DEV "/dev/dvb/adapter0/video0"
-#define AUDIO_DEV "/dev/dvb/adapter0/audio0"
+#define AUDIO_DEV "/dev/snd/controlC0"
 #include <linux/dvb/audio.h>
 #include <linux/dvb/video.h>
 #endif
@@ -138,8 +137,10 @@
 void eDVBVolumecontrol::setVolume(int left, int right)
 {
 		/* left, right is 0..100 */
+	cXineLib *xineLib = cXineLib::getInstance();
 	leftVol = checkVolume(left);
 	rightVol = checkVolume(right);
+	xineLib->setVolume(leftVol);
 
 #ifdef HAVE_ALSA
 	eDebug("[eDVBVolumecontrol] Setvolume: ALSA leftVol=%d", leftVol);
@@ -163,7 +164,7 @@
 	{
 #ifdef DVB_API_VERSION
 		if (ioctl(fd, AUDIO_SET_MIXER, &mixer) < 0) {
-			eDebug("[eDVBVolumecontrol] Setvolume failed: %m");
+			eDebug("[eDVBVolumecontrol] Set software volume");
 		}
 #endif
 		closeMixer(fd);
@@ -210,6 +211,8 @@
 	//HACK?
 	CFile::writeInt("/proc/stb/audio/j1_mute", 1);
 #endif
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->setVolumeMute(1);
 }
 
 void eDVBVolumecontrol::volumeUnMute()
@@ -233,6 +236,8 @@
 	//HACK?
 	CFile::writeInt("/proc/stb/audio/j1_mute", 0);
 #endif
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->setVolumeMute(0);
 }
 
 void eDVBVolumecontrol::volumeToggleMute()
diff -ruN o/lib/gdi/gpixmap.cpp pc/lib/gdi/gpixmap.cpp
--- o/lib/gdi/gpixmap.cpp	2025-07-11 16:39:11.173578001 +0300
+++ pc/lib/gdi/gpixmap.cpp	2025-07-11 16:39:46.961636622 +0300
@@ -210,12 +210,6 @@
 gSurface::gSurface(int width, int height, int _bpp, int accel):
 	gUnmanagedSurface(width, height, _bpp)
 {
-	if ((accel > gPixmap::accelAuto) ||
-		((accel == gPixmap::accelAuto) && (is_a_candidate_for_accel(this))))
-	{
-		if (gAccel::getInstance()->accelAlloc(this) != 0)
-				eDebug("[gSurface] ERROR: accelAlloc failed");
-	}
 	if (!data)
 	{
 		data = new unsigned char [y * stride];
diff -ruN o/lib/gdi/gxlibdc.cpp pc/lib/gdi/gxlibdc.cpp
--- o/lib/gdi/gxlibdc.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/gdi/gxlibdc.cpp	2025-07-11 16:39:46.961636622 +0300
@@ -0,0 +1,388 @@
+#include <fstream>
+#include <lib/gdi/gxlibdc.h>
+#include <lib/actions/action.h>
+#include <lib/base/init.h>
+#include <lib/base/init_num.h>
+#include <lib/base/eenv.h>
+#include <lib/driver/input_fake.h>
+#include <lib/driver/rcxlib.h>
+
+gXlibDC *gXlibDC::instance;
+Display *gXlibDC::display;
+Window  gXlibDC::window;
+int     gXlibDC::width, gXlibDC::height;
+double  gXlibDC::pixel_aspect;
+int     gXlibDC::xpos, gXlibDC::ypos;
+
+static const std::string getConfigString(const std::string &key, const std::string &defaultValue)
+{
+	std::string value = defaultValue;
+
+	// get value from enigma2 settings file
+	std::ifstream in(eEnv::resolve("${sysconfdir}/enigma2/settings").c_str());
+	if (in.good()) {
+		do {
+			std::string line;
+			std::getline(in, line);
+			size_t size = key.size();
+			if (!line.compare(0, size, key) && line[size] == '=') {
+				value = line.substr(size + 1);
+				break;
+			}
+		} while (in.good());
+		in.close();
+	}
+
+	return value;
+}
+
+static bool getConfigBool(const std::string &key, bool defaultValue) {
+	std::string value = getConfigString(key, defaultValue ? "true" : "false");
+	const char *cvalue = value.c_str();
+
+	if (!strcasecmp(cvalue, "true"))
+		return true;
+	if (!strcasecmp(cvalue, "false"))
+		return false;
+
+	return defaultValue;
+}
+
+static int getConfigInt(const std::string &key) {
+	std::string value = getConfigString(key, "0");
+		return atoi(value.c_str());
+}
+
+gXlibDC::gXlibDC() : m_pump(eApp, 1) {
+	double res_h, res_v;
+
+	umask(0);
+	mknod("/tmp/ENIGMA_FIFO", S_IFIFO|0666, 0);
+
+	CONNECT(m_pump.recv_msg, gXlibDC::pumpEvent);
+
+	argb_buffer = NULL;
+	fullscreen = getConfigBool("config.pc.default_fullscreen", false);
+	initialWindowWidth  = getConfigInt("config.pc.initial_window_width");
+	initialWindowHeight = getConfigInt("config.pc.initial_window_height");
+	windowWidth  = 720;
+	windowHeight = 576;
+	xpos = 0;
+	ypos = 0;
+
+	ASSERT(instance == 0);
+	instance = this;
+
+	if(!XInitThreads()) {
+		eFatal("XInitThreads() failed\n");
+		return;
+	}
+
+	if((display = XOpenDisplay(getenv("DISPLAY"))) == NULL) {
+		eFatal("XOpenDisplay() failed.\n");
+		return;
+	}
+
+	screen = XDefaultScreen(display);
+
+	if (fullscreen) {
+		width  = DisplayWidth( display, screen );
+		height = DisplayHeight( display, screen );
+	} else {
+		width  = windowWidth;
+		height = windowHeight;
+	}
+
+	XLockDisplay(display);
+	if (initialWindowWidth && initialWindowHeight)
+		window = XCreateSimpleWindow(display, XDefaultRootWindow(display), xpos, ypos, initialWindowWidth, initialWindowHeight, 0, 0, 0);
+	else
+		window = XCreateSimpleWindow(display, XDefaultRootWindow(display), xpos, ypos, windowWidth, windowHeight, 0, 0, 0);
+	XSelectInput (display, window, INPUT_MOTION);
+	XMapRaised(display, window);
+	res_h = (DisplayWidth(display, screen) * 1000 / DisplayWidthMM(display, screen));
+	res_v = (DisplayHeight(display, screen) * 1000 / DisplayHeightMM(display, screen));
+	XSync(display, False);
+	XUnlockDisplay(display);
+
+	wmDelete=XInternAtom(display, "WM_DELETE_WINDOW", True);
+	XSetWMProtocols(display, window, &wmDelete, 1);
+
+	printf("Display resolution %d %d\n", DisplayWidth(display, screen), DisplayHeight(display, screen));
+
+	vis.display         = display;
+	vis.screen          = screen;
+	vis.d               = window;
+	vis.dest_size_cb    = dest_size_cb;
+	vis.frame_output_cb = frame_output_cb;
+	vis.user_data       = NULL;
+	pixel_aspect        = res_v / res_h;
+
+	if(fabs(pixel_aspect - 1.0) < 0.01)
+		pixel_aspect = 1.0;
+
+	xineLib = new cXineLib(&vis);
+
+	setResolution(windowWidth, windowHeight); // default res
+
+	if (fullscreen) {
+		fullscreen=false;
+		fullscreen_switch();
+	}
+
+	run();
+
+	/*m_surface.type = 0;
+	m_surface.clut.colors = 256;
+	m_surface.clut.data = new gRGB[m_surface.clut.colors];
+
+	m_pixmap = new gPixmap(&m_surface);
+
+	memset(m_surface.clut.data, 0, sizeof(*m_surface.clut.data)*m_surface.clut.colors);*/
+}
+
+gXlibDC::~gXlibDC() {
+	instance = 0;
+
+	thread_stop = true;
+	kill();
+
+	if (xineLib) {
+		delete xineLib;
+		xineLib = NULL;
+	}
+
+	XLockDisplay(display);
+	XUnmapWindow(display, window);
+	XDestroyWindow(display, window);
+	XUnlockDisplay(display);
+
+	XCloseDisplay (display);
+}
+
+void gXlibDC::keyEvent(const XKeyEvent &event) {
+	eXlibInputDriver *driver = eXlibInputDriver::getInstance();
+	xineLib->getVideoFrameRate();
+	eDebug("SDL Key %s: key=%d", (event.type == KeyPress) ? "Down" : "Up", event.keycode);
+
+	if (driver)
+		driver->keyPressed(event);
+}
+
+void gXlibDC::pumpEvent(const XKeyEvent &event) {
+	switch (event.type) {
+	case KeyPress:
+	case KeyRelease:
+		switch (event.keycode) {
+		case 95: // F11
+			if (event.type==KeyPress) {
+				fullscreen_switch();
+			}
+			break;
+		case 53: // X
+			if (event.type==KeyPress) {
+				eDebug("Enigma2 Quit");
+				extern void quitMainloop(int exit_code);
+				quitMainloop(0);
+			}
+			break;
+		default:
+			keyEvent(event);
+			break;
+		}
+		break;
+	}
+}
+
+/*void gSDLDC::pushEvent(enum event code, void *data1, void *data2) {
+	SDL_Event event;
+
+	event.type = SDL_USEREVENT;
+	event.user.code = code;
+	event.user.data1 = data1;
+	event.user.data2 = data2;
+
+	SDL_PushEvent(&event);
+}*/
+
+void gXlibDC::exec(const gOpcode *o) {
+	switch (o->opcode) {
+	case gOpcode::flush:
+		eDebug("FLUSH");
+		xineLib->showOsd();
+		break;
+	default:
+		gDC::exec(o);
+		break;
+	}
+}
+
+void gXlibDC::setResolution(int xres, int yres, int bpp) {
+	printf("setResolution %d %d\n", xres, yres);
+	windowWidth  = xres;
+	windowHeight = yres;
+
+	if (!fullscreen) {
+		width = xres;
+		height = yres;
+	}
+
+	if (argb_buffer)
+		delete [] argb_buffer;
+	argb_buffer = new uint32_t[windowWidth*windowHeight];
+	memset(argb_buffer, 0, windowWidth * windowHeight * sizeof(uint32_t));
+
+	xineLib->newOsd(windowWidth, windowHeight, argb_buffer);
+
+//	m_surface.type = 0;
+	m_surface.x = windowWidth;
+	m_surface.y = windowHeight;
+	m_surface.bpp = 32;
+	m_surface.bypp = 4;
+	m_surface.stride = windowWidth*4;
+	m_surface.data = argb_buffer;
+//	m_surface.offset = 0;
+
+	m_pixmap = new gPixmap(&m_surface);
+
+	if (initialWindowWidth == 0 || initialWindowHeight == 0)
+		XResizeWindow(display, window, windowWidth, windowHeight);
+	updateWindowState();
+}
+
+void gXlibDC::updateWindowState() {
+	if (fullscreen)	{
+		width  = DisplayWidth( display, screen );
+		height = DisplayHeight( display, screen );
+	}
+	else if (initialWindowWidth && initialWindowHeight) {
+		width  = initialWindowWidth;
+		height = initialWindowHeight;
+	}
+	else {
+		width  = windowWidth;
+		height = windowHeight;
+	}
+
+	XFlush(display);
+	xineLib->updateWindowSize(width, height);
+	xineLib->showOsd();
+}
+
+void gXlibDC::fullscreen_switch() {
+	printf("FULLSCREEN EVENT\n");
+	fullscreen ^= 1;
+
+	XEvent xev;
+	XLockDisplay(display);
+	Atom wm_state = XInternAtom(display, "_NET_WM_STATE", False);
+	Atom fullscreenAtom = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
+	XUnlockDisplay(display);
+	memset(&xev, 0, sizeof(xev));
+	xev.type = ClientMessage;
+	xev.xclient.window = window;
+	xev.xclient.message_type = wm_state;
+	xev.xclient.format = 32;
+	xev.xclient.data.l[0] = fullscreen ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
+	xev.xclient.data.l[1] = fullscreenAtom;
+	xev.xclient.data.l[2] = 0;
+	XSendEvent(display, XDefaultRootWindow(display), False, SubstructureNotifyMask, &xev);
+
+	updateWindowState();
+}
+
+void gXlibDC::evFlip() {
+	//SDL_Flip(m_screen);
+}
+
+void gXlibDC::thread() {
+	hasStarted();
+
+	int x11_fd = ConnectionNumber(display);
+	thread_stop = false;
+	fd_set in_fds;
+	struct timeval tv;
+	XEvent event;
+
+	while (!thread_stop) {
+		FD_ZERO(&in_fds);
+		FD_SET(x11_fd, &in_fds);
+
+		tv.tv_usec = 100000;
+		tv.tv_sec = 0;
+
+		if (select(x11_fd+1, &in_fds, 0, 0, &tv)) {
+			/*printf("Event Received!\n");*/
+		}
+
+		while(XPending(display)) {
+			XNextEvent(display, &event);
+			printf("XNextEvent %d\n", event.type);
+			switch(event.type) {
+			case KeyPress:
+			case KeyRelease: {
+					XKeyEvent& xKeyEvent = (XKeyEvent&)event;
+					m_pump.send(xKeyEvent);
+				}
+				break;
+			case ClientMessage:
+				if (event.xclient.data.l[0] == wmDelete) {
+					thread_stop = true;
+					XKeyEvent xKeyEvent;
+					xKeyEvent.type = KeyPress;
+					xKeyEvent.keycode = 53; // X
+					m_pump.send(xKeyEvent);
+				}
+				break;
+			case Expose:
+				if(event.xexpose.count != 0)
+					break;
+			xineLib->showOsd();
+			break;
+			case ConfigureNotify: {
+				XConfigureEvent& cne = (XConfigureEvent&)event;
+				Window tmp_win;
+
+				if((cne.x == 0) && (cne.y == 0)) {
+					XLockDisplay(display);
+					XTranslateCoordinates(display, cne.window, DefaultRootWindow(cne.display), 0, 0, &xpos, &ypos, &tmp_win);
+					XUnlockDisplay(display);
+				}
+				else {
+					xpos = cne.x;
+					ypos = cne.y;
+				}
+				if (!fullscreen) {
+					if (cne.width != windowWidth || cne.height != windowHeight) {
+						windowWidth  = cne.width;
+						windowHeight = cne.height;
+						updateWindowState();
+					}
+				}
+			}
+			break;
+			}
+		}
+	}
+}
+
+void gXlibDC::frame_output_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+	int *dest_x, int *dest_y, int *dest_width, int *dest_height, double *dest_pixel_aspect,
+	int *win_x, int *win_y) {
+		*dest_x            = 0;
+		*dest_y            = 0;
+		*win_x             = xpos;
+		*win_y             = ypos;
+		*dest_width        = gXlibDC::width;
+		*dest_height       = gXlibDC::height;
+		*dest_pixel_aspect = gXlibDC::pixel_aspect;
+	}
+
+void gXlibDC::dest_size_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+	int *dest_width, int *dest_height, double *dest_pixel_aspect) {
+		*dest_width        = gXlibDC::width;
+		*dest_height       = gXlibDC::height;
+		*dest_pixel_aspect = gXlibDC::pixel_aspect;
+	}
+
+eAutoInitPtr<gXlibDC> init_gXlibDC(eAutoInitNumbers::graphic-1, "gXlibDC");
diff -ruN o/lib/gdi/gxlibdc.h pc/lib/gdi/gxlibdc.h
--- o/lib/gdi/gxlibdc.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/gdi/gxlibdc.h	2025-07-11 16:39:46.961636622 +0300
@@ -0,0 +1,80 @@
+#ifndef __lib_gdi_gxlibdc_h
+#define __lib_gdi_gxlibdc_h
+
+#include <lib/base/thread.h>
+#include <lib/gdi/gmaindc.h>
+#include <lib/dvb/idvb.h>
+
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+
+#include <lib/gdi/xineLib.h>
+
+#define INPUT_MOTION (ExposureMask | KeyPressMask | KeyReleaseMask | StructureNotifyMask)
+
+enum
+{
+	_NET_WM_STATE_REMOVE =0,
+	_NET_WM_STATE_ADD = 1,
+	_NET_WM_STATE_TOGGLE =2
+};
+
+class gXlibDC: public gMainDC, public eThread, public sigc::trackable
+{
+private:
+	static gXlibDC       *instance;
+
+	int                  screen;
+	x11_visual_t         vis;
+	int                  fullscreen;
+	int                  windowWidth, windowHeight;
+	int                  initialWindowWidth, initialWindowHeight;
+	cXineLib            *xineLib;
+	gSurface             m_surface;
+	uint32_t            *argb_buffer;
+	bool                 thread_stop;
+
+	Atom                 wmDelete;
+
+	void exec(const gOpcode *opcode);
+
+	eFixedMessagePump<XKeyEvent> m_pump;
+	void keyEvent(const XKeyEvent &event);
+	void pumpEvent(const XKeyEvent &event);
+	virtual void thread();
+
+	enum event {
+		EV_SET_VIDEO_MODE,
+		EV_FLIP,
+		EV_QUIT
+	};
+
+	//void pushEvent(enum event code, void *data1 = 0, void *data2 = 0);
+	void evFlip();
+	void fullscreen_switch();
+	void updateWindowState();
+
+public:
+	static int            width, height;
+	static double         pixel_aspect;
+	static Display       *display;
+	static Window         window;
+	static int            xpos, ypos;
+
+	gXlibDC();
+	virtual ~gXlibDC();
+
+	static gXlibDC *getInstance() { return instance; }
+	void setResolution(int xres, int yres, int bpp = 32);
+	int islocked() { return 0; }
+
+	static void frame_output_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+			int *dest_x, int *dest_y, int *dest_width, int *dest_height, double *dest_pixel_aspect,
+			int *win_x, int *win_y);
+	static void dest_size_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
+			 int *dest_width, int *dest_height, double *dest_pixel_aspect);
+
+};
+
+#endif
diff -ruN o/lib/gdi/lcd.cpp pc/lib/gdi/lcd.cpp
--- o/lib/gdi/lcd.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/gdi/lcd.cpp	2025-07-11 16:39:46.961636622 +0300
@@ -162,7 +162,6 @@
 	int fp;
 	if((fp = open("/dev/dbox/fp0", O_RDWR)) < 0)
 	{
-		eDebug("[eDboxLCD] can't open /dev/dbox/fp0: %m");
 		return(-1);
 	}
 
@@ -194,7 +193,6 @@
 		int fp;
 		if ((fp = open("/dev/dbox/fp0", O_RDWR)) < 0)
 		{
-			eDebug("[eDboxLCD] can't open /dev/dbox/fp0: %m");
 			return(-1);
 		}
 #ifndef FP_IOCTL_LCD_DIMM
diff -ruN o/lib/gdi/Makefile.inc pc/lib/gdi/Makefile.inc
--- o/lib/gdi/Makefile.inc	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/gdi/Makefile.inc	2025-07-11 16:39:46.962636567 +0300
@@ -46,8 +46,17 @@
 	gdi/pixmapcache.h \
 	gdi/region.h
 
-if HAVE_LIBSDL
+if HAVE_XLIB
 gdi_libenigma_gdi_a_SOURCES += \
+	gdi/gxlibdc.cpp \
+	gdi/gxlibdc.h \
+	gdi/xineLib.cpp \
+	gdi/xineLib.h \
+	gdi/post.cpp \
+	gdi/post.h
+else
+if HAVE_LIBSDL
+	gdi_libenigma_gdi_a_SOURCES += \
 	gdi/sdl.cpp \
 	gdi/sdl.h
 else
@@ -55,3 +64,4 @@
 	gdi/gfbdc.cpp \
 	gdi/gfbdc.h
 endif
+endif
diff -ruN o/lib/gdi/picload.cpp pc/lib/gdi/picload.cpp
--- o/lib/gdi/picload.cpp	2025-07-11 16:39:11.174577947 +0300
+++ pc/lib/gdi/picload.cpp	2025-07-11 16:39:46.962636567 +0300
@@ -789,8 +789,6 @@
 
 void ePicLoad::decodePic()
 {
-	eDebug("[ePicLoad] decode picture... %s", m_filepara->file);
-
 	getExif(m_filepara->file, m_filepara->id);
 	switch(m_filepara->id)
 	{
@@ -1450,7 +1448,6 @@
 SWIG_VOID(int) loadPic(ePtr<gPixmap> &result, std::string filename, int x, int y, int aspect, int resize_mode, int rotate, int background, std::string cachefile)
 {
 	long asp1, asp2;
-	eDebug("[loadPic] deprecated loadPic function used!!! please use the non blocking version! you can see demo code in Pictureplayer plugin... this function is removed in the near future!");
 
 	switch(aspect)
 	{
diff -ruN o/lib/gdi/post.cpp pc/lib/gdi/post.cpp
--- o/lib/gdi/post.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/gdi/post.cpp	2025-07-11 16:39:46.962636567 +0300
@@ -0,0 +1,818 @@
+/*
+ * Copyright (C) 2003 by Dirk Meyer
+ *
+ * This file is part of xine, a unix video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * The code is taken from xine-ui/src/xitk/post.c at changed to work with fbxine
+ *
+ * Modified for VDR xineliboutput plugin by Petri Hintukainen, 2006
+ *   - runtime re-configuration (load/unload, enable/disable)
+ *   - support for multiple streams
+ *   - support for mosaico post plugin (picture-in-picture)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "post.h"
+
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <errno.h>
+#include <syslog.h>
+#include <xine.h>
+
+#define LOG_MODULENAME "[xine-post] "
+//#include "../logdefs.h"
+
+#define fe_t post_plugins_t
+
+typedef struct {
+	xine_post_t                 *post;
+	const xine_post_api_t           *api;
+	const xine_post_api_descr_t     *descr;
+	const xine_post_api_parameter_t *param;
+	char                        *param_data;
+	char                        **properties_names;
+
+	int                          x;
+	int                          y;
+	int                          readonly;
+} post_object_t;
+
+static int __pplugin_retrieve_parameters(post_object_t *pobj)
+{
+	xine_post_in_t             *input_api;
+
+	input_api = (xine_post_in_t *) xine_post_input(pobj->post, "parameters");
+	if (input_api) {
+		const xine_post_api_t            *post_api;
+		const xine_post_api_descr_t      *api_descr;
+		const xine_post_api_parameter_t  *parm;
+		int                               pnum = 0;
+
+		post_api = (const xine_post_api_t *) input_api->data;
+
+		api_descr = post_api->get_param_descr();
+		parm = api_descr->parameter;
+		pobj->param_data = (char*)malloc(api_descr->struct_size);
+
+		while(parm->type != POST_PARAM_TYPE_LAST) {
+			post_api->get_parameters(pobj->post, pobj->param_data);
+
+			if(!pnum)
+				pobj->properties_names = (char **) calloc(2, sizeof(char *));
+			else
+				pobj->properties_names = (char **) realloc(pobj->properties_names, sizeof(char *) * (pnum + 2));
+			pobj->properties_names[pnum]     = strdup(parm->name);
+			pobj->properties_names[pnum + 1] = NULL;
+			pnum++;
+			parm++;
+		}
+
+		pobj->api      = post_api;
+		pobj->descr    = api_descr;
+		pobj->param    = api_descr->parameter;
+		return 1;
+	}
+	return 0;
+}
+
+static void _pplugin_update_parameter(post_object_t *pobj)
+{
+	pobj->api->set_parameters(pobj->post, pobj->param_data);
+	pobj->api->get_parameters(pobj->post, pobj->param_data);
+}
+
+static void __pplugin_update_parameters(xine_post_t *post, char *args)
+{
+	char *p;
+	post_object_t pobj = {
+		.post = post,
+	};
+
+	if(__pplugin_retrieve_parameters(&pobj)) {
+
+		if(pobj.properties_names && args && *args) {
+			char *param;
+
+			while((param = strsep(&args, ",")) != NULL) {
+				p = param;
+
+				while((*p != '\0') && (*p != '='))
+					p++;
+
+				if(*p) {
+					int param_num = 0;
+					*p++ = '\0';
+
+					while(pobj.properties_names[param_num] && strcasecmp(pobj.properties_names[param_num], param))
+						param_num++;
+
+					if(pobj.properties_names[param_num]) {
+
+						pobj.param    = pobj.descr->parameter;
+						pobj.param    += param_num;
+						pobj.readonly = pobj.param->readonly;
+
+						switch(pobj.param->type) {
+							case POST_PARAM_TYPE_INT:
+							if(!pobj.readonly) {
+								if(pobj.param->enum_values) {
+									char **values = pobj.param->enum_values;
+									int    i = 0;
+
+									while(values[i]) {
+										if(!strcasecmp(values[i], p)) {
+											*(int *)(pobj.param_data + pobj.param->offset) = i;
+											break;
+										}
+										i++;
+									}
+
+									if( !values[i] )
+										*(int *)(pobj.param_data + pobj.param->offset) = (int) strtol(p, &p, 10);
+								} else {
+									*(int *)(pobj.param_data + pobj.param->offset) = (int) strtol(p, &p, 10);
+								}
+								_pplugin_update_parameter(&pobj);
+							}
+							break;
+
+							case POST_PARAM_TYPE_DOUBLE:
+								if(!pobj.readonly) {
+									*(double *)(pobj.param_data + pobj.param->offset) = strtod(p, &p);
+									_pplugin_update_parameter(&pobj);
+								}
+							break;
+
+							case POST_PARAM_TYPE_CHAR:
+							case POST_PARAM_TYPE_STRING:
+								if(!pobj.readonly) {
+									if(pobj.param->type == POST_PARAM_TYPE_CHAR) {
+										int maxlen = pobj.param->size / sizeof(char);
+										snprintf((char *)(pobj.param_data + pobj.param->offset), maxlen, "%s", p);
+										_pplugin_update_parameter(&pobj);
+									}
+								else
+									fprintf(stderr, "parameter type POST_PARAM_TYPE_STRING not supported yet.\n");
+								}
+							break;
+
+							case POST_PARAM_TYPE_STRINGLIST: /* unsupported */
+								if(!pobj.readonly)
+									fprintf(stderr, "parameter type POST_PARAM_TYPE_STRINGLIST not supported yet.\n");
+							break;
+
+							case POST_PARAM_TYPE_BOOL:
+								if(!pobj.readonly) {
+									*(int *)(pobj.param_data + pobj.param->offset) = ((int) strtol(p, &p, 10)) ? 1 : 0;
+									_pplugin_update_parameter(&pobj);
+								}
+							break;
+
+							case POST_PARAM_TYPE_LAST:
+								break; /* terminator of parameter list */
+							default:
+								printf("%s(%d): Unknown post parameter type %d!\n", __FUNCTION__, __LINE__, pobj.param->type);
+						}
+					} else {
+						printf("Unknown post plugin parameter %s !\n", param);
+					}
+				}
+			}
+		}
+
+		if (pobj.properties_names) {
+			int i = 0;
+
+			while(pobj.properties_names[i]) {
+				free(pobj.properties_names[i]);
+				pobj.properties_names[i] = NULL;
+				i++;
+			}
+			free(pobj.properties_names);
+			pobj.properties_names = NULL;
+		}
+		free(pobj.param_data);
+		pobj.param_data = NULL;
+	}
+}
+
+/* -post <name>:option1=value1,option2=value2... */
+static post_element_t **pplugin_parse_and_load(fe_t *fe, int plugin_type, const char *pchain, int *post_elements_num)
+{
+	post_element_t **post_elements = NULL;
+	*post_elements_num = 0;
+
+	if(pchain && strlen(pchain)) {
+		char *post_chain, *freeme, *p;
+		freeme = post_chain = strdup(pchain);
+		while((p = strsep(&post_chain, ";"))) {
+
+			if(p && strlen(p)) {
+				char *plugin, *args = NULL;
+				xine_post_t *post;
+				while(*p == ' ')
+					p++;
+				plugin = strdup(p);
+
+				if((p = strchr(plugin, ':')))
+					*p++ = '\0';
+				if(p && (strlen(p) > 1))
+					args = p;
+#if 0
+				post = xine_post_init(fe->xine, plugin, 0, &fe->audio_port, &fe->video_port);
+#else
+				if(plugin_type == XINE_POST_TYPE_VIDEO_COMPOSE) {
+					post = xine_post_init(fe->xine, plugin, 2, &fe->audio_port, &fe->video_port);
+				} else
+					post = xine_post_init(fe->xine, plugin, 0, &fe->audio_port, &fe->video_port);
+#endif
+				if (post && plugin_type) {
+					if (post->type != plugin_type) {
+						xine_post_dispose(fe->xine, post);
+						post = NULL;
+					}
+				}
+
+				if(post) {
+					if(!(*post_elements_num))
+						post_elements = (post_element_t **) calloc(2, sizeof(post_element_t *));
+					else
+						post_elements = (post_element_t **)
+					realloc(post_elements, sizeof(post_element_t *) * ((*post_elements_num) + 2));
+					post_elements[(*post_elements_num)] = (post_element_t *) calloc(1, sizeof(post_element_t));
+					post_elements[(*post_elements_num)]->post = post;
+					post_elements[(*post_elements_num)]->name = strdup(plugin);
+#if 1
+					post_elements[(*post_elements_num)]->args = args ? strdup(args) : NULL;
+					post_elements[(*post_elements_num)]->enable = 0;
+#endif
+					(*post_elements_num)++;
+					post_elements[(*post_elements_num)] = NULL;
+					__pplugin_update_parameters(post, args);
+				}
+
+				free(plugin);
+			}
+		}
+		free(freeme);
+	}
+
+	return post_elements;
+}
+
+static void strcat_n(size_t sz, char *dst, const char *src)
+{
+	size_t len = strlen(dst) + strlen(src);
+	if (sz < 1)
+		return;
+	if (len + 6 > sz) {
+		while (len + 1 < sz) {
+			dst[len++] = '.';
+		}
+		dst[sz-1] = 0;
+		return;
+	}
+	strcat(dst, src);
+}
+
+static void pplugin_parse_and_store_post(fe_t *fe, int plugin_type, const char *post_chain)
+{
+	post_element_t ***_post_elements;
+	int *_post_elements_num;
+	post_element_t **posts = NULL;
+	int              num;
+
+	switch(plugin_type) {
+		case XINE_POST_TYPE_VIDEO_FILTER:
+			_post_elements = &fe->post_video_elements;
+			_post_elements_num = &fe->post_video_elements_num;
+		break;
+		case XINE_POST_TYPE_VIDEO_COMPOSE:
+			_post_elements = &fe->post_pip_elements;
+			_post_elements_num = &fe->post_pip_elements_num;
+		break;
+		case XINE_POST_TYPE_AUDIO_VISUALIZATION:
+			_post_elements = &fe->post_vis_elements;
+			_post_elements_num = &fe->post_vis_elements_num;
+		break;
+		default:
+			_post_elements = &fe->post_audio_elements;
+			_post_elements_num = &fe->post_audio_elements_num;
+		break;
+	}
+
+	if((posts = pplugin_parse_and_load(fe, plugin_type, post_chain, &num))) {
+		if(*_post_elements_num) {
+			int i;
+			int ptot = *_post_elements_num + num;
+			*_post_elements = (post_element_t **) realloc(*_post_elements, sizeof(post_element_t *) * (ptot + 1));
+			for(i = *_post_elements_num; i <  ptot; i++)
+				(*_post_elements)[i] = posts[i - *_post_elements_num];
+			(*_post_elements)[i] = NULL;
+			(*_post_elements_num) += num;
+			free(posts);
+		} else {
+			*_post_elements     = posts;
+			*_post_elements_num = num;
+		}	
+#if 1
+		/* dump list of all loaded plugins */
+		int ptot = *_post_elements_num;
+		int i;
+		char s[4096]="";
+		for(i=0; i<ptot; i++)
+		if((*_post_elements)[i])
+			if(((*_post_elements)[i])->post) {
+				if(((*_post_elements)[i])->enable)
+					strcat_n(sizeof(s), s, "*");
+				if(((*_post_elements)[i])->name)
+					strcat_n(sizeof(s), s, ((*_post_elements)[i])->name);
+				else
+					strcat_n(sizeof(s), s, "<no name!>");
+				strcat_n(sizeof(s), s, " ");
+			}
+		printf("    loaded plugins (type %d.%d): %s\n", (plugin_type>>16), (plugin_type&0xffff), s);
+#endif
+	}
+}
+
+void vpplugin_parse_and_store_post(fe_t *fe, const char *post_chain)
+{
+	pplugin_parse_and_store_post(fe, XINE_POST_TYPE_VIDEO_FILTER, post_chain);
+	pplugin_parse_and_store_post(fe, XINE_POST_TYPE_VIDEO_COMPOSE, post_chain);
+}
+
+void applugin_parse_and_store_post(fe_t *fe, const char *post_chain)
+{
+	pplugin_parse_and_store_post(fe, XINE_POST_TYPE_AUDIO_FILTER, post_chain);
+	pplugin_parse_and_store_post(fe, XINE_POST_TYPE_AUDIO_VISUALIZATION, post_chain);
+}
+
+static void _vpplugin_unwire(fe_t *fe)
+{
+	xine_post_out_t  *vo_source;
+	vo_source = xine_get_video_source(fe->video_source);
+	(void) xine_post_wire_video_port(vo_source, fe->video_port);
+}
+
+static void _applugin_unwire(fe_t *fe)
+{
+	xine_post_out_t  *ao_source;
+	ao_source = xine_get_audio_source(fe->audio_source);
+	(void) xine_post_wire_audio_port(ao_source, fe->audio_port);
+}
+
+static void _vpplugin_rewire_from_post_elements(fe_t *fe, post_element_t **post_elements, int post_elements_num)
+{
+	if(post_elements_num) {
+		xine_post_out_t   *vo_source;
+		int                i = 0;
+
+		for(i = (post_elements_num - 1); i >= 0; i--) {
+			const char *const *outs = xine_post_list_outputs(post_elements[i]->post);
+			xine_post_out_t *vo_out = xine_post_output(post_elements[i]->post, *outs);
+
+			if(i == (post_elements_num - 1)) {
+				printf("        wiring %10s[out] -> [in]video_out\n", post_elements[i]->name);
+				xine_post_wire_video_port(vo_out, fe->video_port);
+			} else {
+				xine_post_in_t *vo_in;
+
+				/* look for standard input names */
+				vo_in = xine_post_input(post_elements[i + 1]->post, "video");
+				if( !vo_in )
+					vo_in = xine_post_input(post_elements[i + 1]->post, "video in");
+
+				printf("        wiring %10s[out] -> [in]%-10s \n", post_elements[i]->name, post_elements[i+1]->name);
+				xine_post_wire(vo_out, vo_in);
+			}
+		}
+
+		if(fe->post_pip_enable && !strcmp(post_elements[0]->name, "mosaico") && fe->pip_stream) {
+			vo_source = xine_get_video_source(fe->pip_stream);
+			printf("        wiring %10s[out] -> [in1]%-10s ", "pip stream\n", post_elements[0]->name);
+			xine_post_wire_video_port(vo_source, post_elements[0]->post->video_input[1]);
+		}
+
+		vo_source = xine_get_video_source(fe->video_source);
+		printf("        wiring %10s[out] -> [in]%-10s", "stream\n", post_elements[0]->name);
+		xine_post_wire_video_port(vo_source, post_elements[0]->post->video_input[0]);
+	}
+}
+
+static void _applugin_rewire_from_post_elements(fe_t *fe, post_element_t **post_elements, int post_elements_num)
+{
+	if(post_elements_num) {
+		xine_post_out_t   *ao_source;
+		int                i = 0;
+
+		for(i = (post_elements_num - 1); i >= 0; i--) {
+			const char *const *outs = xine_post_list_outputs(post_elements[i]->post);
+			xine_post_out_t *ao_out = xine_post_output(post_elements[i]->post, *outs);
+
+			if(i == (post_elements_num - 1)) {
+				printf("        wiring %10s[out] -> [in]audio_out\n", post_elements[i]->name);
+				xine_post_wire_audio_port(ao_out, fe->audio_port);
+			} else {
+				xine_post_in_t *ao_in;
+
+				/* look for standard input names */
+				ao_in = xine_post_input(post_elements[i + 1]->post, "audio");
+				if( !ao_in )
+					ao_in = xine_post_input(post_elements[i + 1]->post, "audio in");
+				printf("        wiring %10s[out] -> [in]%-10s \n", post_elements[i]->name, post_elements[i+1]->name);
+				xine_post_wire(ao_out, ao_in);
+			}
+		}
+
+		ao_source = xine_get_audio_source(fe->audio_source);
+		printf("        wiring %10s[out] -> [in]%-10s", "stream", post_elements[0]->name);
+		xine_post_wire_audio_port(ao_source, post_elements[0]->post->audio_input[0]);
+	}
+}
+
+static post_element_t **_pplugin_join_deinterlace_and_post_elements(fe_t *fe, int *post_elements_num)
+{
+	post_element_t **post_elements;
+	int i = 0, j = 0, n = 0, p = 0;
+	static const char *order[] = {"autocrop", "thread", "tvtime", "swscale", NULL};
+	*post_elements_num = 0;
+
+	if( fe->post_video_enable )
+		*post_elements_num += fe->post_video_elements_num;
+
+	if( fe->post_pip_enable )
+		*post_elements_num += fe->post_pip_elements_num;
+
+	if( *post_elements_num == 0 )
+		return NULL;
+
+	post_elements = (post_element_t**) calloc( (*post_elements_num), sizeof(post_element_t *));
+
+	if(fe->post_pip_enable)
+		for( i = 0; i < fe->post_pip_elements_num; i++ ) {
+			if(fe->post_pip_elements[i]->enable)
+				post_elements[i+j-n] = fe->post_pip_elements[i];
+			else
+				n++;
+		}
+
+	if(fe->post_video_enable)
+		for( j = 0; j < fe->post_video_elements_num; j++ ) {
+			if(fe->post_video_elements[j]->enable) {
+				post_elements[i+j-n] = fe->post_video_elements[j];
+			} else
+				n++;
+		}
+
+	*post_elements_num -= n;
+	if( *post_elements_num == 0 ) {
+		free(post_elements);
+		return NULL;
+	}
+
+	/* in some special cases order is important. By default plugin order
+	* in post plugin chain is post plugin loading order.
+	* But, we want:
+	*
+	*   1. autocrop       - less data to process for other plugins
+	*                     - accepts only YV12
+	*   2. deinterlace    - blur etc. makes deinterlacing difficult.
+	*                     - upscales chroma (YV12->YUY2) in some modes.
+	*   3. anything else
+	*
+	* So let's move those two to beginning ...
+	*/
+	n = 0;
+	while(order[p]) {
+		for(i = 0; i<*post_elements_num; i++)
+			if(!strcmp(post_elements[i]->name, order[p])) {
+				if(i != n) {
+					post_element_t *tmp = post_elements[i];
+					for(j=i; j>n; j--)
+						post_elements[j] = post_elements[j-1];
+					post_elements[n] = tmp;
+					printf("      moved %s to post slot %d\n", order[p], n);
+				}
+				n++;
+				break;
+			}
+		p++;
+	}
+
+	return post_elements;
+}
+
+static post_element_t **_pplugin_join_visualization_and_post_elements(fe_t *fe, int *post_elements_num)
+{
+	post_element_t **post_elements;
+	int i = 0, j = 0, n = 0;
+	*post_elements_num = 0;
+
+	if( fe->post_audio_enable )
+		*post_elements_num += fe->post_audio_elements_num;
+
+	if( fe->post_vis_enable )
+		*post_elements_num += fe->post_vis_elements_num;
+
+	if( *post_elements_num == 0 )
+		return NULL;
+
+	post_elements = (post_element_t**) calloc( (*post_elements_num), sizeof(post_element_t *));
+
+	if(fe->post_audio_enable)
+		for( j = 0; j < fe->post_audio_elements_num; j++ ) {
+			if(fe->post_audio_elements[j]->enable)
+				post_elements[i+j-n] = fe->post_audio_elements[j];
+			else
+				n++;
+		}
+
+	if(fe->post_vis_enable)
+		for( i = 0; i < fe->post_vis_elements_num; i++ ) {
+			if(fe->post_vis_elements[i]->enable)
+				post_elements[i+j-n] = fe->post_vis_elements[i];
+			else
+				n++;
+		}
+
+	*post_elements_num -= n;
+
+	if( *post_elements_num == 0 ) {
+		free(post_elements);
+		return NULL;
+	}
+
+	return post_elements;
+}
+
+static void _vpplugin_rewire(fe_t *fe)
+{
+	static post_element_t **post_elements;
+	int post_elements_num;
+	post_elements = _pplugin_join_deinterlace_and_post_elements(fe, &post_elements_num);
+
+	if( post_elements ) {
+		_vpplugin_rewire_from_post_elements(fe, post_elements, post_elements_num);
+		free(post_elements);
+	}
+}
+
+static void _applugin_rewire(fe_t *fe)
+{
+	static post_element_t **post_elements;
+	int post_elements_num;
+	post_elements = _pplugin_join_visualization_and_post_elements(fe, &post_elements_num);
+
+	if( post_elements ) {
+		_applugin_rewire_from_post_elements(fe, post_elements, post_elements_num);
+		free(post_elements);
+	}
+}
+
+void vpplugin_rewire_posts(fe_t *fe)
+{
+	/*TRACELINE;*/
+	_vpplugin_unwire(fe);
+	_vpplugin_rewire(fe);
+}
+
+void applugin_rewire_posts(fe_t *fe)
+{
+	/*TRACELINE;*/
+	_applugin_unwire(fe);
+	_applugin_rewire(fe);
+}
+
+static int _pplugin_enable_post(const char *name, const char *args,
+ post_element_t **post_elements, int post_elements_num, int *found)
+{
+	int i, result = 0;
+
+	for(i=0; i<post_elements_num; i++)
+		if(post_elements[i])
+			if(!strcmp(post_elements[i]->name, name)) {
+				if(post_elements[i]->enable == 0) {
+					post_elements[i]->enable = 1;
+					result = 1;
+				}
+
+				*found = 1;
+
+				if(args && *args) {
+					if(post_elements[i]->enable != 2) {
+						char *tmp = strdup(args);
+						__pplugin_update_parameters(post_elements[i]->post, tmp);
+						free(tmp);
+						if(post_elements[i]->args)
+							free(post_elements[i]->args);
+						post_elements[i]->args = strdup(args);
+					} else {
+					printf("  * enable post %s, parameters fixed in command line.\n", name);
+					printf("      requested: %s\n", args ? : "none");
+					printf("      using    : %s\n", post_elements[i]->args ? : "none");
+					}
+				}
+			}
+	return result;
+}
+
+static int _vpplugin_enable_post(post_plugins_t *fe, const char *name, const char *args, int *found)
+{
+	int result = 0;
+	if(!*found)
+		result = _pplugin_enable_post(name, args, fe->post_video_elements, fe->post_video_elements_num, found);
+	if(!*found)
+		result = _pplugin_enable_post(name, args, fe->post_pip_elements, fe->post_pip_elements_num, found);
+	return result;
+}
+
+static int _applugin_enable_post(post_plugins_t *fe, const char *name, const char *args, int *found)
+{
+	int result = 0;
+	if(!*found)
+		result = _pplugin_enable_post(name, args, fe->post_audio_elements, fe->post_audio_elements_num, found);
+	if(!*found)
+		result = _pplugin_enable_post(name, args, fe->post_vis_elements, fe->post_vis_elements_num, found);
+	return result;
+}
+
+static char * _pp_name_strdup(const char *initstr)
+{
+	char *name = strdup(initstr), *pt;
+
+	if(NULL != (pt = strchr(name, ':')))
+		*pt = 0;
+
+	return name;
+}
+
+static const char * _pp_args(const char *initstr)
+{
+	char *pt = (char*)strchr(initstr, ':');
+	if(pt && *(pt+1))
+		return pt+1;
+	return NULL;
+}
+
+int vpplugin_enable_post(post_plugins_t *fe, const char *initstr, int *found)
+{
+	char *name = _pp_name_strdup(initstr);
+	const char *args = _pp_args(initstr);
+	int result = _vpplugin_enable_post(fe, name, args, found);
+	printf("  * enable post %s --> %s, %s\n", name, *found ? "found"   : "not found", result ? "enabled" : "no action");
+
+	if(!*found) {
+		printf("  * loading post %s\n", initstr);
+		vpplugin_parse_and_store_post(fe, initstr);
+		result = _vpplugin_enable_post(fe, name, NULL, found);
+		printf("  * enable post %s --> %s, %s\n", name, *found ? "found"   : "not found", result ? "enabled" : "no action");
+	}
+
+	if(result)
+		_vpplugin_unwire(fe);
+
+	free(name);
+	return result;
+}
+
+int applugin_enable_post(post_plugins_t *fe, const char *initstr, int *found)
+{
+	const char * args = _pp_args(initstr);
+	char *name = _pp_name_strdup(initstr);
+	int result = _applugin_enable_post(fe, name, args, found);
+	printf("  * enable post %s --> %s, %s\n", name, *found ? "found"   : "not found", result ? "enabled" : "no action");
+
+	if(!*found) {
+		printf("  * loading post %s\n", initstr);
+		applugin_parse_and_store_post(fe, initstr);
+		result = _applugin_enable_post(fe, name, NULL, found);
+		printf("  * enable post %s --> %s, %s\n", name, *found ? "found"   : "not found", result ? "enabled" : "no action");
+	}
+
+	if(result)
+		_applugin_unwire(fe);
+	free(name);
+	return result;
+}
+
+static int _pplugin_disable_post(const char *name, post_element_t **post_elements, int post_elements_num)
+{
+	int i, result = 0;
+	/*TRACELINE;*/
+
+	if(post_elements)
+		for(i = 0; i < post_elements_num; i++)
+			if(post_elements[i])
+				if(!name || !strcmp(post_elements[i]->name, name))
+					if(post_elements[i]->enable == 1) {
+						post_elements[i]->enable = 0;
+						result = 1;
+					}
+	return result;
+}
+
+int vpplugin_disable_post(post_plugins_t *fe, const char *name)
+{
+	/*TRACELINE;*/
+	if(_pplugin_disable_post(name, fe->post_video_elements, fe->post_video_elements_num) || _pplugin_disable_post(name, fe->post_pip_elements, fe->post_pip_elements_num)) {
+		_vpplugin_unwire(fe);
+		return 1;
+	}
+	return 0;
+}
+
+int applugin_disable_post(post_plugins_t *fe, const char *name)
+{
+	/*TRACELINE;*/
+	if(_pplugin_disable_post(name, fe->post_audio_elements, fe->post_audio_elements_num) || _pplugin_disable_post(name, fe->post_vis_elements, fe->post_vis_elements_num)) {
+		_applugin_unwire(fe);
+		return 1;
+	}
+	return 0;
+}
+
+static int _pplugin_unload_post(post_plugins_t *fe, const char *name, post_element_t ***post_elements, int *post_elements_num)
+{
+	/* does not unwrire plugins ! */
+	int i, j, result = 0;
+
+	/*TRACELINE;*/
+	if(!*post_elements || !*post_elements_num)
+		return 0;
+
+	for(i=0; i < *post_elements_num; i++) {
+		if((*post_elements)[i]) {
+			if(!name || !strcmp((*post_elements)[i]->name, name)) {
+				if((*post_elements)[i]->enable == 0 || !name) {
+					xine_post_dispose(fe->xine, (*post_elements)[i]->post);
+					free((*post_elements)[i]->name);
+					if((*post_elements)[i]->args)
+						free((*post_elements)[i]->args);
+					free((*post_elements)[i]);
+
+					for(j=i; j < *post_elements_num - 1; j++)
+						(*post_elements)[j] = (*post_elements)[j+1];
+					(*post_elements_num) --;
+					(*post_elements)[(*post_elements_num)] = 0;
+					result = 1;
+					i--;
+				} else {
+					printf("Unload %s failed: plugin enabled and in use\n",
+					(*post_elements)[i]->name);
+				}
+			}
+		}
+	}
+
+	if(*post_elements_num <= 0) {
+		if(*post_elements)
+			free(*post_elements);
+		*post_elements = NULL;
+	}
+	return result;
+}
+
+int vpplugin_unload_post(post_plugins_t *fe, const char *name)
+{
+	int result = vpplugin_disable_post(fe, name);
+
+	/* unload already disabled plugins too (result=0) */
+	_pplugin_unload_post(fe, name, &fe->post_video_elements, &fe->post_video_elements_num);
+	_pplugin_unload_post(fe, name, &fe->post_pip_elements, &fe->post_pip_elements_num);
+
+	/* result indicates only unwiring condition, not unload result */
+	return result;
+}
+
+int applugin_unload_post(post_plugins_t *fe, const char *name)
+{
+	int result = applugin_disable_post(fe, name);
+
+	/* unload already disabled plugins too (result=0) */
+	_pplugin_unload_post(fe, name, &fe->post_audio_elements, &fe->post_audio_elements_num);
+	_pplugin_unload_post(fe, name, &fe->post_vis_elements, &fe->post_vis_elements_num);
+
+	/* result indicates only unwiring condition, not unload result */
+	return result;
+}
+
diff -ruN o/lib/gdi/post.h pc/lib/gdi/post.h
--- o/lib/gdi/post.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/gdi/post.h	2025-07-11 16:39:46.962636567 +0300
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2003 by Dirk Meyer
+ *
+ * This file is part of xine, a unix video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * Modified for xineliboutput by Petri Hintukainen, 2006
+ *
+ */
+
+#ifndef POST_HH
+#define POST_HH
+
+#include <xine.h>
+
+typedef struct {
+  xine_post_t    *post;
+  char           *name;
+  char           *args;
+  int            enable; /* 0 - disabled, 1 - enabled, 2 - can't disable */
+} post_element_t;
+
+
+typedef struct post_plugins_s post_plugins_t;
+
+struct post_plugins_s {
+
+  /* frontend data */
+  char *static_post_plugins;   /* post plugins from command line; always on */
+  xine_stream_t *video_source; /* stream to take video from */
+  xine_stream_t *audio_source; /* stream to take audio from */
+  xine_stream_t *pip_stream;   /* pip stream */
+
+  /* xine */
+  xine_t            *xine;
+  xine_video_port_t *video_port;
+  xine_audio_port_t *audio_port;
+
+  /* post.c internal use */
+  int post_audio_elements_num;
+  int post_video_elements_num;
+  int post_vis_elements_num;
+  int post_pip_elements_num;
+
+  post_element_t **post_audio_elements;
+  post_element_t **post_video_elements;
+  post_element_t **post_vis_elements;   /* supports only one */
+  post_element_t **post_pip_elements;   /* supports only one and two input */
+
+  int post_audio_enable;
+  int post_video_enable;
+  int post_vis_enable;
+  int post_pip_enable;
+};
+
+
+void vpplugin_rewire_posts(post_plugins_t *fe);
+void applugin_rewire_posts(post_plugins_t *fe);
+
+/* load and config post plugin(s) */
+/* post == "plugin:arg1=val1,arg2=val2;plugin2..." */
+void vpplugin_parse_and_store_post(post_plugins_t *fe, const char *post);
+void applugin_parse_and_store_post(post_plugins_t *fe, const char *post);
+
+/* enable (and load if not loaded), but don't rewire */
+/* result indicates only unwiring condition, not enable result */
+/* -> if result <> 0, something was enabled and post chain is unwired */
+int  vpplugin_enable_post(post_plugins_t *fe, const char *name, int *found);
+int  applugin_enable_post(post_plugins_t *fe, const char *name, int *found);
+
+/* disable (and unwire if found), but don't unload */
+/* result indicates only unwiring condition, not disable result */
+int  vpplugin_disable_post(post_plugins_t *fe, const char *name);
+int  applugin_disable_post(post_plugins_t *fe, const char *name);
+
+/* unload (and unwire) plugin(s) */
+/* result indicates only unwiring condition, not unload result */
+int  vpplugin_unload_post(post_plugins_t *fe, const char *name);
+int  applugin_unload_post(post_plugins_t *fe, const char *name);
+
+#endif
+
+/* end of post.h */
diff -ruN o/lib/gdi/xineLib.cpp pc/lib/gdi/xineLib.cpp
--- o/lib/gdi/xineLib.cpp	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/gdi/xineLib.cpp	2025-07-11 16:39:46.963636513 +0300
@@ -0,0 +1,971 @@
+#include <fstream>
+#include <lib/gdi/xineLib.h>
+#include <lib/base/eenv.h>
+#include <sstream>
+#include <string>
+
+static const std::string getConfigString(const std::string &key, const std::string &defaultValue)
+{
+	std::string value = defaultValue;
+
+	/* get value from enigma2 settings file */
+	std::ifstream in(eEnv::resolve("${sysconfdir}/enigma2/settings").c_str());
+	if (in.good()) {
+		do {
+			std::string line;
+			std::getline(in, line);
+			size_t size = key.size();
+			if (!line.compare(0, size, key) && line[size] == '=') {
+				value = line.substr(size + 1);
+				break;
+			}
+		} while (in.good());
+		in.close();
+	}
+
+	return value;
+}
+
+static int getConfigInt(const std::string &key)
+{
+	std::string value = getConfigString(key, "0");
+		return atoi(value.c_str());
+}
+
+static void config_change_sound(xine_t *xine, int m_sound_card, int m_sound_device, int m_sound_output)
+{
+	std::ostringstream a_line;
+	a_line << "hw:" << m_sound_card << "," << m_sound_device;
+	std::string         s = a_line.str();
+	const char  *hw_audio = s.c_str();
+
+	printf("[cXineLib] Sound card:device - %s\n", hw_audio);
+
+	xine_config_register_string(xine,
+	"audio.device.alsa_default_device",
+	"default",
+	_("device used for mono output"),
+	_("xine will use this alsa device "
+	"to output mono sound.\n"
+	"See the alsa documentation "
+	"for information on alsa devices."),
+	10, NULL, NULL);
+
+	xine_config_register_string(xine,
+	"audio.device.alsa_front_device",
+	"plug:front:default",
+	_("device used for stereo output"),
+	_("xine will use this alsa device "
+	"to output stereo sound.\n"
+	"See the alsa documentation "
+	"for information on alsa devices."),
+	10, NULL, NULL);
+
+	xine_config_register_string(xine,
+	"audio.device.alsa_surround51_device",
+	"plug:surround51:0",
+	_("device used for 5.1-channel output"),
+	_("xine will use this alsa device to output "
+	"5 channel plus LFE (5.1) surround sound.\n"
+	"See the alsa documentation for information "
+	"on alsa devices."),
+	10,  NULL, NULL);
+
+	xine_config_register_string(xine,
+	"audio.device.alsa_passthrough_device",
+	"iec958:AES0=0x6,AES1=0x82,AES2=0x0,AES3=0x2",
+	_("device used for 5.1-channel output"),
+	_("xine will use this alsa device to output "
+	"undecoded digital surround sound. This can "
+	"be used be external surround decoders.\nSee the "
+	"alsa documentation for information on alsa "
+	"devices."),
+	10, NULL, NULL);
+
+	xine_config_register_string(xine,"audio.output.speaker_arrangement",
+	"Stereo 2.0",
+	_("speaker arrangement"),
+	_("Select how your speakers are arranged, "
+	"this determines which speakers xine uses for sound output. "
+	"The individual values are:\n\n"
+	"Mono 1.0: You have only one speaker.\n"
+	"Stereo 2.0: You have two speakers for left and right channel.\n"
+	"Headphones 2.0: You use headphones.\n"
+	"Stereo 2.1: You have two speakers for left and right channel, and one "
+	"subwoofer for the low frequencies.\n"
+	"Surround 3.0: You have three speakers for left, right and rear channel.\n"
+	"Surround 4.0: You have four speakers for front left and right and rear "
+	"left and right channels.\n"
+	"Surround 4.1: You have four speakers for front left and right and rear "
+	"left and right channels, and one subwoofer for the low frequencies.\n"
+	"Surround 5.0: You have five speakers for front left, center and right and "
+	"rear left and right channels.\n"
+	"Surround 5.1: You have five speakers for front left, center and right and "
+	"rear left and right channels, and one subwoofer for the low frequencies.\n"
+	"Surround 6.0: You have six speakers for front left, center and right and "
+	"rear left, center and right channels.\n"
+	"Surround 6.1: You have six speakers for front left, center and right and "
+	"rear left, center and right channels, and one subwoofer for the low frequencies.\n"
+	"Surround 7.1: You have seven speakers for front left, center and right, "
+	"left and right and rear left and right channels, and one subwoofer for the "
+	"low frequencies.\n"
+	"Pass Through: Your sound system will receive undecoded digital sound from xine. "
+	"You need to connect a digital surround decoder capable of decoding the "
+	"formats you want to play to your sound card's digital output."),
+	10, NULL, NULL);
+
+	xine->config->update_string(xine->config, "audio.device.alsa_default_device", hw_audio);
+	xine->config->update_string(xine->config, "audio.device.alsa_front_device", hw_audio);
+	xine->config->update_string(xine->config, "audio.device.alsa_passthrough_device", hw_audio);
+	xine->config->update_string(xine->config, "audio.device.alsa_surround51_device", hw_audio);
+
+	if (m_sound_output == 1)
+		xine->config->update_string(xine->config, "audio.output.speaker_arrangement", "Stereo 2.0");
+	else if (m_sound_output == 8)
+		xine->config->update_string(xine->config, "audio.output.speaker_arrangement", "Surround 5.1");
+	else if (m_sound_output == 11)
+		xine->config->update_string(xine->config, "audio.output.speaker_arrangement", "Surround 7.1");
+	else if (m_sound_output == 12)
+		xine->config->update_string(xine->config, "audio.output.speaker_arrangement", "Pass Through");
+}
+
+/* list available plugins */
+static void list_plugins_type(xine_t *xine, const char *msg, __typeof__ (xine_list_audio_output_plugins) list_func) {
+	static xine_t *tmp_xine = NULL;
+	if(!xine) {
+		if(!tmp_xine)
+			xine_init(tmp_xine = xine_new());
+		xine = tmp_xine;
+	}
+	const char *const *list = list_func(xine);
+
+	printf("%s", msg);
+	while(list && *list)
+		printf(" %s", *list++);
+	printf("\n");
+}
+
+cXineLib *cXineLib::instance;
+
+DEFINE_REF(cXineLib);
+
+cXineLib::cXineLib(x11_visual_t *vis) : m_pump(eApp, 1) {
+	char configfile[300];
+	char *vo_driver;
+	char *ao_driver;
+	const char  *static_post_plugins = "enigma_video; enigma_audio; upmix_mono";
+
+	instance = this;
+	osd = NULL;
+	stream = NULL;
+	end_of_stream = false;
+	videoPlayed = false;
+	doDescramble = false;
+	post_plugins_t *posts = NULL;
+
+	printf("XINE-LIB version: %s\n", xine_get_version_string());
+
+	xine = xine_new();
+	strcpy(configfile, eEnv::resolve("${datadir}/enigma2/xine.conf").c_str());
+	printf("XINE-LIB configfile: %s\n", configfile);
+	xine_config_load(xine, configfile);
+	sound_mode = sound_card = sound_device = 0;
+	sound_output = 1;
+	sound_mode = getConfigInt("config.av.sound_mode");
+	if (sound_mode > 0)
+	{
+		sound_card = getConfigInt("config.av.sound_card");
+		sound_device = getConfigInt("config.av.sound_device");
+		sound_output = getConfigInt("config.av.sound_output");
+		config_change_sound(xine, sound_card, sound_device, sound_output);
+	}
+	xine_init(xine);
+	xine_engine_set_param(xine, XINE_ENGINE_PARAM_VERBOSITY, XINE_VERBOSITY_LOG);
+	list_plugins_type(xine, "Available post plugins: ", xine_list_post_plugins); 
+
+	cfg_entry_t *entry;
+	config_values_t *cfg;
+	/* read Video Driver from config */
+	cfg = this->xine->config;
+	entry = cfg->lookup_entry(cfg, "video.driver");
+	vo_driver = strdup(entry->unknown_value);
+	/* read Audio Driver from config */
+	entry = cfg->lookup_entry(cfg, "audio.driver");
+	ao_driver = strdup(entry->unknown_value);
+	printf("[cXineLib] Use vo_driver: %s \n", vo_driver);
+	printf("[cXineLib] Use ao_driver: %s \n", ao_driver);
+
+	if((vo_port = xine_open_video_driver(xine, vo_driver , XINE_VISUAL_TYPE_X11, (void *) vis)) == NULL)
+	{
+		printf("[cXineLib] I'm unable to initialize '%s' video driver. Giving up.\n", vo_driver);
+		return;
+	}
+
+	ao_port = xine_open_audio_driver(xine , ao_driver, NULL);
+	stream = xine_stream_new(xine, ao_port, vo_port);
+
+	if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/logo.mvi").c_str())) || (!xine_play(stream, 0, 0))) {
+		return;
+	}
+
+	event_queue = xine_event_new_queue (stream);
+	xine_event_create_listener_thread(event_queue, xine_event_handler, this);
+
+	posts = this->postplugins = (post_plugins_t*)calloc(1, sizeof(post_plugins_t));
+	posts->xine = this->xine;
+	posts->audio_port = this->ao_port;
+	posts->video_port = this->vo_port;
+	posts->video_source = posts->audio_source = this->stream;
+
+/*#if 0
+	LOGMSG("Enabling multithreaded post processing");
+	vpplugin_parse_and_store_post(posts, "thread");
+#endif*/
+
+	if(static_post_plugins && *static_post_plugins) {
+		int i;
+		printf("[cXineLib] Static post plugins (from command line): %s\n", static_post_plugins);
+		posts->static_post_plugins = strdup(static_post_plugins);
+		vpplugin_parse_and_store_post(posts, posts->static_post_plugins);
+		applugin_parse_and_store_post(posts, posts->static_post_plugins);
+
+		for(i=0; i<posts->post_audio_elements_num; i++)
+			if(posts->post_audio_elements[i])
+				posts->post_audio_elements[i]->enable = 2;
+
+		for(i=0; i<posts->post_video_elements_num; i++)
+			if(posts->post_video_elements[i])
+				posts->post_video_elements[i]->enable = 2;
+		posts->post_video_enable = 1;
+		posts->post_audio_enable = 1;
+		rewire_posts_load();
+	}
+
+	CONNECT(m_pump.recv_msg, cXineLib::pumpEvent);
+
+	m_width = 0;
+	m_height = 0;
+	m_framerate = 0;
+	m_aspect = -1;
+	m_windowAspectRatio = 0;
+	m_policy43 = 0;
+	m_policy169 = 0;
+	m_progressive = -1;
+
+	m_sharpness = 0;
+	m_noise = 0;
+
+	m_streamtype = -1;
+
+	m_hevc = getConfigInt("config.pc.prebuffer_metronom_hevc");
+	m_avc = getConfigInt("config.pc.prebuffer_metronom_avc");
+	m_mpeg2 = getConfigInt("config.pc.prebuffer_metronom_mpeg2");
+
+	/* DEFAULT */
+	if (m_hevc == 0)
+		m_hevc = 216000;
+	if (m_avc == 0)
+		m_avc = 162000;
+	if (m_mpeg2 == 0)
+		m_mpeg2 = 126000;
+}
+
+cXineLib::~cXineLib() {
+	instance = 0;
+//	stream = 0;
+
+/*	if (m_state == stRunning)
+		stop();
+
+	if (stream) {
+		eDebug("[cXineLib] Close stream");
+		xine_close(stream);
+		eDebug("[cXineLib] Dispose stream");
+		xine_dispose(stream);
+		eDebug("[cXineLib] Demux flush");
+		_x_demux_flush_engine(this->stream);
+	}*/
+
+	if (stream)
+	{
+		xine_stop(stream);
+
+                if (this->postplugins) {
+			rewire_posts_unload();
+		}
+
+		xine_close(stream);
+
+		if (event_queue)
+		{
+			xine_event_dispose_queue(event_queue);
+			event_queue = 0;
+		}
+
+		_x_demux_flush_engine(stream);
+
+		xine_dispose(stream);
+		stream = NULL;
+	}
+
+
+	if (this->postplugins)
+		rewire_posts_unload();
+
+	printf("[cXineLib] Dispose queue\n");
+	if (event_queue)
+		xine_event_dispose_queue(event_queue);
+
+	printf("[cXineLib] Dispose ao_port\n");
+	if (ao_port)
+		xine_close_audio_driver(xine, ao_port);
+
+	printf("[cXineLib] Dispose vo port\n");
+	if (vo_port)
+		xine_close_video_driver(xine, vo_port);
+
+	printf("[cXineLib] Done\n");
+}
+
+void cXineLib::rewire_posts_load() {
+	printf("[cXineLib] Enable re-wiring post plugins\n");
+	if (this->postplugins) {
+		vpplugin_rewire_posts(this->postplugins);
+		applugin_rewire_posts(this->postplugins);
+	}
+}
+
+void cXineLib::rewire_posts_unload() {
+	if (this->postplugins) {
+		printf("[cXineLib] Unloading post plugins\n");
+		vpplugin_unload_post(this->postplugins, NULL);
+		applugin_unload_post(this->postplugins, NULL);
+	}
+}
+
+void cXineLib::setVolume(int value) {
+//	xine_set_param (stream, XINE_PARAM_AUDIO_VOLUME, value);
+	xine_set_param (stream, XINE_PARAM_AUDIO_AMP_LEVEL, value);
+}
+
+void cXineLib::setVolumeMute(int value) {
+//	xine_set_param (stream, XINE_PARAM_AUDIO_MUTE, value==0?0:1);
+	xine_set_param(stream, XINE_PARAM_AUDIO_AMP_MUTE, value==0?0:1);
+}
+
+void cXineLib::showOsd() {
+	xine_osd_show_scaled(osd, 0);
+	//stream->osd_renderer->draw_bitmap(osd, (uint8_t*)m_surface.data, 0, 0, 720, 576, temp_bitmap_mapping);
+}
+
+void cXineLib::newOsd(int width, int height, uint32_t *argb_buffer) {
+	osdWidth  = width;
+	osdHeight = height;
+
+	if (osd)
+		xine_osd_free(osd);
+
+	osd = xine_osd_new(stream, 0, 0, osdWidth, osdHeight);
+	xine_osd_set_extent(osd, osdWidth, osdHeight);
+	xine_osd_set_argb_buffer(osd, argb_buffer, 0, 0, osdWidth, osdHeight);
+}
+
+void cXineLib::setScrambled(bool doDescrambleChannel) {
+	printf("[cXineLib] doDescrambled channel: %s\n", doDescrambleChannel ? "true" : "false");
+	doDescramble = doDescrambleChannel;
+}
+
+void cXineLib::playVideo(void) {
+	if (doDescramble) {
+		return;
+	}
+
+/*	if ( videoPlayed == true ) {
+		xine_stop(stream);
+	}*/
+
+	end_of_stream = false;
+	videoPlayed = false;
+
+	if (m_streamtype == 6) {
+		printf("[cXineLib] Switch to HEVC-1 TV mode\n");
+		setPrebuffer(m_hevc);
+		if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/black.mvi").c_str())) || (!xine_play(stream, 0, 0)))
+			return;
+	}
+
+	else if (m_streamtype == 5) {
+		printf("[cXineLib] Switch to HEVC-2 TV mode\n");
+		setPrebuffer(m_hevc);
+		if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/black.mvi").c_str())) || (!xine_play(stream, 0, 0)))
+			return;
+	}
+
+	else if (m_streamtype == 4) {
+		printf("[cXineLib] Switch to MPEG4 H264 TV mode\n");
+		setPrebuffer(m_avc);
+		if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/black.mvi").c_str())) || (!xine_play(stream, 0, 0)))
+			return;
+	}
+
+	else if (m_streamtype == 3) {
+		printf("[cXineLib] Switch to MPEG4-P2/AVC TV mode\n");
+		setPrebuffer(m_avc);
+		if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/black.mvi").c_str())) || (!xine_play(stream, 0, 0)))
+			return;
+	}
+
+	else if (m_streamtype == 2) {
+		printf("[cXineLib] Switch to MPEG2 TV mode\n");
+		setPrebuffer(m_mpeg2);
+		if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/black.mvi").c_str())) || (!xine_play(stream, 0, 0)))
+			return;
+	}
+
+	else if (m_streamtype == 1) {
+		printf("[cXineLib] Switch to RADIO mode\n");
+		setPrebuffer(m_mpeg2);
+		if ((!xine_open(stream, eEnv::resolve("${datarootdir}/enigma2/radio.mvi").c_str())) || (!xine_play(stream, 0, 0))) {
+			return;
+		}
+	}
+
+	printf("**************** [cXineLib] XINE TRY TO START\n");
+	if (!xine_open(stream, "enigma:/")) {
+		printf("**************** [cXineLib] UNABLE TO OPEN STREAM\n");
+	}
+
+	xine_pids_data_t data;
+	xine_event_t event;
+	event.type = XINE_EVENT_PIDS_CHANGE;
+	data.vpid = videoData.pid;
+	data.apid = audioData.pid;
+	event.data = &data;
+	event.data_length = sizeof (xine_pids_data_t);
+
+	printf ("Input_dvb: sending event\n");
+
+	xine_event_send (stream, &event);
+
+	xine_set_param(this->stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, -1);
+	
+	/* From ChannelSelection.py */
+	setStreamType(0); /* video */
+	setStreamType(1); /* audio */
+
+	if(!xine_play(stream, 0, 0)) {
+		printf("**************** [cXineLib] UNABLE TO PLAY STREAM\n");
+	}
+	else {
+		printf("**************** [cXineLib] XINE STARTED. STILL FIRST, CONTROL, SEEK FRAME\n");
+		videoPlayed = true;
+	}
+}
+
+/* Stop play video files only */
+void cXineLib::stopVideo(void) {
+	printf("[cXineLib] Xine: stop\n");
+	if (videoPlayed) {
+		xine_stop(stream);
+		end_of_stream = true;
+		videoPlayed = false;
+	}
+}
+
+void cXineLib::setStreamType(int video) {
+	xine_event_t event;
+
+	if (video == 1) {
+		event.type = XINE_EVENT_SET_VIDEO_STREAMTYPE;
+		event.data = &videoData;
+	} else {
+		event.type = XINE_EVENT_SET_AUDIO_STREAMTYPE;
+		event.data = &audioData;
+	}
+
+	event.data_length = sizeof (xine_streamtype_data_t);
+
+	xine_event_send (stream, &event);
+}
+
+void cXineLib::setVideoType(int pid, int type) {
+	videoData.pid = pid;
+	videoData.streamtype = type;
+
+	/* 0x24 (HEX) = 36 (DEC) */
+	if (type == 36) {
+		setLiveTV(6);
+	}
+
+	/* 0x27 (HEX) = 39 (DEC) Not used */
+	else if (type == 39) {
+		setLiveTV(5);
+	}
+
+	/* 0x10 (HEX) = 16 (DEC) Not used */
+	else if (type == 16) {
+		setLiveTV(4);
+	}
+
+	/* 0x1B (HEX) = 27 (DEC) */
+	else if (type == 27) {
+		setLiveTV(3);
+	}
+
+	else {
+		setLiveTV(2);
+	}
+}
+
+void cXineLib::FilmVideo(char *mrl) {
+	ASSERT(stream);
+
+	if (!xine_open(stream, mrl)) {
+		printf("[cXineLib] XINE_OPEN FAILED\n");
+		return ;
+	}
+
+/* SET_PVR_MODE, call event set 'demux_ts' to read PAT, PMT files *.ts, *.m2ts */
+	int data;
+	xine_event_t event;
+	event.type = XINE_EVENT_SET_PVR_MODE;
+	data = 1;
+	event.data = &data;
+	event.data_length = sizeof (int);
+	xine_event_send (stream, &event);
+
+	if (!xine_play(stream, 0, 0)) {
+		printf("[cXineLib] XINE_PLAY FAILED\n");
+		return ;
+	}
+
+/*	if (event_queue==0)
+	{
+		event_queue = xine_event_new_queue (stream);
+		xine_event_create_listener_thread(event_queue, xine_event_handler, this);
+	}*/
+
+	xine_set_param(this->stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, 0);
+	videoPlayed = true;
+}
+
+int cXineLib::VideoPause() {
+/*	_x_set_speed (stream, XINE_SPEED_PAUSE);
+	stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0);*/
+	xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
+	return 1;
+}
+
+int cXineLib::VideoResume() {
+	xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
+/*	_x_set_speed (stream, XINE_SPEED_NORMAL);
+	stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);*/
+	return 1;
+}
+
+int cXineLib::VideoRewT(pts_t Rew) {
+	/* 10 seconds rewind */
+	pts_t reWind;
+	xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
+	VideoPosition();
+	reWind=Vpos+Rew;
+	printf("[cXineLib] %lld---Vpos=%d---Rew=%lld", reWind, Vpos, Rew);
+	if (reWind < 0) reWind = 0;
+		xine_play(stream, 0, reWind);
+	xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
+	return 1;
+}
+
+int cXineLib::VideoPlayF() {
+	int ret;
+	/* Slow playback */
+	ret = xine_get_param(stream, XINE_PARAM_SPEED);
+	if( ret != XINE_EVENT_INPUT_RIGHT) {
+		xine_set_param(stream, XINE_PARAM_SPEED, XINE_EVENT_INPUT_RIGHT);
+	}
+	return 1;
+}
+
+int cXineLib::VideoPosition() {
+	xine_get_pos_length (stream, &VposStream, &Vpos, &Vlength);
+	return 1;
+}
+
+/*XINE_SPEED_SLOW_4
+XINE_SPEED_SLOW_2
+XINE_SPEED_NORMAL
+XINE_SPEED_FAST_2
+XINE_SPEED_FAST_4
+XINE_FINE_SPEED_NORMAL*/
+
+void cXineLib::SeekTo(long long value) {
+	xine_play(stream, 0, value);
+}
+
+void cXineLib::setAudioType(int pid, int type) {
+	audioData.pid = pid;
+	audioData.streamtype = type;
+
+	if (videoPlayed)
+		setStreamType(0);
+	else
+		setLiveTV(1); /* mpeg2 radio mode */
+}
+
+int cXineLib::getNumberOfTracksAudio() {
+	int ret = xine_get_stream_info(this->stream, XINE_STREAM_INFO_MAX_AUDIO_CHANNEL);
+	return ret;
+}
+
+void cXineLib::selectAudioStream(int value) {
+	xine_set_param(this->stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, value);
+}
+
+int cXineLib::getCurrentTrackAudio() {
+	if (getNumberOfTracksAudio()) {
+		int ret=xine_get_param(this->stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL);
+		return ret;
+	}
+	return 0;
+}
+
+std::string cXineLib::getAudioLang(int value) {
+	char lang_buffer[XINE_LANG_MAX];
+	char *lang = NULL;
+
+	if (!xine_get_audio_lang(this->stream, value, &lang_buffer[0])) {
+		snprintf(lang_buffer, sizeof(lang_buffer), "%3d", value);
+	}
+	lang = lang_buffer;
+
+	return lang;
+}
+
+void cXineLib::setLiveTV(int streamtype) {
+	m_streamtype = streamtype;
+}
+
+void cXineLib::setPrebuffer(int prebuffer) {
+	xine_set_param(stream, XINE_PARAM_METRONOM_PREBUFFER, prebuffer);
+}
+
+void cXineLib::setBufMetronom(int hevc, int avc, int mpeg2) {
+	m_hevc = hevc;
+	m_avc = avc;
+	m_mpeg2 = mpeg2;
+}
+
+void cXineLib::xine_event_handler(void *user_data, const xine_event_t *event) {
+	cXineLib *xineLib = (cXineLib*)user_data;
+	if (event->type!=15)
+		printf("[cXineLib] I have XINE event ---  %d\n", event->type);
+
+	switch (event->type)
+	{
+	case XINE_EVENT_UI_PLAYBACK_FINISHED:
+		printf("[cXineLib] XINE_EVENT_UI_PLAYBACK_FINISHED\n");
+		break;
+	case XINE_EVENT_NBC_STATS:
+		return;
+	case XINE_EVENT_FRAME_FORMAT_CHANGE:
+		printf("[cXineLib] XINE_EVENT_FRAME_FORMAT_CHANGE\n");
+		{
+			xine_format_change_data_t* data = (xine_format_change_data_t*)event->data;
+			printf("[cXineLib] width %d  height %d  aspect %d\n", data->width, data->height, data->aspect);
+
+			struct iTSMPEGDecoder::videoEvent evt;
+			evt.type = iTSMPEGDecoder::videoEvent::eventSizeChanged;
+			xineLib->m_aspect = evt.aspect = data->aspect;
+			xineLib->m_height = evt.height = data->height;
+			xineLib->m_width  = evt.width  = data->width;
+			xineLib->m_pump.send(evt);
+
+			xineLib->adjust_policy();
+		}
+		return;
+	case XINE_EVENT_FRAMERATE_CHANGE:
+		printf("[cXineLib] XINE_EVENT_FRAMERATE_CHANGE\n");
+		{
+			xine_framerate_data_t* data = (xine_framerate_data_t*)event->data;
+			printf("[cXineLib] framerate %ld \n", data->framerate);
+
+			struct iTSMPEGDecoder::videoEvent evt;
+			evt.type = iTSMPEGDecoder::videoEvent::eventFrameRateChanged;
+			xineLib->m_framerate = evt.framerate = data->framerate;
+			xineLib->m_pump.send(evt);
+		}
+		return;
+	case XINE_EVENT_PROGRESS:
+		{
+			xine_progress_data_t* data = (xine_progress_data_t*) event->data;
+			printf("[cXineLib] XINE_EVENT_PROGRESS  %s  %d\n", data->description, data->percent);
+			if (xineLib->videoPlayed && data->percent==0)
+				xineLib->end_of_stream = true;
+		}
+		break;
+
+	default:
+		printf("[cXineLib] xine_event_handler(): event->type: %d\n", event->type);
+		return;
+	}
+}
+
+void cXineLib::pumpEvent(const iTSMPEGDecoder::videoEvent &event) {
+	m_event(event);
+}
+
+int cXineLib::getVideoWidth() {
+	return m_width;
+}
+
+int cXineLib::getVideoHeight() {
+	return m_height;
+}
+
+int cXineLib::getVideoFrameRate() {
+	if (stream) {
+		int d;
+		d = xine_get_stream_info(this->stream, XINE_STREAM_INFO_FRAME_DURATION);
+		if (d != 0) {
+			m_framerate = int(90000000/d) ;
+		}
+		printf("[cXineLib] FRAMERATE: %d\n", m_framerate);
+	}
+	return m_framerate;
+}
+
+int cXineLib::getProgressive() {
+	if (stream) {
+		xine_current_frame_data_t  data;
+		memset(&data, 0, sizeof (data));
+		if (xine_get_current_frame_data(this->stream, &data, XINE_FRAME_DATA_ALLOCATE_IMG)) {
+			if (data.interlaced == 1)
+				m_progressive = 0;
+			else
+				m_progressive = 1;
+		}
+		printf("[cXineLib] PROGRESSIVE: %d\n", m_progressive);
+	}
+	return m_progressive;
+}
+
+int cXineLib::getVideoAspect() {
+	return m_aspect;
+}
+
+RESULT cXineLib::getPTS(pts_t &pts) {
+//	pts_t* last_pts_l = (pts_t*)(intptr_t)vo_port->get_property(vo_port, VO_PROP_LAST_PTS);
+	pts_t* last_pts_l = (pts_t*)vo_port->get_property(vo_port, VO_PROP_LAST_PTS);
+
+	pts = *last_pts_l;
+	if (pts != 0)
+		return 0;
+	return -1;
+
+/*	if (last_pts_l != 0) // gag!
+		return 0;
+	return -1;*/
+}
+
+void cXineLib::setVideoWindow(int window_x, int window_y, int window_width, int window_height) {
+	int left = window_x * windowWidth / osdWidth;
+	int top = window_y * windowHeight / osdHeight;
+	int width = window_width * windowWidth / osdWidth;
+	int height = window_height * windowHeight / osdHeight;
+
+	xine_osd_set_video_window(osd, left, top, width, height);
+	showOsd();
+}
+
+void cXineLib::updateWindowSize(int width, int height) {
+	windowWidth  = width;
+	windowHeight = height;
+}
+
+void cXineLib::setDeinterlace(int global, int sd, int hd) {
+	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_SD, sd);
+	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_HD, hd);
+	vo_port->set_property(vo_port, VO_PROP_INTERLACED, global);
+}
+
+void cXineLib::setSDfeatures(int sharpness, int noise) {
+	m_sharpness = sharpness;
+	m_noise = noise;
+}
+
+void cXineLib::setAspectRatio(int ratio) {
+	m_windowAspectRatio = ratio;
+}
+
+void cXineLib::setPolicy43(int mode) {
+	m_policy43 = mode;
+}
+
+void cXineLib::setPolicy169(int mode) {
+	m_policy169 = mode;
+}
+
+void cXineLib::setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y) {
+	m_zoom43_x = zoom43_x;
+	m_zoom43_y = zoom43_y;
+	m_zoom169_x = zoom169_x;
+	m_zoom169_y = zoom169_y;
+}
+
+void cXineLib::set_zoom_settings(int x, int y) {
+	xine_set_param(stream, XINE_PARAM_VO_ZOOM_X, x);
+	xine_set_param(stream, XINE_PARAM_VO_ZOOM_Y, y);
+}
+
+void cXineLib::set_crop_settings(int left, int right, int top, int bottom) {
+	xine_set_param(stream, XINE_PARAM_VO_CROP_LEFT, left);
+	xine_set_param(stream, XINE_PARAM_VO_CROP_RIGHT, right);
+	xine_set_param(stream, XINE_PARAM_VO_CROP_TOP, top);
+	xine_set_param(stream, XINE_PARAM_VO_CROP_BOTTOM, bottom);
+}
+
+void cXineLib::adjust_policy() {
+	switch (m_windowAspectRatio) {
+	case XINE_VO_ASPECT_AUTO:
+		printf("[cXineLib] XINE_VO_ASPECT_AUTO\n");
+		xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, 0);
+		set_zoom_settings(100, 100);
+		set_crop_settings(0, 0, 0, 0);
+		break;
+	case XINE_VO_ASPECT_4_3:
+		printf("[cXineLib] XINE_VO_ASPECT_4_3\n");
+		switch (m_aspect) {
+		case 2: /* 4:3 */
+			printf("[cXineLib] m_policy43 %d\n", m_policy43);
+			switch (m_policy43) {
+			case 0: /* scale */
+			case 1: /* nonlinear */
+			case 2: /* panscan */
+			case 3: /* pillarbox */
+				printf("[cXineLib] 4:3 SCALE/NONLINEAR/PANSCAN/PILLARBOX\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			case 4: /* zoom */
+				printf("[cXineLib] 4:3 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(m_zoom43_x, m_zoom43_y);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		case 3: /* 16:9 */
+			printf("[cXineLib] m_policy169 %d\n", m_policy169);
+			switch (m_policy169) {
+			case 0: /* scale */
+				printf("[cXineLib] 16:9 SCALE\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			case 1: /* panscan */
+				printf("[cXineLib] 16:9 PANSCAN\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+				set_crop_settings(m_width/8, m_width/8, 0, 0);
+				break;
+			case 2: /* letterbox */
+				printf("[cXineLib] 16:9 LETTERBOX\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			case 3: /* zoom */
+				printf("[cXineLib] 16:9 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(m_zoom169_x, m_zoom169_y);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		}
+		break;
+	case XINE_VO_ASPECT_ANAMORPHIC: /* 16:9 */
+		printf("[cXineLib] XINE_VO_ASPECT_ANAMORPHIC (16:9)\n");
+		switch (m_aspect) {
+		case 2: /* 4:3 */
+			switch (m_policy43) {
+			case 0: /* scale */
+				printf("[cXineLib] 4:3 SCALE\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			case 1: /* nonlinear */
+				printf("[cXineLib] 4:3 NONLINEAR\n");
+				break;
+			case 2: /* panscan */
+				printf("[cXineLib] 4:3 PANSCAN\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+				set_crop_settings(0, 0, m_height/8, m_height/8);
+				break;
+			case 3: /* pillarbox */
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(100, 100);
+				printf("[cXineLib] 4:3 PILLARBOX\n");
+				break;
+			case 4: /* zoom */
+				printf("[cXineLib] 4:3 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
+				set_zoom_settings(m_zoom43_x, m_zoom43_y);
+				set_crop_settings(0, 0, 0, 0);
+//				detect_aspect_from_frame(true);
+				break;
+			}
+			break;
+		case 3: /* 16:9 */
+			printf("[cXineLib] m_policy169 %d\n", m_policy169);
+			switch (m_policy169) {
+			case 0: /* scale */
+			case 1: /* panscan */
+			case 2: /* letterbox */
+				printf("[cXineLib] 16:9 SCALE/PANSCAN/LETTERBOX\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(100, 100);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			case 3: /* zoom */
+				printf("[cXineLib] 16:9 ZOOM\n");
+				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
+				set_zoom_settings(m_zoom169_x, m_zoom169_y);
+				set_crop_settings(0, 0, 0, 0);
+				break;
+			}
+			break;
+		}
+		break;
+	}
+
+	if (m_width<=720) {
+		/* SD channels */
+		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, m_sharpness);
+		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, m_noise);
+	}
+	else {
+		/* HD & HEVC channels */
+		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, 0);
+		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, 0);
+	}
+}
+
+/* Сorrect xine stream closure */
+/*RESULT cXineLib::stop() {
+	if (m_state == stError)
+		return -1;
+
+	ASSERT(m_state != stIdle);
+	ASSERT(stream);
+	if (m_state == stStopped)
+		return -1;
+	xine_stop(stream);
+	// STOP
+	m_state = stStopped;
+	return 0;
+}*/
diff -ruN o/lib/gdi/xineLib.h pc/lib/gdi/xineLib.h
--- o/lib/gdi/xineLib.h	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/gdi/xineLib.h	2025-07-11 16:39:46.963636513 +0300
@@ -0,0 +1,116 @@
+#ifndef __lib_gdi_xineLib_h
+#define __lib_gdi_xineLib_h
+
+#include <lib/gdi/gpixmap.h>
+#include <xine.h>
+#include <xine/xine_internal.h>
+#include <xine/xineutils.h>
+#include <lib/dvb/idvb.h>
+#include <lib/base/message.h>
+#include <lib/gdi/post.h>
+
+//#include <lib/service/iservice.h>
+
+class cXineLib : public sigc::trackable {
+	DECLARE_REF(cXineLib);
+private:
+	static cXineLib        *instance;
+
+	xine_t                 *xine;
+	xine_stream_t          *stream;
+	xine_video_port_t      *vo_port;
+	xine_audio_port_t      *ao_port;
+	xine_osd_t             *osd;
+	xine_event_queue_t     *event_queue;
+	post_plugins_t         *postplugins;
+
+	xine_streamtype_data_t  videoData, audioData;
+
+	bool videoPlayed;
+	bool doDescramble;
+	int  osdWidth, osdHeight;
+	int  windowWidth, windowHeight;
+
+	int m_width, m_height, m_framerate, m_aspect, m_progressive;
+	int sound_mode, sound_card, sound_device, sound_output;
+	int m_windowAspectRatio, m_policy43, m_policy169;
+	int m_zoom43_x, m_zoom43_y, m_zoom169_x, m_zoom169_y;
+	int m_sharpness, m_noise;
+	int m_streamtype;
+	int m_hevc, m_avc, m_mpeg2;
+
+	void setStreamType(int video);
+	void setLiveTV(int v_streamtype);
+
+	static void xine_event_handler(void *user_data, const xine_event_t *event);
+
+	eFixedMessagePump<iTSMPEGDecoder::videoEvent> m_pump;
+	void pumpEvent(const iTSMPEGDecoder::videoEvent &event);
+
+	void set_zoom_settings(int x, int y);
+	void set_crop_settings(int left, int right, int top, int bottom);
+public:
+	bool end_of_stream;
+
+	cXineLib(x11_visual_t *vis);
+	virtual ~cXineLib();
+
+	static cXineLib *getInstance() { return instance; }
+
+	void setPrebuffer(int prebuffer);
+	void setVolume(int value);
+	void setVolumeMute(int value);
+	void showOsd();
+	void newOsd(int width, int height, uint32_t *argb_buffer);
+	void playVideo(void);
+	void stopVideo(void);
+	void setVideoType(int pid, int type);
+	void setAudioType(int pid, int type);
+	void rewire_posts_load();
+	void rewire_posts_unload();
+
+	void FilmVideo(char *mrl);
+	int VideoPause();
+	int VideoResume();
+	int VideoPosition();
+	int VideoPlayF();
+	int VposStream;
+	int Vpos;
+	int Vlength;
+
+	int VideoRewT(pts_t Rew);
+	void SeekTo(long long value);
+	int getNumberOfTracksAudio();
+	void selectAudioStream(int value);
+	int getCurrentTrackAudio();
+	std::string getAudioLang(int value);
+
+	sigc::signal<void(struct iTSMPEGDecoder::videoEvent)> m_event;
+
+	int getVideoWidth();
+	int getVideoHeight();
+	int getVideoFrameRate();
+	int getProgressive();
+	int getVideoAspect();
+	void adjust_policy();
+	RESULT getPTS(pts_t &pts);
+	void setVideoWindow(int window_x, int window_y, int window_width, int window_height);
+	void updateWindowSize(int width, int height);
+
+	void setDeinterlace(int global, int sd, int hd);
+	void setSDfeatures(int sharpness, int noise);
+	void setAspectRatio(int ratio);
+	void setPolicy43(int mode);
+	void setPolicy169(int mode);
+	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
+	void setBufMetronom(int hevc, int avc, int mpeg2);
+	void setScrambled(bool doDescramble);
+
+/*	RESULT stop();
+	enum
+	{
+		stError, stIdle, stRunning, stStopped,
+	};
+	int m_state;*/
+};
+#endif
diff -ruN o/lib/gui/evideo.cpp pc/lib/gui/evideo.cpp
--- o/lib/gui/evideo.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/gui/evideo.cpp	2025-07-11 16:39:46.963636513 +0300
@@ -1,6 +1,7 @@
 #include <lib/base/cfile.h>
 #include <lib/gui/evideo.h>
 #include <lib/gui/ewidgetdesktop.h>
+#include <lib/gdi/xineLib.h>
 
 ePtr<eTimer> eVideoWidget::fullsizeTimer;
 int eVideoWidget::pendingFullsize = 0;
@@ -56,6 +57,8 @@
 	posFullsizeTop = pos.top();
 	posFullsizeWidth = pos.width();
 	posFullsizeHeight = pos.height();
+	cXineLib* xineLib = cXineLib::getInstance();
+	xineLib->setVideoWindow(posFullsizeLeft, posFullsizeTop, posFullsizeWidth, posFullsizeHeight);
 	setPosition(0, posFullsizeLeft, posFullsizeTop, posFullsizeWidth, posFullsizeHeight);
 }
 
@@ -84,6 +87,8 @@
 	{
 		if (force || (pendingFullsize & (1 << decoder)))
 		{
+			cXineLib* xineLib = cXineLib::getInstance();
+			xineLib->setVideoWindow(posFullsizeLeft, posFullsizeTop, posFullsizeWidth, posFullsizeHeight);
 			eVideoWidget::setPosition(decoder, posFullsizeLeft, posFullsizeTop, posFullsizeWidth, posFullsizeHeight);
 			pendingFullsize &= ~(1 << decoder);
 		}
@@ -129,6 +134,8 @@
 
 	if (!disable)
 	{
+		cXineLib* xineLib = cXineLib::getInstance();
+		xineLib->setVideoWindow(pos.left(), pos.top(), pos.width(), pos.height());
 		setPosition(m_decoder, left, top, width, height);
 		pendingFullsize &= ~(1 << m_decoder);
 		m_state |= 8;
diff -ruN o/lib/python/Components/About.py pc/lib/python/Components/About.py
--- o/lib/python/Components/About.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/About.py	2025-07-11 16:39:46.963636513 +0300
@@ -13,8 +13,8 @@
 
 def getImageVersionString():
 	try:
-		if os.path.isfile('/var/lib/opkg/status'):
-			st = os.stat('/var/lib/opkg/status')
+		if os.path.isfile('/var/lib/dpkg/status'):
+			st = os.stat('/var/lib/dpkg/status')
 		tm = time.localtime(st.st_mtime)
 		if tm.tm_year >= 2011:
 			return time.strftime("%Y-%m-%d %H:%M:%S", tm)
@@ -39,7 +39,7 @@
 def getUpdateDateString():
 	try:
 		from glob import glob
-		build = [x.split("-")[-2:-1][0][-8:] for x in open(glob("/var/lib/opkg/info/openpli-bootlogo.control")[0], "r") if x.startswith("Version:")][0]
+		build = [x.split("-")[-2:-1][0][-8:] for x in open(glob("/var/lib/dpkg/info/openpli-bootlogo.control")[0], "r") if x.startswith("Version:")][0]
 		if build.isdigit():
 			return returndate(build)
 	except:
@@ -64,8 +64,8 @@
 def getGStreamerVersionString():
 	try:
 		from glob import glob
-		gst = [x.split("Version: ") for x in open(glob("/var/lib/opkg/info/gstreamer[0-9].[0-9].control")[0], "r") if x.startswith("Version:")][0]
-		return "%s" % gst[1].split("+")[0].split("-")[0].replace("\n", "")
+		gst = [x.split("Source: gstreamer") for x in open(glob("/var/lib/dpkg/status")[0], "r") if x.startswith("Source: gstreamer")][0]
+		return "%s" % gst[1].split(" ")[0].replace("\n", "")
 	except:
 		return ""
 
@@ -73,8 +73,18 @@
 def getffmpegVersionString():
 	try:
 		from glob import glob
-		ffmpeg = [x.split("Version: ") for x in open(glob("/var/lib/opkg/info/ffmpeg.control")[0], "r") if x.startswith("Version:")][0]
-		return "%s" % ffmpeg[1].split("-")[0].replace("\n", "")
+		ffmpeg = [x.split("Version: 7:") for x in open(glob("/var/lib/dpkg/status")[0], "r") if x.startswith("Version: 7:")][0]
+		return "%s" % ffmpeg[1].split(":")[0].replace("\n", "")
+	except:
+		return _("Not Installed")
+
+def getlibxineVersionString():
+	try:
+		from glob import glob
+		libxine = [x.split("Version: 1.2.13+") for x in open(glob("/var/lib/dpkg/status")[0], "r") if x.startswith("Version: 1.2.13+")][0]
+		return "%s" % libxine[1].split("+")[0].replace("\n", "")
+#		libxine = [x.split("Version: 12:") for x in open(glob("/var/lib/dpkg/status")[0], "r") if x.startswith("Version: 12:")][0]
+#		return "%s" % libxine[1].split(":")[0].replace("\n", "")
 	except:
 		return ""
 
@@ -126,15 +136,9 @@
 
 		temperature = None
 		freq = _("MHz")
-		if os.path.isfile('/proc/stb/fp/temp_sensor_avs'):
-			temperature = open("/proc/stb/fp/temp_sensor_avs").readline().replace('\n', '')
-		elif os.path.isfile('/proc/stb/power/avs'):
-			temperature = open("/proc/stb/power/avs").readline().replace('\n', '')
-		elif os.path.isfile('/proc/stb/fp/temp_sensor'):
-			temperature = open("/proc/stb/fp/temp_sensor").readline().replace('\n', '')
-		elif os.path.isfile("/sys/devices/virtual/thermal/thermal_zone0/temp"):
+		if os.path.isfile("/sys/devices/virtual/thermal/thermal_zone1/temp"):
 			try:
-				temperature = int(open("/sys/devices/virtual/thermal/thermal_zone0/temp").read().strip()) // 1000
+				temperature = int(open("/sys/devices/virtual/thermal/thermal_zone1/temp").read().strip()) // 1000
 			except:
 				pass
 		elif os.path.isfile("/proc/hisi/msp/pm_cpu"):
@@ -153,16 +157,16 @@
 	try:
 		from glob import glob
 		try:
-			driver = [x.split("-") for x in open(glob("/var/lib/opkg/info/*-dvb-modules-*.control")[0], "r") if x.startswith("Version:")][0]
+			driver = [x.split("-") for x in open(glob("/var/lib/dpkg/info/*-dvb-modules-*.control")[0], "r") if x.startswith("Version:")][0]
 			if len(driver) == 2:
 				driver = driver[0].split('+')
 			return "%s-%s-%s" % (driver[1][:4], driver[1][4:6], driver[1][6:])
 		except:
 			try:
-				driver = [x.split("Version:") for x in open(glob("/var/lib/opkg/info/*-dvb-proxy-*.control")[0], "r") if x.startswith("Version:")][0]
+				driver = [x.split("Version:") for x in open(glob("/var/lib/dpkg/info/*-dvb-proxy-*.control")[0], "r") if x.startswith("Version:")][0]
 				return "%s" % driver[1].replace("\n", "")
 			except:
-				driver = [x.split("Version:") for x in open(glob("/var/lib/opkg/info/*-platform-util-*.control")[0], "r") if x.startswith("Version:")][0]
+				driver = [x.split("Version:") for x in open(glob("/var/lib/dpkg/info/*-platform-util-*.control")[0], "r") if x.startswith("Version:")][0]
 				return "%s" % driver[1].replace("\n", "")
 	except:
 		return _("unknown")
diff -ruN o/lib/python/Components/ActionMap.py pc/lib/python/Components/ActionMap.py
--- o/lib/python/Components/ActionMap.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/ActionMap.py	2025-07-11 16:39:46.963636513 +0300
@@ -104,7 +104,7 @@
 		adict = {}
 		for context in contexts:
 			alist = []
-			for (action, funchelp) in actions.items():
+			for (action, funchelp) in list(actions.items()):
 				# Check if this is a tuple.
 				if isinstance(funchelp, tuple):
 					if queryKeyBinding(context, action):
diff -ruN o/lib/python/Components/AVSwitch.py pc/lib/python/Components/AVSwitch.py
--- o/lib/python/Components/AVSwitch.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/AVSwitch.py	2025-07-11 16:39:46.963636513 +0300
@@ -101,7 +101,7 @@
 	# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
 	"panscan": _("Pan&scan"),
 	# TRANSLATORS: (aspect ratio policy: scale as close to fullscreen as possible)
-	"scale": _("Just scale")}
+	"scale": _("Just scale"), "zoom": _("Zoom")}
 	try:
 		if "full" in open("/proc/stb/video/policy2_choices").read():
 			# TRANSLATORS: (aspect ratio policy: display as fullscreen, even if the content aspect ratio does not match the screen ratio)
@@ -121,7 +121,7 @@
 	# TRANSLATORS: (aspect ratio policy: cropped content on left/right) in doubt, keep english term
 	"panscan": _("Pan&scan"),
 	# TRANSLATORS: (aspect ratio policy: scale as close to fullscreen as possible)
-	"scale": _("Just scale")}
+	"scale": _("Just scale"), "zoom": _("Zoom")}
 	try:
 		if "nonlinear" in open("/proc/stb/video/policy_choices").read():
 			# TRANSLATORS: (aspect ratio policy: display as fullscreen, with stretching the left/right)
diff -ruN o/lib/python/Components/config.py pc/lib/python/Components/config.py
--- o/lib/python/Components/config.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/config.py	2025-07-11 16:39:46.964636458 +0300
@@ -401,7 +401,7 @@
 
 	def setValue(self, value):
 		prev = str(self._value) if hasattr(self, "_value") else None
-		if str(value) in map(str, self.choices):
+		if str(value) in list(map(str, self.choices)):
 			self._value = self.choices[self.choices.index(value)]
 		else:
 			self._value = self.default
@@ -1962,7 +1962,7 @@
 
 	def setSavedValue(self, values):
 		self.stored_values = dict(values)
-		for (key, val) in self.stored_values.items():
+		for (key, val) in list(self.stored_values.items()):
 			if int(key) < len(self):
 				self[int(key)].saved_value = val
 
@@ -1988,16 +1988,16 @@
 		self.stored_values = {}
 
 	def load(self):
-		for item in self.values():
+		for item in list(self.values()):
 			item.load()
 
 	def save(self):
-		for item in self.values():
+		for item in list(self.values()):
 			item.save()
 
 	def getSavedValue(self):
 		values = {}
-		for (key, val) in self.items():
+		for (key, val) in list(self.items()):
 			saved = val.saved_value
 			if saved is not None:
 				values[str(key)] = saved
@@ -2005,7 +2005,7 @@
 
 	def setSavedValue(self, values):
 		self.stored_values = dict(values)
-		for (key, val) in self.items():
+		for (key, val) in list(self.items()):
 			if str(key) in self.stored_values:
 				val.saved_value = self.stored_values[str(key)]
 
@@ -2058,7 +2058,7 @@
 
 	def getSavedValue(self):
 		values = self.content.stored_values
-		for (key, val) in self.content.items.items():
+		for (key, val) in list(self.content.items.items()):
 			saved = val.saved_value
 			if saved is not None:
 				values[key] = saved
@@ -2069,7 +2069,7 @@
 	def setSavedValue(self, values):
 		values = dict(values)
 		self.content.stored_values = values
-		for (key, val) in self.content.items.items():
+		for (key, val) in list(self.content.items.items()):
 			value = values.get(key, None)
 			if value is not None:
 				val.saved_value = value
@@ -2077,15 +2077,15 @@
 	saved_value = property(getSavedValue, setSavedValue)
 
 	def save(self):
-		for item in self.content.items.values():
+		for item in list(self.content.items.values()):
 			item.save()
 
 	def load(self):
-		for item in self.content.items.values():
+		for item in list(self.content.items.values()):
 			item.load()
 
 	def cancel(self):
-		for item in self.content.items.values():
+		for item in list(self.content.items.values()):
 			item.cancel()
 
 	def dict(self):
@@ -2102,7 +2102,7 @@
 		ConfigSubsection.__init__(self)
 
 	def pickle_this(self, prefix, topickle, result):
-		for (key, val) in sorted(topickle.items(), key=lambda x: int(x[0]) if x[0].isdigit() else x[0].lower()):
+		for (key, val) in sorted(list(topickle.items()), key=lambda x: int(x[0]) if x[0].isdigit() else x[0].lower()):
 			name = '.'.join((prefix, key))
 			if isinstance(val, dict):
 				self.pickle_this(name, val, result)
diff -ruN o/lib/python/Components/Console.py pc/lib/python/Components/Console.py
--- o/lib/python/Components/Console.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Console.py	2025-07-11 16:39:46.964636458 +0300
@@ -86,6 +86,6 @@
 			self.appContainers[name].container.kill()
 
 	def killAll(self):
-		for name, item in self.appContainers.items():
+		for name, item in list(self.appContainers.items()):
 			print("[Console] killing: ", name)
 			item.container.kill()
diff -ruN o/lib/python/Components/Converter/EventName.py pc/lib/python/Components/Converter/EventName.py
--- o/lib/python/Components/Converter/EventName.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Converter/EventName.py	2025-07-11 16:39:46.964636458 +0300
@@ -118,10 +118,6 @@
 				return ""
 			else:
 				return getGenreStringSub(genre.getLevel1(), genre.getLevel2())
-		elif self.type == self.NAME_NOW:
-			return pgettext("now/next: 'now' event label", "Now") + ": " + event.getEventName()
-		elif self.type == self.NAME_NEXT:
-			return pgettext("now/next: 'next' event label", "Next") + ": " + event.getEventName()
 		elif self.type == self.SHORT_DESCRIPTION:
 			return dropEPGNewLines(event.getShortDescription())
 		elif self.type == self.EXTENDED_DESCRIPTION:
diff -ruN o/lib/python/Components/Harddisk.py pc/lib/python/Components/Harddisk.py
--- o/lib/python/Components/Harddisk.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Harddisk.py	2025-07-11 16:39:46.964636458 +0300
@@ -52,7 +52,7 @@
 	def __init__(self, device, removable=False):
 		self.device = device
 
-		if os.access("/dev/.udev", 0):
+		if os.access("/dev/disk", 0):
 			self.type = DEVTYPE_UDEV
 		elif os.access("/dev/udev_network_queue", 0):
 			self.type = DEVTYPE_UDEV
@@ -93,8 +93,8 @@
 			tmp = readFile(self.sysfsPath('dev')).split(':')
 			s_major = int(tmp[0])
 			s_minor = int(tmp[1])
-			for disc in os.listdir("/dev/discs"):
-				dev_path = os.path.realpath('/dev/discs/' + disc)
+			for disc in os.listdir("/dev/disc"):
+				dev_path = os.path.realpath('/dev/disc/' + disc)
 				disk_path = dev_path + '/disc'
 				try:
 					rdev = os.stat(disk_path).st_rdev
diff -ruN o/lib/python/Components/HdmiCec.py pc/lib/python/Components/HdmiCec.py
--- o/lib/python/Components/HdmiCec.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/HdmiCec.py	2025-07-11 16:39:46.964636458 +0300
@@ -10,7 +10,7 @@
 from enigma import eTimer
 from sys import maxsize
 
-LOGPATH = "/hdd/"
+LOGPATH = "/media/hdd/"
 LOGFILE = "hdmicec.log"
 
 # CEC Version's table
diff -ruN o/lib/python/Components/InputDevice.py pc/lib/python/Components/InputDevice.py
--- o/lib/python/Components/InputDevice.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/InputDevice.py	2025-07-11 16:39:46.965636404 +0300
@@ -41,7 +41,6 @@
 				self.name = self.name[:self.name.find("\0")]
 				os.close(self.fd)
 			except (IOError, OSError) as err:
-				print("[InputDevice] getInputDevices " + evdev + " <ERROR: ioctl(EVIOCGNAME): " + str(err) + " >")
 				self.name = None
 
 			if self.name:
@@ -59,7 +58,7 @@
 			return None
 
 	def getDeviceName(self, x):
-		if x in self.Devices.keys():
+		if x in list(self.Devices.keys()):
 			return self.Devices[x].get("name", x)
 		else:
 			return "Unknown device name"
diff -ruN o/lib/python/Components/Language.py pc/lib/python/Components/Language.py
--- o/lib/python/Components/Language.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Language.py	2025-07-11 16:39:46.965636404 +0300
@@ -8,7 +8,7 @@
 
 class Language:
 	def __init__(self):
-		gettext.install('enigma2', resolveFilename(SCOPE_LANGUAGE, ""), codeset="utf-8")
+		gettext.install('enigma2', resolveFilename(SCOPE_LANGUAGE, ""))
 		gettext.bindtextdomain("enigma2", resolveFilename(SCOPE_LANGUAGE))
 		gettext.textdomain("enigma2")
 		self.activeLanguage = 0
diff -ruN o/lib/python/Components/MovieList.py pc/lib/python/Components/MovieList.py
--- o/lib/python/Components/MovieList.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/MovieList.py	2025-07-11 16:39:46.965636404 +0300
@@ -752,7 +752,7 @@
 
 		# reverse the dictionary to see which unique movie each tag now references
 		rautotags = {}
-		for tag, movies in autotags.items():
+		for tag, movies in list(autotags.items()):
 			if (len(movies) > 1):
 				movies = tuple(movies) # a tuple can be hashed, but a list not
 				item = rautotags.get(movies, [])
@@ -760,7 +760,7 @@
 					rautotags[movies] = item
 				item.append(tag)
 		self.tags = {}
-		for movies, tags in rautotags.items():
+		for movies, tags in list(rautotags.items()):
 			movie = movies[0]
 			# format the tag lists so that they are in 'original' order
 			tags.sort(key=movie.find)
diff -ruN o/lib/python/Components/Network.py pc/lib/python/Components/Network.py
--- o/lib/python/Components/Network.py	2025-07-11 16:39:11.175577893 +0300
+++ pc/lib/python/Components/Network.py	2025-07-11 16:39:46.965636404 +0300
@@ -93,7 +93,7 @@
 			fp.write("# automatically generated by enigma2\n# do NOT change manually!\n\n")
 			fp.write("auto lo\n")
 			fp.write("iface lo inet loopback\n\n")
-			for ifacename, iface in self.ifaces.items():
+			for ifacename, iface in list(self.ifaces.items()):
 				if iface['up']:
 					fp.write("auto " + ifacename + "\n")
 					self.configuredInterfaces.append(ifacename)
@@ -172,7 +172,7 @@
 							if dns_ip != [0, 0, 0, 0] and dns_ip not in self.ifaces[currif]["dns-nameservers"]:
 								self.ifaces[currif]["dns-nameservers"].append(dns_ip)
 
-		for ifacename, iface in ifaces.items():
+		for ifacename, iface in list(ifaces.items()):
 			if ifacename in self.ifaces:
 				self.ifaces[ifacename]["dhcp"] = iface["dhcp"]
 		if not self.console.appContainers:
@@ -223,7 +223,7 @@
 		return len(self.ifaces)
 
 	def getFriendlyAdapterName(self, x):
-		if x in self.friendlyNames.keys():
+		if x in list(self.friendlyNames.keys()):
 			return self.friendlyNames.get(x, x)
 		self.friendlyNames[x] = self.getFriendlyAdapterNaming(x)
 		return self.friendlyNames.get(x, x)  # when we have no friendly name, use adapter name
@@ -357,7 +357,7 @@
 	def resetNetworkConfig(self, mode='lan', callback=None):
 		self.commands = []
 		self.commands.append("/etc/init.d/avahi-daemon stop")
-		for iface in self.ifaces.keys():
+		for iface in list(self.ifaces.keys()):
 			if iface != 'eth0' or not self.onRemoteRootFS():
 				self.commands.append("/sbin/ip addr flush dev " + iface + " scope global")
 		self.commands.append("/etc/init.d/networking stop")
@@ -431,7 +431,7 @@
 		self.msgPlugins()
 		self.commands = []
 		self.commands.append("/etc/init.d/avahi-daemon stop")
-		for iface in self.ifaces.keys():
+		for iface in list(self.ifaces.keys()):
 			if iface != 'eth0' or not self.onRemoteRootFS():
 				self.commands.append(("/sbin/ifdown", "/sbin/ifdown", iface))
 				self.commands.append("/sbin/ip addr flush dev " + iface + " scope global")
@@ -614,7 +614,7 @@
 		return 'wext'
 
 	def calc_netmask(self, nmask):
-		cidr_range = range(0, 32)
+		cidr_range = list(range(0, 32))
 		cidr = int(nmask)
 		if cidr not in cidr_range:
 			print("[Network] cidr invalid: %d" % cidr)
diff -ruN o/lib/python/Components/NimManager.py pc/lib/python/Components/NimManager.py
--- o/lib/python/Components/NimManager.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/NimManager.py	2025-07-11 16:39:46.966636349 +0300
@@ -582,7 +582,7 @@
 	def getTunerTypesEnabled(self):
 		try:
 			if self.combined:
-				return [x for x in self.multi_type.values() if
+				return [x for x in list(self.multi_type.values()) if
 					self.config.configModeDVBS.value and x.startswith("DVB-S") or
 					self.config.configModeDVBC.value and x.startswith("DVB-C") or
 					self.config.configModeDVBT.value and x.startswith("DVB-T") or
@@ -595,12 +595,12 @@
 		return self.isSupported() and bool([x for x in self.getTunerTypesEnabled() if what in self.compatible[x]])
 
 	def canBeCompatible(self, what):
-		return self.isSupported() and bool([x for x in self.multi_type.values() if what in self.compatible[x]] if self.multi_type else self.isCompatible(what))
+		return self.isSupported() and bool([x for x in list(self.multi_type.values()) if what in self.compatible[x]] if self.multi_type else self.isCompatible(what))
 
 	def getType(self):
 		try:
 			if self.isCombined():
-				return [x for x in self.multi_type.values() if x.startswith("DVB-S")][0]
+				return [x for x in list(self.multi_type.values()) if x.startswith("DVB-S")][0]
 			if self.isMultiType():
 				return self.multi_type[self.config.multiType.value]
 		except:
@@ -694,8 +694,8 @@
 		return self.isFBCTuner() and self.is_fbc[1] != 1
 
 	def getFriendlyType(self):
-		if self.multi_type.values():
-			returnValue = "/".join([x[1].replace("DVB-", "") for x in sorted([({"DVB-S": 1, "DVB-C": 2, "DVB-T": 3, "ATSC": 4}[x[:5]], x) for x in self.multi_type.values()])])
+		if list(self.multi_type.values()):
+			returnValue = "/".join([x[1].replace("DVB-", "") for x in sorted([({"DVB-S": 1, "DVB-C": 2, "DVB-T": 3, "ATSC": 4}[x[:5]], x) for x in list(self.multi_type.values())])])
 			return "%s %s" % (_("Combined") if self.combined else _("MultiType"), returnValue if returnValue == 'ATSC' else "DVB-%s" % returnValue)
 		return self.getType() or _("empty")
 
@@ -929,10 +929,10 @@
 				entries[current_slot]["name"] = _("N/A")
 				entries[current_slot]["isempty"] = True
 		nimfile.close()
-		self.number_of_slots = len(entries.keys())
+		self.number_of_slots = len(list(entries.keys()))
 		fbc_number = 0
 		fbc_tuner = 1
-		for id, entry in entries.items():
+		for id, entry in list(entries.items()):
 			if not ("name" in entry and "type" in entry):
 				entry["name"] = _("N/A")
 				entry["type"] = None
@@ -1061,7 +1061,7 @@
 						nimHaveRotor = True
 						break
 				if not nimHaveRotor:
-					for sat in mode.advanced.sat.values():
+					for sat in list(mode.advanced.sat.values()):
 						lnb_num = int(sat.lnb.value)
 						diseqcmode = lnb_num and mode.advanced.lnb[lnb_num].diseqcMode.value or ""
 						if diseqcmode == "1_2":
@@ -1092,7 +1092,7 @@
 					if lnb_num != 0 and nim.advanced.lnb[lnb_num].lof.value == "unicable":
 						return True
 				if not is_unicable:
-					for sat in nim.advanced.sat.values():
+					for sat in list(nim.advanced.sat.values()):
 						lnb_num = int(sat.lnb.value)
 						if lnb_num != 0 and nim.advanced.lnb[lnb_num].lof.value == "unicable":
 							return True
@@ -1342,7 +1342,7 @@
 	lnb_choices_default = "universal_lnb"
 
 	prio_list = [("-1", _("Auto"))]
-	for prio in chain(range(65), range(14000, 14065), range(19000, 19065)):
+	for prio in chain(list(range(65)), list(range(14000, 14065)), list(range(19000, 19065))):
 		description = ""
 		if prio == 0:
 			description = _(" (disabled)")
@@ -1807,7 +1807,7 @@
 			createATSCConfig(nim, slot_id)
 
 		if slot.isMultiType() and not hasattr(nim, "multiType"):
-			nim.multiType = ConfigSelection([(id, slot.getMultiTypeList()[id]) for id in slot.getMultiTypeList().keys()] + [("nothing", _("disabled"))], "0")
+			nim.multiType = ConfigSelection([(id, slot.getMultiTypeList()[id]) for id in list(slot.getMultiTypeList().keys())] + [("nothing", _("disabled"))], "0")
 			nim.multiType.fe_id = slot_id
 			nim.multiType.addNotifier(boundFunction(tunerTypeChanged, nimmgr))
 			if nim.multiType.value == "nothing":
diff -ruN o/lib/python/Components/ParentalControlList.py pc/lib/python/Components/ParentalControlList.py
--- o/lib/python/Components/ParentalControlList.py	1970-01-01 03:00:00.000000000 +0300
+++ pc/lib/python/Components/ParentalControlList.py	2025-07-11 16:39:46.966636349 +0300
@@ -0,0 +1,45 @@
+from .MenuList import MenuList
+from Components.ParentalControl import IMG_WHITESERVICE, IMG_WHITEBOUQUET, IMG_BLACKSERVICE, IMG_BLACKBOUQUET
+from Tools.Directories import SCOPE_SKIN_IMAGE, resolveFilename
+
+from enigma import eListboxPythonMultiContent, gFont, RT_HALIGN_LEFT
+from Tools.LoadPixmap import LoadPixmap
+
+#Now there is a list of pictures instead of one...
+entryPicture = {}
+
+entryPicture[IMG_BLACKSERVICE] = LoadPixmap(resolveFilename(SCOPE_SKIN_IMAGE, "skin_default/icons/lock.png"))
+entryPicture[IMG_BLACKBOUQUET] = LoadPixmap(resolveFilename(SCOPE_SKIN_IMAGE, "skin_default/icons/lockBouquet.png"))
+entryPicture[IMG_WHITESERVICE] = LoadPixmap(resolveFilename(SCOPE_SKIN_IMAGE, "skin_default/icons/unlock.png"))
+entryPicture[IMG_WHITEBOUQUET] = LoadPixmap(resolveFilename(SCOPE_SKIN_IMAGE, "skin_default/icons/unlockBouquet.png"))
+
+def ParentalControlEntryComponent(service, name, protectionType):
+	locked = protectionType[0]
+	sImage = protectionType[1]
+	res = [
+		(service, name, locked),
+		(eListboxPythonMultiContent.TYPE_TEXT, 80, 5, 300, 50, 0, RT_HALIGN_LEFT, name)
+	]
+	#Changed logic: The image is defined by sImage, not by locked anymore
+	if sImage != "":
+		res.append((eListboxPythonMultiContent.TYPE_PIXMAP_ALPHATEST, 0, 0, 32, 32, entryPicture[sImage]))
+	return res
+
+class ParentalControlList(MenuList):
+	def __init__(self, list, enableWrapAround = False):
+		MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
+		self.l.setFont(0, gFont("Regular", 20))
+		self.l.setItemHeight(32)
+
+	def toggleSelectedLock(self):
+		from Components.ParentalControl import parentalControl
+		print("self.l.getCurrentSelection():", self.l.getCurrentSelection())
+		print("self.l.getCurrentSelectionIndex():", self.l.getCurrentSelectionIndex())
+		curSel = self.l.getCurrentSelection()
+		if curSel[0][2]:
+			parentalControl.unProtectService(self.l.getCurrentSelection()[0][0])
+		else:
+			parentalControl.protectService(self.l.getCurrentSelection()[0][0])
+		#Instead of just negating the locked- flag, now I call the getProtectionType every time...
+		self.list[self.l.getCurrentSelectionIndex()] = ParentalControlEntryComponent(curSel[0][0], curSel[0][1], parentalControl.getProtectionType(curSel[0][0]))
+		self.l.setList(self.list)
diff -ruN o/lib/python/Components/ParentalControl.py pc/lib/python/Components/ParentalControl.py
--- o/lib/python/Components/ParentalControl.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/ParentalControl.py	2025-07-11 16:39:46.966636349 +0300
@@ -194,7 +194,7 @@
 
 	def saveListToFile(self, sWhichList, vList):
 		file = open(resolveFilename(SCOPE_CONFIG, sWhichList), 'w')
-		for sService, sType in vList.items():
+		for sService, sType in list(vList.items()):
 			if (TYPE_SERVICE in sType or TYPE_BOUQUET in sType) and not sService.startswith("-"):
 				file.write(str(sService) + "\n")
 		file.close()
diff -ruN o/lib/python/Components/PerServiceDisplay.py pc/lib/python/Components/PerServiceDisplay.py
--- o/lib/python/Components/PerServiceDisplay.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/PerServiceDisplay.py	2025-07-11 16:39:46.966636349 +0300
@@ -31,7 +31,7 @@
 			self.navcore.event.append(PerServiceBase.event)
 
 		EventMap = EventMap.setdefault
-		for x in eventmap.items():
+		for x in list(eventmap.items()):
 			EventMap(x[0], []).append((with_event, x[1]))
 
 		# start with stopped state, so simulate that
@@ -44,7 +44,7 @@
 
 	def destroy(self):
 		EventMap = PerServiceBase.EventMap.setdefault
-		for x in self.eventmap.items():
+		for x in list(self.eventmap.items()):
 			EventMap(x[0], []).remove((self.with_event, x[1]))
 
 	def enablePolling(self, interval=60000):
diff -ruN o/lib/python/Components/RcModel.py pc/lib/python/Components/RcModel.py
--- o/lib/python/Components/RcModel.py	2025-07-11 16:39:11.175577893 +0300
+++ pc/lib/python/Components/RcModel.py	2025-07-11 16:39:46.967636295 +0300
@@ -27,9 +27,9 @@
 		else:
 			modeltype = None
 
-		if modeltype is not None and modeltype in self.RcModels.keys():
+		if modeltype is not None and modeltype in list(self.RcModels.keys()):
 			remote = self.RcModels[modeltype]
-		elif self.model in self.RcModels.keys():
+		elif self.model in list(self.RcModels.keys()):
 			remote = self.RcModels[self.model]
 		else:
 			remote = 'dmm'	# default. Assume files for dmm exists
diff -ruN o/lib/python/Components/Renderer/NextEpgInfo.py pc/lib/python/Components/Renderer/NextEpgInfo.py
--- o/lib/python/Components/Renderer/NextEpgInfo.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Renderer/NextEpgInfo.py	2025-07-11 16:39:46.967636295 +0300
@@ -32,15 +32,11 @@
 					if event:
 						if self.hideLabel:
 							self.text = "%s%s%s%s%s" % (self.timecolor, strftime("%H:%M", localtime(event.getBeginTime())), spaces, self.foregroundColor, event.getEventName())
-						else:
-							self.text = "%s%s:%s%s%s" % (self.labelcolor, pgettext("now/next: 'next' event label", "Next"), spaces, self.foregroundColor, event.getEventName())
 				else:
 					for x in range(self.numberOfItems):
 						event = self.epgcache.getNextTimeEntry()
 						if event:
 							self.text += "%s%s%s%s%s\n" % (self.timecolor, strftime("%H:%M", localtime(event.getBeginTime())), spaces, self.foregroundColor, event.getEventName())
-					if not self.hideLabel:
-						self.text = self.text and "%s%s\n%s" % (self.labelcolor, pgettext("now/next: 'next' event label", "Next"), self.text) or ""
 
 	def applySkin(self, desktop, parent):
 		attribs = []
diff -ruN o/lib/python/Components/Sensors.py pc/lib/python/Components/Sensors.py
--- o/lib/python/Components/Sensors.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Sensors.py	2025-07-11 16:39:46.967636295 +0300
@@ -24,7 +24,7 @@
 	# returns a list of sensorids of type "type"
 	def getSensorsList(self, type=None):
 		if type is None:
-			return range(len(self.sensors_list))
+			return list(range(len(self.sensors_list)))
 		list = []
 		for sensorid in range(len(self.sensors_list)):
 			if self.sensors_list[sensorid][0] == type:
diff -ruN o/lib/python/Components/ServiceEventTracker.py pc/lib/python/Components/ServiceEventTracker.py
--- o/lib/python/Components/ServiceEventTracker.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/ServiceEventTracker.py	2025-07-11 16:39:46.967636295 +0300
@@ -114,11 +114,11 @@
 			screen.session.nav.event.append(ServiceEventTracker.event)
 			ServiceEventTracker.navcore = screen.session.nav
 		EventMap = EventMap.setdefault
-		for x in eventmap.items():
+		for x in list(eventmap.items()):
 			EventMap(x[0], []).append((self.__passall, screen, x[1]))
 		screen.onClose.append(self.__del_event)
 
 	def __del_event(self):
 		EventMap = ServiceEventTracker.EventMap.setdefault
-		for x in self.__eventmap.items():
+		for x in list(self.__eventmap.items()):
 			EventMap(x[0], []).remove((self.__passall, self.__screen, x[1]))
diff -ruN o/lib/python/Components/SystemInfo.py pc/lib/python/Components/SystemInfo.py
--- o/lib/python/Components/SystemInfo.py	2025-07-11 16:39:11.176577838 +0300
+++ pc/lib/python/Components/SystemInfo.py	2025-07-11 16:39:46.967636295 +0300
@@ -44,22 +44,14 @@
 	def __init__(self, root=""):
 		self.boxInfo = immutableDict({"machine": "default", "checksum": None}) #add one key to the boxInfoCollector as it always should exist to satisfy the CI test on github and predefine checksum
 		checksumcollectionstring = ""
-		file = root + "/usr/lib/enigma.info"
+		file = root + "/usr/local/e2/lib/enigma.info"
 		if fileExists(file):
 			for line in open(file, 'r').readlines():
-				if line.startswith("checksum="):
-					self.boxInfo["checksum"] = md5(bytearray(checksumcollectionstring, "UTF-8", errors="ignore")).hexdigest() == line.strip().split('=')[1]
-					break
-				checksumcollectionstring += line
 				if line.startswith("#") or line.strip() == "":
 					continue
 				if '=' in line:
 					item, value = line.split('=', 1)
 					self.boxInfo[item.strip()] = self.processValue(value.strip())
-			if self.boxInfo["checksum"]:
-				print("[SystemInfo] Enigma information file data loaded into BoxInfo.")
-			else:
-				print("[SystemInfo] Enigma information file data loaded, but checksum failed.")
 		else:
 			print("[SystemInfo] ERROR: %s is not available!  The system is unlikely to boot or operate correctly." % file)
 		self.boxInfo.setImmutable() #make what is derived from enigma.info immutable
diff -ruN o/lib/python/Components/Task.py pc/lib/python/Components/Task.py
--- o/lib/python/Components/Task.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Components/Task.py	2025-07-11 16:39:46.967636295 +0300
@@ -5,7 +5,7 @@
 
 
 class Job:
-	NOT_STARTED, IN_PROGRESS, FINISHED, FAILED = range(4)
+	NOT_STARTED, IN_PROGRESS, FINISHED, FAILED = list(range(4))
 
 	def __init__(self, name):
 		self.tasks = []
@@ -502,7 +502,7 @@
 			self.realpath = task.cmd
 			path = os.environ.get('PATH', '').split(os.pathsep)
 			path.append(task.cwd + '/')
-			absolutes = list(filter(lambda file: os.access(file, os.X_OK), list(map(lambda directory, file=task.cmd: os.path.join(directory, file), path))))
+			absolutes = list([file for file in list(map(lambda directory, file=task.cmd: os.path.join(directory, file), path)) if os.access(file, os.X_OK)])
 			if absolutes:
 				self.realpath = absolutes[0]
 				return True
diff -ruN o/lib/python/Components/UsageConfig.py pc/lib/python/Components/UsageConfig.py
--- o/lib/python/Components/UsageConfig.py	2025-07-11 16:39:11.176577838 +0300
+++ pc/lib/python/Components/UsageConfig.py	2025-07-11 16:39:46.968636240 +0300
@@ -129,8 +129,8 @@
 	config.usage.default_path = ConfigText(default="")
 	config.usage.timer_path = ConfigText(default="<default>")
 	config.usage.instantrec_path = ConfigText(default="<default>")
-	config.usage.timeshift_path = ConfigText(default="/media/hdd/")
-	config.usage.allowed_timeshift_paths = ConfigLocations(default=["/media/hdd/"])
+	config.usage.timeshift_path = ConfigText(default="/media/hdd/timeshift/")
+	config.usage.allowed_timeshift_paths = ConfigLocations(default=["/media/hdd/timeshift/"])
 	config.usage.timeshift_skipreturntolive = ConfigYesNo(default=False)
 	config.usage.movielist_trashcan = ConfigYesNo(default=True)
 	config.usage.movielist_trashcan_days = ConfigNumber(default=8)
@@ -791,6 +791,13 @@
 	config.autolanguage.subtitle_defaultdvb = ConfigYesNo(default=False)
 	config.autolanguage.subtitle_usecache = ConfigYesNo(default=True)
 
+	config.pc = ConfigSubsection()
+	config.pc.default_fullscreen = ConfigYesNo(default = False)
+	config.pc.zoom_enable = ConfigYesNo(default = False)
+	config.pc.image4_3_zoom_x = ConfigNumber(default = 100)
+	config.pc.image4_3_zoom_y = ConfigNumber(default = 100)
+	config.pc.image16_9_zoom_x = ConfigNumber(default = 100)
+	config.pc.image16_9_zoom_y = ConfigNumber(default = 100)
 	config.streaming = ConfigSubsection()
 	config.streaming.stream_ecm = ConfigYesNo(default=False)
 	config.streaming.descramble = ConfigYesNo(default=True)
diff -ruN o/lib/python/e2reactor.py pc/lib/python/e2reactor.py
--- o/lib/python/e2reactor.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/e2reactor.py	2025-07-11 16:39:46.968636240 +0300
@@ -82,7 +82,7 @@
 		except:
 			# the hard way: necessary because fileno() may disappear at any
 			# moment, thanks to python's underlying sockets impl
-			for fd, fdes in selectables.items():
+			for fd, fdes in list(selectables.items()):
 				if selectable is fdes:
 					break
 			else:
@@ -125,8 +125,8 @@
 		"""Remove all selectables, and return a list of them."""
 		if self.waker is not None:
 			self.removeReader(self.waker)
-		result = selectables.values()
-		fds = selectables.keys()
+		result = list(selectables.values())
+		fds = list(selectables.keys())
 		reads.clear()
 		writes.clear()
 		selectables.clear()
diff -ruN o/lib/python/enigma_python.i pc/lib/python/enigma_python.i
--- o/lib/python/enigma_python.i	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/enigma_python.i	2025-07-11 16:39:46.968636240 +0300
@@ -43,7 +43,6 @@
 #include <lib/base/message.h>
 #include <lib/base/e2avahi.h>
 #include <lib/driver/rc.h>
-#include <lib/driver/rcinput_swig.h>
 #include <lib/service/event.h>
 #include <lib/service/iservice.h>
 #include <lib/service/service.h>
@@ -199,7 +198,6 @@
 %immutable eDVBSatelliteEquipmentControl::slotRotorSatPosChanged;
 %include <lib/base/message.h>
 %include <lib/driver/rc.h>
-%include <lib/driver/rcinput_swig.h>
 %include <lib/gdi/fb.h>
 %include <lib/gdi/font.h>
 %include <lib/gdi/gpixmap.h>
diff -ruN o/lib/python/keyids.py pc/lib/python/keyids.py
--- o/lib/python/keyids.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/keyids.py	2025-07-11 16:39:46.968636240 +0300
@@ -344,7 +344,7 @@
 
 def invertKeyIds():
 	invKeyIds = {}
-	for key, value in KEYIDS.items():
+	for key, value in list(KEYIDS.items()):
 		if value not in invKeyIds:
 			invKeyIds[value] = key
 		else:
diff -ruN o/lib/python/Plugins/Extensions/DVDBurn/DreamboxDVD.ddvdp.xml pc/lib/python/Plugins/Extensions/DVDBurn/DreamboxDVD.ddvdp.xml
--- o/lib/python/Plugins/Extensions/DVDBurn/DreamboxDVD.ddvdp.xml	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/DVDBurn/DreamboxDVD.ddvdp.xml	2025-07-11 16:39:46.968636240 +0300
@@ -7,7 +7,7 @@
 		titlesetmode="multi"
 		vmgm="vmgmdream.mpg"
 		output="dvd"
-		isopath="/hdd/movie/"
+		isopath="/media/hdd/movies/"
 		dataformat="iso9660_4"
 	/>
 	<titles> </titles>
diff -ruN o/lib/python/Plugins/Extensions/DVDBurn/DVDProject.py pc/lib/python/Plugins/Extensions/DVDBurn/DVDProject.py
--- o/lib/python/Plugins/Extensions/DVDBurn/DVDProject.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/DVDBurn/DVDProject.py	2025-07-11 16:39:46.969636186 +0300
@@ -20,7 +20,7 @@
 		cut_len = min(len(self.text), 40)
 		filename = (self.text.rstrip("/").rsplit("/", 1))[1][:cut_len] + " "
 		if self.allmarked:
-			mark = range(0, len(filename))
+			mark = list(range(0, len(filename)))
 		else:
 			mark = [filename]
 		return ("mtext"[1 - selected:], filename, mark)
@@ -59,7 +59,7 @@
 		list.append('<?xml version="1.0" encoding="utf-8" ?>\n')
 		list.append('<DreamDVDBurnerProject>\n')
 		list.append('\t<settings ')
-		for key, val in self.settings.dict().items():
+		for key, val in list(self.settings.dict().items()):
 			list.append(key + '="' + str(val.getValue()) + '" ')
 		list.append('/>\n')
 		list.append('\t<titles>\n')
@@ -70,12 +70,12 @@
 			list.append('</path>\n')
 			list.append('\t\t\t<properties ')
 			audiotracks = []
-			for key, val in title.properties.dict().items():
+			for key, val in list(title.properties.dict().items()):
 				if isinstance(val, ConfigSubList):
 					audiotracks.append('\t\t\t<audiotracks>\n')
 					for audiotrack in val:
 						audiotracks.append('\t\t\t\t<audiotrack ')
-						for subkey, subval in audiotrack.dict().items():
+						for subkey, subval in list(audiotrack.dict().items()):
 							audiotracks.append(subkey + '="' + str(subval.getValue()) + '" ')
 						audiotracks.append(' />\n')
 					audiotracks.append('\t\t\t</audiotracks>\n')
diff -ruN o/lib/python/Plugins/Extensions/DVDBurn/DVDToolbox.py pc/lib/python/Plugins/Extensions/DVDBurn/DVDToolbox.py
--- o/lib/python/Plugins/Extensions/DVDBurn/DVDToolbox.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/DVDBurn/DVDToolbox.py	2025-07-11 16:39:46.969636186 +0300
@@ -181,7 +181,7 @@
 
 
 class DVDformatTask(Task):
-	ERROR_ALREADYFORMATTED, ERROR_NOTWRITEABLE, ERROR_UNKNOWN = range(3)
+	ERROR_ALREADYFORMATTED, ERROR_NOTWRITEABLE, ERROR_UNKNOWN = list(range(3))
 
 	def __init__(self, job, extra_args=[]):
 		Task.__init__(self, job, ("RW medium format"))
diff -ruN o/lib/python/Plugins/Extensions/DVDBurn/Process.py pc/lib/python/Plugins/Extensions/DVDBurn/Process.py
--- o/lib/python/Plugins/Extensions/DVDBurn/Process.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/DVDBurn/Process.py	2025-07-11 16:39:46.969636186 +0300
@@ -209,7 +209,7 @@
 
 
 class MplexTask(Task):
-	ERROR_UNDERRUN, ERROR_UNKNOWN = range(2)
+	ERROR_UNDERRUN, ERROR_UNKNOWN = list(range(2))
 
 	def __init__(self, job, outputfile, inputfiles=None, demux_task=None, weighting=500):
 		Task.__init__(self, job, "Mux ES into PS")
@@ -331,7 +331,7 @@
 
 
 class BurnTask(Task):
-	ERROR_NOTWRITEABLE, ERROR_LOAD, ERROR_SIZE, ERROR_WRITE_FAILED, ERROR_DVDROM, ERROR_ISOFS, ERROR_FILETOOLARGE, ERROR_ISOTOOLARGE, ERROR_MINUSRWBUG, ERROR_UNKNOWN = range(10)
+	ERROR_NOTWRITEABLE, ERROR_LOAD, ERROR_SIZE, ERROR_WRITE_FAILED, ERROR_DVDROM, ERROR_ISOFS, ERROR_FILETOOLARGE, ERROR_ISOTOOLARGE, ERROR_MINUSRWBUG, ERROR_UNKNOWN = list(range(10))
 
 	def __init__(self, job, extra_args=[], tool="growisofs"):
 		Task.__init__(self, job, job.name)
diff -ruN o/lib/python/Plugins/Extensions/DVDBurn/ProjectSettings.py pc/lib/python/Plugins/Extensions/DVDBurn/ProjectSettings.py
--- o/lib/python/Plugins/Extensions/DVDBurn/ProjectSettings.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/DVDBurn/ProjectSettings.py	2025-07-11 16:39:46.969636186 +0300
@@ -169,9 +169,9 @@
 
 		self["config"].setList(self.list)
 		self.keydict = {}
-		for key, val in self.settings.dict().items():
+		for key, val in list(self.settings.dict().items()):
 			self.keydict[val] = key
-		for key, val in self.project.menutemplate.settings.dict().items():
+		for key, val in list(self.project.menutemplate.settings.dict().items()):
 			self.keydict[val] = key
 
 	def keyLeft(self):
diff -ruN o/lib/python/Plugins/Extensions/DVDBurn/TitleProperties.py pc/lib/python/Plugins/Extensions/DVDBurn/TitleProperties.py
--- o/lib/python/Plugins/Extensions/DVDBurn/TitleProperties.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/DVDBurn/TitleProperties.py	2025-07-11 16:39:46.969636186 +0300
@@ -151,10 +151,10 @@
 		syslang = syslanguage.getLanguage()[:2]
 		self.langdict = {}
 		self.choices = []
-		for key, val in LanguageCodes.items():
+		for key, val in list(LanguageCodes.items()):
 			if len(key) == 2:
 				self.langdict[key] = val[0]
-		for key, val in self.langdict.items():
+		for key, val in list(self.langdict.items()):
 			if key not in (syslang, 'en'):
 				self.langdict[key] = val
 				self.choices.append((key, val))
@@ -168,7 +168,7 @@
 		DVB_lang = DVB_lang.lower()
 		for word in ("stereo", "audio", "description", "2ch", "dolby digital"):
 			DVB_lang = DVB_lang.replace(word, "").strip()
-		for key, val in LanguageCodes.items():
+		for key, val in list(LanguageCodes.items()):
 			if DVB_lang.find(key.lower()) == 0:
 				if len(key) == 2:
 					return key
@@ -179,7 +179,7 @@
 					return key
 				else:
 					DVB_lang = (LanguageCodes[key])[0]
-		for key, val in self.langdict.items():
+		for key, val in list(self.langdict.items()):
 			if val == DVB_lang:
 				return key
 		return "nolang"
diff -ruN o/lib/python/Plugins/Extensions/MediaPlayer/plugin.py pc/lib/python/Plugins/Extensions/MediaPlayer/plugin.py
--- o/lib/python/Plugins/Extensions/MediaPlayer/plugin.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/MediaPlayer/plugin.py	2025-07-11 16:39:46.970636131 +0300
@@ -352,13 +352,11 @@
 		currPlay = self.session.nav.getCurrentService()
 		sTagAudioCodec = currPlay.info().getInfoString(iServiceInformation.sTagAudioCodec)
 		print("[__evAudioDecodeError] audio-codec %s can't be decoded by hardware" % (sTagAudioCodec))
-		self.session.open(MessageBox, _("This receiver cannot decode %s streams!") % sTagAudioCodec, type=MessageBox.TYPE_INFO, timeout=20)
 
 	def __evVideoDecodeError(self):
 		currPlay = self.session.nav.getCurrentService()
 		sTagVideoCodec = currPlay.info().getInfoString(iServiceInformation.sTagVideoCodec)
 		print("[__evVideoDecodeError] video-codec %s can't be decoded by hardware" % (sTagVideoCodec))
-		self.session.open(MessageBox, _("This receiver cannot decode %s streams!") % sTagVideoCodec, type=MessageBox.TYPE_INFO, timeout=20)
 
 	def __evPluginError(self):
 		currPlay = self.session.nav.getCurrentService()
diff -ruN o/lib/python/Plugins/Extensions/PicturePlayer/ui.py pc/lib/python/Plugins/Extensions/PicturePlayer/ui.py
--- o/lib/python/Plugins/Extensions/PicturePlayer/ui.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/Extensions/PicturePlayer/ui.py	2025-07-11 16:39:46.970636131 +0300
@@ -20,7 +20,7 @@
 
 
 config.pic = ConfigSubsection()
-config.pic.framesize = ConfigInteger(default=30, limits=(5, 99))
+config.pic.framesize = ConfigInteger(default=0, limits=(0, 99))
 config.pic.slidetime = ConfigInteger(default=10, limits=(1, 60))
 config.pic.resize = ConfigSelection(default="1", choices=[("0", _("simple")), ("1", _("better"))])
 config.pic.cache = ConfigYesNo(default=True)
@@ -500,7 +500,7 @@
 			self["pic"].instance.setPixmap(self.currPic[2].__deref__())
 			self.currPic = []
 
-			self.next()
+			next(self)
 			self.start_decode()
 
 	def finish_decode(self, picInfo=""):
@@ -523,7 +523,7 @@
 		self.picload.startDecode(self.filelist[self.index])
 		self["point"].show()
 
-	def next(self):
+	def __next__(self):
 		self.index += 1
 		if self.index > self.maxentry:
 			self.index = 0
diff -ruN o/lib/python/Plugins/SystemPlugins/DiseqcTester/plugin.py pc/lib/python/Plugins/SystemPlugins/DiseqcTester/plugin.py
--- o/lib/python/Plugins/SystemPlugins/DiseqcTester/plugin.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/DiseqcTester/plugin.py	2025-07-11 16:39:46.970636131 +0300
@@ -53,9 +53,9 @@
 				if transponder[2] == "pids_failed":
 					print(transponder[2], "-", transponder[3])
 			text += "The %d unsuccessful tuning attempts failed for the following reasons:\n" % countfailed
-			for reason in reasons.keys():
+			for reason in list(reasons.keys()):
 				text += "%s: %d transponders failed\n" % (reason, len(reasons[reason]))
-			for reason in reasons.keys():
+			for reason in list(reasons.keys()):
 				text += "\n"
 				text += "%s previous planes:\n" % reason
 				for transponder in reasons[reason]:
@@ -100,13 +100,13 @@
 		if self.type == self.TYPE_BYINDEX:
 			text += self.getTextualResultForIndex(self.index)
 		elif self.type == self.TYPE_BYORBPOS:
-			for index in self.results.keys():
+			for index in list(self.results.keys()):
 				if index[2] == self.orbpos:
 					text += self.getTextualResultForIndex(index)
 					text += "\n-----------------------------------------------------\n"
 		elif self.type == self.TYPE_ALL:
 			orderedResults = {}
-			for index in self.results.keys():
+			for index in list(self.results.keys()):
 				orbpos = index[2]
 				orderedResults[orbpos] = orderedResults.get(orbpos, [])
 				orderedResults[orbpos].append(index)
@@ -269,7 +269,7 @@
 		self.clearTransponder()
 		print("----------- fillTransponderList")
 		print("index:", self.currentlyTestedIndex)
-		keys = self.indexlist.keys()
+		keys = list(self.indexlist.keys())
 		if self.getContinueScanning():
 			print("index:", self.getTextualIndexRepresentation(self.currentlyTestedIndex))
 			for transponder in self.indexlist[self.currentlyTestedIndex]:
@@ -303,7 +303,7 @@
 			self["overall_progress"].setValue(self.myindex)
 			return self.randomkeys[0]
 		elif self.test_type == self.TEST_TYPE_COMPLETE:
-			keys = self.indexlist.keys()
+			keys = list(self.indexlist.keys())
 			print("keys:", keys)
 			successorindex = {}
 			for index in keys:
@@ -318,7 +318,7 @@
 			while not stop:
 				if currindex is None or len(successorindex[currindex]) == 0:
 					oldindex = currindex
-					for index in successorindex.keys():
+					for index in list(successorindex.keys()):
 						if len(successorindex[index]) > 0:
 							currindex = index
 							self.keylist.append(currindex)
@@ -370,7 +370,7 @@
 	# the algorithm checks, if we should continue scanning
 	def getContinueScanning(self):
 		if self.test_type == self.TEST_TYPE_QUICK or self.test_type == self.TEST_TYPE_RANDOM:
-			return (self.myindex < len(self.indexlist.keys()))
+			return (self.myindex < len(list(self.indexlist.keys())))
 		elif self.test_type == self.TEST_TYPE_COMPLETE:
 			return (self.myindex < len(self.keylist))
 
diff -ruN o/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py pc/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py
--- o/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py	2025-07-11 16:39:46.970636131 +0300
@@ -1,6 +1,6 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
-from __future__ import print_function
+
 from Plugins.Plugin import PluginDescriptor
 from Screens.Setup import Setup
 from Screens.InfoBar import InfoBar
@@ -346,7 +346,7 @@
 		stopFCCList = []
 		currentFCCList = self.fccmgr.getFCCServiceList()
 
-		for (sref, value) in currentFCCList.items():
+		for (sref, value) in list(currentFCCList.items()):
 			state = value[0]
 
 			if state == 2: # fcc_state_failed
@@ -409,7 +409,7 @@
 	def FCCStopAllServices(self):
 		self.FCCTimeoutTimerStop()
 		fccServiceList = self.fccmgr.getFCCServiceList()
-		for (sref, value) in fccServiceList.items():
+		for (sref, value) in list(fccServiceList.items()):
 			state = value[0]
 			if state != 1: # 1  : fcc_state_decoding
 				self.fccmgr.stopFCCService(eServiceReference(sref))
@@ -425,7 +425,7 @@
 		self.eventList = []
 
 	def FCCCheckNoLocked(self):
-		for (sref, value) in self.fccmgr.getFCCServiceList().items():
+		for (sref, value) in list(self.fccmgr.getFCCServiceList().items()):
 			state = value[0]
 			locked = value[1]
 			if state != 1 and locked == 0: # no fcc decoding and no locked
diff -ruN o/lib/python/Plugins/SystemPlugins/NetworkWizard/NetworkWizard.py pc/lib/python/Plugins/SystemPlugins/NetworkWizard/NetworkWizard.py
--- o/lib/python/Plugins/SystemPlugins/NetworkWizard/NetworkWizard.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/NetworkWizard/NetworkWizard.py	2025-07-11 16:39:46.971636077 +0300
@@ -126,7 +126,7 @@
 	def checkOldInterfaceState(self):
 		# disable up interface if it was originally down and config is unchanged.
 		if not self.originalInterfaceStateChanged:
-			for interface in self.originalInterfaceState.keys():
+			for interface in list(self.originalInterfaceState.keys()):
 				if interface == self.selectedInterface:
 					if not self.originalInterfaceState[interface]["up"]:
 						if iNetwork.checkforInterface(interface):
diff -ruN o/lib/python/Plugins/SystemPlugins/PositionerSetup/log.py pc/lib/python/Plugins/SystemPlugins/PositionerSetup/log.py
--- o/lib/python/Plugins/SystemPlugins/PositionerSetup/log.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/PositionerSetup/log.py	2025-07-11 16:39:46.971636077 +0300
@@ -6,8 +6,8 @@
 # because the log unit looks enough like a file!
 
 import sys
-from io import StringIO
 import threading
+from six.moves import cStringIO as StringIO
 
 logfile = None
 # Need to make our operations thread-safe.
diff -ruN o/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py pc/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py
--- o/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/SoftwareManager/BackupRestore.py	2025-07-11 16:39:46.971636077 +0300
@@ -112,7 +112,7 @@
 
 		self.selectedFiles = config.plugins.configurationbackup.backupdirs.value
 		defaultDir = '/'
-		inhibitDirs = ["/bin", "/boot", "/dev", "/autofs", "/lib", "/proc", "/sbin", "/sys", "/hdd", "/tmp", "/mnt", "/media"]
+		inhibitDirs = ["/bin", "/boot", "/dev", "/autofs", "/lib", "/proc", "/sbin", "/sys", "/media/hdd", "/tmp", "/mnt", "/media"]
 		self.filelist = MultiFileSelectList(self.selectedFiles, defaultDir, inhibitDirs=inhibitDirs)
 		self["checkList"] = self.filelist
 
diff -ruN o/lib/python/Plugins/SystemPlugins/Videomode/plugin.py pc/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
--- o/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/Videomode/plugin.py	2025-07-11 16:39:46.971636077 +0300
@@ -1,6 +1,6 @@
 from Screens.Screen import Screen
 from Plugins.Plugin import PluginDescriptor
-from Components.SystemInfo import BoxInfo
+from Components.SystemInfo import SystemInfo
 from Components.ConfigList import ConfigListScreen
 from Components.config import config, ConfigBoolean, ConfigNothing
 from Components.Label import Label
@@ -17,9 +17,10 @@
 		Screen.__init__(self, session)
 		# for the skin: first try VideoSetup, then Setup, this allows individual skinning
 		self.skinName = ["VideoSetup", "Setup"]
-		self.setTitle(_("A/V settings"))
+		self.setup_title = _("Xine A/V settings")
 		self.hw = hw
 		self.onChangedEntry = []
+		self.port = "DVI-PC"
 
 		# handle hotplug by re-creating setup
 		self.onShow.append(self.startHotplug)
@@ -52,111 +53,86 @@
 	def createSetup(self):
 		level = config.usage.setup_level.index
 
-		self.list = [
-			(_("Video output"), config.av.videoport, _("Configures which video output connector will be used."))
-		]
-
-		# if we have modes for this port:
-		if config.av.videoport.value in config.av.videomode:
-			# add mode- and rate-selection:
-			self.list.append((pgettext("Video output mode", "Mode"), config.av.videomode[config.av.videoport.value], _("Configure the video output mode (or resolution).")))
-			if config.av.videomode[config.av.videoport.value].value == 'PC':
-				self.list.append((_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the screen resolution in PC output mode.")))
-			else:
-				self.list.append((_("Refresh rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the refresh rate of the screen.")))
-
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			mode = None
-		else:
-			mode = config.av.videomode[port].value
-
-		# some modes (720p, 1080i) are always widescreen. Don't let the user select something here, "auto" is not what he wants.
-		force_wide = self.hw.isWidescreenMode(port, mode)
-
-		if not force_wide:
-			self.list.append((_("Aspect ratio"), config.av.aspect, _("Configure the aspect ratio of the screen.")))
-
-		if force_wide or config.av.aspect.value in ("16_9", "16_10"):
-			self.list.extend((
-				(_("Display 4:3 content as"), config.av.policy_43, _("When the content has an aspect ratio of 4:3, choose whether to scale/stretch the picture.")),
-				(_("Display >16:9 content as"), config.av.policy_169, _("When the content has an aspect ratio of 16:9, choose whether to scale/stretch the picture."))
-			))
-		elif config.av.aspect.value == "4_3":
-			self.list.append((_("Display 16:9 content as"), config.av.policy_169, _("When the content has an aspect ratio of 16:9, choose whether to scale/stretch the picture.")))
-
-		if config.av.videoport.value == "DVI":
-			if level >= 1:
-				self.list.append((_("Allow unsupported modes"), config.av.edid_override, _("When selected this allows video modes to be selected even if they are not reported as supported.")))
-				if BoxInfo.getItem("HasBypassEdidChecking"):
-					self.list.append((_("Bypass HDMI EDID checking"), config.av.bypassEdidChecking, _("Configure if the HDMI EDID checking should be bypassed as this might solve issue with some TVs.")))
-				if BoxInfo.getItem("HasColorspace"):
-					self.list.append((_("HDMI Colorspace"), config.av.hdmicolorspace, _("This option allows you to configure the Colorspace from Auto to RGB")))
-				if BoxInfo.getItem("HasColordepth"):
-					self.list.append((_("HDMI Colordepth"), config.av.hdmicolordepth, _("This option allows you to configure the Colordepth for UHD")))
-				if BoxInfo.getItem("HasColorimetry"):
-					self.list.append((_("HDMI Colorimetry"), config.av.hdmicolorimetry, _("This option allows you to configure the Colorimetry for HDR.")))
-				if BoxInfo.getItem("HasHdrType"):
-					self.list.append((_("HDMI HDR Type"), config.av.hdmihdrtype, _("This option allows you to configure the HDR type.")))
-				if BoxInfo.getItem("HasHDMIpreemphasis"):
-					self.list.append((_("Use HDMI pre-emphasis"), config.av.hdmipreemphasis, _("This option can be useful for long HDMI cables.")))
-				if BoxInfo.getItem("HDRSupport"):
-					self.list.append((_("HLG support"), config.av.hlg_support, _("This option allows you to force the HLG modes for UHD")))
-					self.list.append((_("HDR10 support"), config.av.hdr10_support, _("This option allows you to force the HDR10 modes for UHD")))
-					self.list.append((_("Allow 12bit"), config.av.allow_12bit, _("This option allows you to enable or disable the 12 bit color mode")))
-					self.list.append((_("Allow 10bit"), config.av.allow_10bit, _("This option allows you to enable or disable the 10 bit color mode")))
-
-		if config.av.videoport.value == "Scart":
-			self.list.append((_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
-			if level >= 1:
-				self.list.append((_("WSS on 4:3"), config.av.wss, _("When enabled, content with an aspect ratio of 4:3 will be stretched to fit the screen.")))
-				if BoxInfo.getItem("ScartSwitch"):
-					self.list.append((_("Auto scart switching"), config.av.vcrswitch, _("When enabled, your receiver will detect activity on the VCR SCART input.")))
+		self.list = [ ]
+		self.list.append((_("Refresh Rate"), config.av.videorate, _("Select Xine refresh rate.")))
+		self.list.append((_("Aspect Ratio"), config.av.aspect, _("Select Xine aspect ratio.")))
+
+		if config.av.aspect.value != "auto":
+			self.list.append((_("Display 4:3 content as"), config.av.policy_43, _("Select 4:3 display zoom method.")))
+			if config.av.policy_43.value == "zoom":
+				self.list.extend((
+					(_("Zoom 4:3 X"), config.pc.image4_3_zoom_x),
+					(_("Zoom 4:3 Y"), config.pc.image4_3_zoom_y)
+				))
+
+			self.list.append((_("Display 16:9 content as"), config.av.policy_169, _("Select 16:9 display zoom method.")))
+			if config.av.policy_169.value == "zoom":
+				self.list.extend((
+					(_("Zoom 16:9 X"), config.pc.image16_9_zoom_x),
+					(_("Zoom 16:9 Y"), config.pc.image16_9_zoom_y)
+				))
+
+		self.list.append((_("Deinterlacing"), config.av.deinterlace, _("Using Xine deinterlacing.")))
+		if config.av.deinterlace.value == "1":
+			self.list.append((_("SD deinterlace method"), config.av.deinterlace_sd, _("Select Xine SD deinterlace method.")))
+			self.list.append((_("HD deinterlace method"), config.av.deinterlace_hd, _("Select Xine HD deinterlace method.")))
+
+		self.list.append((_("SD sharpness"), config.pc.sd_sharpness, _("Adjust Xine SD sharpness.")))
+		self.list.append((_("SD noise reduction"), config.pc.sd_noise, _("Adjust Xine SD noise reduction.")))
+
+		self.list.append((_("Fullscreen default"), config.pc.default_fullscreen, _("Configure whether to turn on full screen mode on start Enigma2.")))
+
+		self.list.append((_("TV resolution width"), config.pc.initial_window_width, _("Adjust the width resolution.")))
+		self.list.append((_("TV resolution height"), config.pc.initial_window_height, _("Adjust the height resolution.")))
+
+		self.list.append((_("HEVC prebuffer metronome"), config.pc.prebuffer_metronom_hevc, _("Adjust Xine HEVC prebuffer metronome.")))
+		self.list.append((_("AVC prebuffer metronome"), config.pc.prebuffer_metronom_avc, _("Adjust Xine AVC prebuffer metronome.")))
+		self.list.append((_("MPEG2 prebuffer metronome"), config.pc.prebuffer_metronom_mpeg2, _("Adjust Xine MPEG2 prebuffer metronome.")))
 
 		if level >= 1:
 			self.list.append((_("Audio volume step size"), config.av.volume_stepsize, _("Configure the general audio volume step size (limit 1-10).")))
-			if BoxInfo.getItem("CanDownmixAC3"):
+			if SystemInfo["CanDownmixAC3"]:
 				self.list.append((_("AC3 downmix"), config.av.downmix_ac3, _("Configure whether multi channel sound tracks should be downmixed to stereo.")))
-			if BoxInfo.getItem("CanDownmixDTS"):
+			if SystemInfo["CanDownmixDTS"]:
 				self.list.append((_("DTS downmix"), config.av.downmix_dts, _("Configure whether multi channel sound tracks should be downmixed to stereo.")))
-			if BoxInfo.getItem("CanDownmixAAC"):
+			if SystemInfo["CanDownmixAAC"]:
 				self.list.append((_("AAC downmix"), config.av.downmix_aac, _("Configure whether multi channel sound tracks should be downmixed to stereo.")))
-			if BoxInfo.getItem("CanDownmixAACPlus"):
+			if SystemInfo["CanDownmixAACPlus"]:
 				self.list.append((_("AAC+ downmix"), config.av.downmix_aacplus, _("Choose whether multi channel aac+ sound tracks should be downmixed to stereo.")))
-			if BoxInfo.getItem("CanAC3Transcode"):
+			if SystemInfo["CanAC3Transcode"]:
 				self.list.append((_("AC3 transcoding"), config.av.transcodeac3plus, _("Choose whether AC3 sound tracks should be transcoded.")))
-			if BoxInfo.getItem("CanAACTranscode"):
+			if SystemInfo["CanAACTranscode"]:
 				self.list.append((_("AAC transcoding"), config.av.transcodeaac, _("Choose whether AAC sound tracks should be transcoded.")))
-			if BoxInfo.getItem("CanDTSHD"):
+			if SystemInfo["CanDTSHD"]:
 				self.list.append((_("DTS-HD(HR/MA) downmix"), config.av.dtshd, _("Choose whether multi channel DTS-HD(HR/MA) sound tracks should be downmixed or transcoded.")))
-			if BoxInfo.getItem("CanWMAPRO"):
+			if SystemInfo["CanWMAPRO"]:
 				self.list.append((_("WMA Pro downmix"), config.av.wmapro, _("Choose whether WMA Pro sound tracks should be downmixed.")))
-			if BoxInfo.getItem("HasMultichannelPCM"):
+			if SystemInfo["HasMultichannelPCM"]:
 				self.list.append((_("Multichannel PCM"), config.av.multichannel_pcm, _("Configure whether multi channel PCM sound should be enabled.")))
 			self.list.extend((
 				(_("General AC3 delay"), config.av.generalAC3delay, _("Configure the general audio delay of Dolby Digital sound tracks.")),
 				(_("General PCM delay"), config.av.generalPCMdelay, _("Configure the general audio delay of stereo sound tracks."))
 			))
-			if BoxInfo.getItem("CanBTAudio"):
+			if SystemInfo["CanBTAudio"]:
 				self.list.append((_("Enable bluetooth audio"), config.av.btaudio, _("This option allows you to switch audio to bluetooth speakers.")))
-				if BoxInfo.getItem("CanBTAudioDelay") and config.av.btaudio.value != "off":
+				if SystemInfo["CanBTAudioDelay"] and config.av.btaudio.value != "off":
 					self.list.append((_("General bluetooth audio delay"), config.av.btaudiodelay, _("This option configures the general audio delay for bluetooth speakers.")))
-			if BoxInfo.getItem("HasAutoVolume") or BoxInfo.getItem("HasAutoVolumeLevel"):
-				self.list.append((_("Audio auto volume level"), BoxInfo.getItem("HasAutoVolume") and config.av.autovolume or config.av.autovolumelevel, _("This option allows you can to set the auto volume level.")))
-			if BoxInfo.getItem("Has3DSurround"):
+			if SystemInfo["HasAutoVolume"] or SystemInfo["HasAutoVolumeLevel"]:
+				self.list.append((_("Audio auto volume level"), SystemInfo["HasAutoVolume"] and config.av.autovolume or config.av.autovolumelevel, _("This option allows you can to set the auto volume level.")))
+			if SystemInfo["Has3DSurround"]:
 				self.list.append((_("3D surround"), config.av.surround_3d, _("This option allows you to enable 3D surround sound.")))
-				if BoxInfo.getItem("Has3DSpeaker") and config.av.surround_3d.value != "none":
+				if SystemInfo["Has3DSpeaker"] and config.av.surround_3d.value != "none":
 					self.list.append((_("3D surround speaker position"), config.av.speaker_3d, _("This option allows you to change the virtuell loadspeaker position.")))
-			if BoxInfo.getItem("Has3DSurroundSpeaker"):
+			if SystemInfo["Has3DSurroundSpeaker"]:
 				self.list.append((_("3D surround speaker position"), config.av.surround_3d_speaker, _("This option allows you to disable or change the virtuell loadspeaker position.")))
-				if BoxInfo.getItem("Has3DSurroundSoftLimiter") and config.av.surround_3d_speaker.value != "disabled":
+				if SystemInfo["Has3DSurroundSoftLimiter"] and config.av.surround_3d_speaker.value != "disabled":
 					self.list.append((_("3D surround softlimiter"), config.av.surround_softlimiter_3d, _("This option allows you to enable 3D surround softlimiter.")))
 
-		if BoxInfo.getItem("CanChangeOsdAlpha"):
-			self.list.append((_("OSD transparency"), config.av.osd_alpha, _("Configure the transparency of the OSD.")))
-
-		if not isinstance(config.av.scaler_sharpness, ConfigNothing):
-			self.list.append((_("Scaler sharpness"), config.av.scaler_sharpness, _("Configure the sharpness of the video scaling.")))
+		self.list.append((_("Sound mode"), config.av.sound_mode, _("Select audio device as card and device number. To show your audio cards, type aplay -l in the terminal.")))
+		if config.av.sound_mode.value == "1":
+			self.list.append((_("Sound card"), config.av.sound_card))
+			self.list.append((_("Sound device"), config.av.sound_device))
+			self.list.append((_("Sound output"), config.av.sound_output))
 
 		self["config"].list = self.list
 
@@ -168,7 +144,6 @@
 
 	def confirm(self, confirmed):
 		if not confirmed:
-			config.av.videoport.value = self.last_good[0]
 			config.av.videomode[self.last_good[0]].value = self.last_good[1]
 			config.av.videorate[self.last_good[1]].value = self.last_good[2]
 			self.hw.setMode(*self.last_good)
@@ -176,17 +151,15 @@
 			self.keySave()
 
 	def grabLastGoodMode(self):
-		port = config.av.videoport.value
-		mode = config.av.videomode[port].value
-		rate = config.av.videorate[mode].value
-		self.last_good = (port, mode, rate)
+		rate = config.av.videorate.value
+		self.last_good = (self.port, rate)
 
 	def apply(self):
-		port = config.av.videoport.value
-		mode = config.av.videomode[port].value
-		rate = config.av.videorate[mode].value
-		if (port, mode, rate) != self.last_good:
-			self.hw.setMode(port, mode, rate)
+		print("Apply")
+		rate = config.av.videorate.value
+		video_hw.updateAspect(None)
+		if (self.port, rate) != self.last_good:
+			self.hw.setMode(self.port, rate)
 			from Screens.MessageBox import MessageBox
 			self.session.openWithCallback(self.confirm, MessageBox, _("Is this video mode ok?"), MessageBox.TYPE_YESNO, timeout=20, default=False)
 		else:
@@ -205,21 +178,18 @@
 
 	def hotplug(self, what):
 		print("hotplug detected on port '%s'" % (what))
-		port = config.av.videoport.value
-		mode = config.av.videomode[port].value
-		rate = config.av.videorate[mode].value
-
-		if not self.hw.isModeAvailable(port, mode, rate):
-			print("mode %s/%s/%s went away!" % (port, mode, rate))
-			modelist = self.hw.getModeList(port)
+		rate = config.av.videorate.value
+
+		if not self.hw.isModeAvailable(self.port, mode, rate):
+			print("mode %s/%s/%s went away!" % (self.port, mode, rate))
+			modelist = self.hw.getModeList(self.port)
 			if not len(modelist):
 				print("sorry, no other mode is available (unplug?). Doing nothing.")
 				return
 			mode = modelist[0][0]
 			rate = modelist[0][1]
-			print("setting %s/%s/%s" % (port, mode, rate))
-			self.hw.setMode(port, mode, rate)
-
+			print("setting %s/%s/%s" % (self.port, mode, rate))
+			self.hw.setMode(self.port, mode, rate)
 
 hotplug = None
 
@@ -252,11 +222,10 @@
 
 
 def startSetup(menuid):
-	if menuid != "video":
+	if menuid != "system":
 		return []
 
-	return [(_("A/V settings"), videoSetupMain, "av_setup", 40)]
-
+	return [(_("Xine A/V settings"), videoSetupMain, "av_setup", 40)]
 
 def VideoWizard(*args, **kwargs):
 	from Plugins.SystemPlugins.Videomode.VideoWizard import VideoWizard
diff -ruN o/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py pc/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
--- o/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2025-07-11 16:39:11.176577838 +0300
+++ pc/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py	2025-07-11 16:39:46.972636023 +0300
@@ -1,7 +1,9 @@
+from enigma import eTimer, eAVSwitch
 from Components.config import config, ConfigSelection, ConfigSubDict, ConfigYesNo
-from Components.SystemInfo import BoxInfo
+from Components.SystemInfo import SystemInfo
 from Tools.CList import CList
 from Tools.HardwareInfo import HardwareInfo
+from Components.AVSwitch import AVSwitch
 import os
 
 # The "VideoHardware" is the interface to /proc/stb/video.
@@ -9,194 +11,93 @@
 # available and preferred modes, as well as handling the currently
 # selected mode. No other strict checking is done.
 
-config.av.edid_override = ConfigYesNo(default=True)
-
-
 class VideoHardware:
-	rates = {} # high-level, use selectable modes.
-
-	modes = {}  # a list of (high-level) modes for a certain port.
-
-	rates["PAL"] = {"50Hz": {50: "pal"},
-								"60Hz": {60: "pal60"},
-								"multi": {50: "pal", 60: "pal60"}}
-
-	rates["NTSC"] = {"60Hz": {60: "ntsc"}}
-
-	rates["Multi"] = {"multi": {50: "pal", 60: "ntsc"}}
-
-	rates["480i"] = {"60Hz": {60: "480i"}}
-
-	rates["576i"] = {"50Hz": {50: "576i"}}
-
-	rates["480p"] = {"60Hz": {60: "480p"}}
-
-	rates["576p"] = {"50Hz": {50: "576p"}}
-
-	rates["720p"] = {"50Hz": {50: "720p50"},
-								"60Hz": {60: "720p"},
-								"multi": {50: "720p50", 60: "720p"},
-								"auto": {50: "720p50", 60: "720p", 24: "720p24"}}
-
-	rates["1080i"] = {"50Hz": {50: "1080i50"},
-								"60Hz": {60: "1080i"},
-								"multi": {50: "1080i50", 60: "1080i"},
-								"auto": {50: "1080i50", 60: "1080i", 24: "1080p24"}}
-
-	rates["1080p"] = {"50Hz": {50: "1080p50"},
-								"60Hz": {60: "1080p"},
-								"multi": {50: "1080p50", 60: "1080p"},
-								"auto": {50: "1080p50", 60: "1080p", 24: "1080p24"}}
-
-	rates["2160p30"] = {"25Hz": {50: "2160p25"},
-								"30Hz": {60: "2160p30"},
-								"multi": {50: "2160p25", 60: "2160p30"},
-								"auto": {50: "2160p25", 60: "2160p30", 24: "2160p24"}}
-
-	rates["2160p"] = {"50Hz": {50: "2160p50"},
-								"60Hz": {60: "2160p"},
-								"multi": {50: "2160p50", 60: "2160p"},
-								"auto": {50: "2160p50", 60: "2160p", 24: "2160p24"}}
-
-	rates["PC"] = {
-		"1024x768": {60: "1024x768"}, # not possible on DM7025
-		"800x600": {60: "800x600"},  # also not possible
-		"720x480": {60: "720x480"},
-		"720x576": {60: "720x576"},
-		"1280x720": {60: "1280x720"},
-		"1280x720 multi": {50: "1280x720_50", 60: "1280x720"},
-		"1920x1080": {60: "1920x1080"},
-		"1920x1080 multi": {50: "1920x1080", 60: "1920x1080_50"},
-		"1280x1024": {60: "1280x1024"},
-		"1366x768": {60: "1366x768"},
-		"1366x768 multi": {50: "1366x768", 60: "1366x768_50"},
-		"1280x768": {60: "1280x768"},
-		"640x480": {60: "640x480"}
+	rates = {
+		"24": _("24Hz"),
+		"50": _("50Hz"),
+		"60": _("60Hz"),
 	}
 
-	if BoxInfo.getItem("HasScart"):
-		modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	elif BoxInfo.getItem("HasComposite"):
-		modes["RCA"] = ["576i", "PAL", "NTSC", "Multi"]
-	if BoxInfo.getItem("HasYPbPr"):
-		modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	if BoxInfo.getItem("Has2160p"):
-		modes["DVI"] = ["720p", "1080p", "2160p", "1080i", "576p", "480p", "576i", "480i"]
-	else:
-		modes["DVI"] = ["720p", "1080p", "2160p", "2160p30", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
+	deinterlace_modes = {
+		"0": _("bob"),
+		"1": _("half temporal"),
+		"2": _("half temporal spatial"),
+		"3": _("temporal"),
+		"4": _("temporal spatial"),
+	}
 
 	def getOutputAspect(self):
 		ret = (16, 9)
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print("[VideoHardware] current port not available in getOutputAspect!!! force 16:9")
-		else:
-			mode = config.av.videomode[port].value
-			force_widescreen = self.isWidescreenMode(port, mode)
-			is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
-			is_auto = config.av.aspect.value == "auto"
-			if is_widescreen:
-				if force_widescreen:
-					pass
-				else:
-					aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-					if aspect == "16:10":
-						ret = (16, 10)
-			elif is_auto:
-				try:
-					aspect_str = open("/proc/stb/vmpeg/0/aspect", "r").read()
-					if aspect_str == "1": # 4:3
-						ret = (4, 3)
-				except IOError:
-					pass
-			else:  # 4:3
-				ret = (4, 3)
+		is_widescreen = config.av.aspect.value in ("16_9", "16_10")
+		is_auto = config.av.aspect.value == "auto"
+		if is_widescreen:
+			aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
+			if aspect == "16:10":
+				ret = (16, 10)
+		elif is_auto:
+			try:
+				aspect_str = open("/proc/stb/vmpeg/0/aspect", "r").read()
+				if aspect_str == "1": # 4:3
+					ret = (4, 3)
+			except IOError:
+				pass
+		else:  # 4:3
+			ret = (4, 3)
 		return ret
 
 	def __init__(self):
-		self.last_modes_preferred = []
 		self.on_hotplug = CList()
-		self.current_mode = None
-		self.current_port = None
-
-		self.readAvailableModes()
-		self.readPreferredModes()
-		self.widescreen_modes = set(["720p", "1080i", "1080p", "2160p", "2160p30"]).intersection(*[self.modes_available])
-
-		if "DVI-PC" in self.modes and not self.getModeList("DVI-PC"):
-			print("[VideoHardware] remove DVI-PC because of not existing modes")
-			del self.modes["DVI-PC"]
-		if "Scart" in self.modes and not self.getModeList("Scart"):
-			print("[VideoHardware] remove Scart because of not existing modes")
-			del self.modes["Scart"]
-
 		self.createConfig()
 
-		# take over old AVSwitch component :)
-		from Components.AVSwitch import AVSwitch
 		config.av.aspectratio.notifiers = []
 		config.av.tvsystem.notifiers = []
-		config.av.wss.notifiers = []
 		AVSwitch.getOutputAspect = self.getOutputAspect
-
 		config.av.aspect.addNotifier(self.updateAspect)
-		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
 		config.av.policy_43.addNotifier(self.updateAspect)
 
-	def readAvailableModes(self):
-		try:
-			modes = open("/proc/stb/video/videomode_choices").read()[:-1]
-		except IOError:
-			print("[VideoHardware] couldn't read available videomodes.")
-			self.modes_available = []
-			return
-		self.modes_available = modes.split(' ')
-
-	def readPreferredModes(self):
-		if config.av.edid_override.value == False:
-			try:
-				modes = open("/proc/stb/video/videomode_preferred").read()[:-1]
-				self.modes_preferred = modes.split(' ')
-			except IOError:
-				print("[VideoHardware] reading preferred modes failed, using all video modes")
-				self.modes_preferred = self.modes_available
-
-			if len(self.modes_preferred) <= 1:
-				self.modes_preferred = self.modes_available
-				print("[VideoHardware] reading preferred modes is empty, using all video modes")
-		else:
-			self.modes_preferred = self.modes_available
-			print("[VideoHardware] reading preferred modes override, using all video modes")
-
-		self.last_modes_preferred = self.modes_preferred
-
-	# check if a high-level mode with a given rate is available.
-	def isModeAvailable(self, port, mode, rate):
-		rate = self.rates[mode][rate]
-		for mode in rate.values():
-			if port == "DVI":
-				if mode not in self.modes_preferred:
-					return False
-			else:
-				if mode not in self.modes_available:
-					return False
-		return True
+		config.av.deinterlace    = ConfigSelection(choices = {"0": _("Off"), "1": _("On")}, default="0")
+		config.av.deinterlace_sd = ConfigSelection(choices = self.deinterlace_modes, default="4")
+		config.av.deinterlace_hd = ConfigSelection(choices = self.deinterlace_modes, default="3")
+		config.av.deinterlace.addNotifier(self.updateDeinterlace)
+		config.av.deinterlace_sd.addNotifier(self.updateDeinterlace)
+		config.av.deinterlace_hd.addNotifier(self.updateDeinterlace)
+
+		config.av.sound_mode    = ConfigSelection(choices = {"0": _("default"), "1": _("custom")}, default="0")
+		config.av.sound_card    = ConfigSelection(choices = {"0": _("Card 0"), "1": _("Card 1"), "2": _("Card 2"), "3": _("Card 3")}, default="0")
+		config.av.sound_device  = ConfigSelection(choices = {"0": _("Device 0"), "1": _("Device 1"), "2": _("Device 2"), "3": _("Device 3"),  "4": _("Device 4"), "5": _("Device 5"), "6": _("Device 6"),  "7": _("Device 7"), "8": _("Device 8"), "9": _("Device 9")}, default="0")
+		config.av.sound_output  = ConfigSelection(choices = {"1": _("Stereo 2.0"), "8": _("Surround 5.1"), "11": _("Surround 7.1"), "12": _("Pass Through")}, default="1")
+		config.av.sound_mode.addNotifier(self.updateSoundMode)
+		config.av.sound_card.addNotifier(self.updateSoundMode)
+		config.av.sound_device.addNotifier(self.updateSoundMode)
+		config.av.sound_output.addNotifier(self.updateSoundMode)
+
+		config.pc.image4_3_zoom_x.addNotifier(self.updateAspect)
+		config.pc.image4_3_zoom_y.addNotifier(self.updateAspect)
+		config.pc.image16_9_zoom_x.addNotifier(self.updateAspect)
+		config.pc.image16_9_zoom_y.addNotifier(self.updateAspect)
+
+		config.pc.sd_sharpness = ConfigSelection(choices = {"0": _("Off"), "1": _("On")}, default="0")
+		config.pc.sd_noise     = ConfigSelection(choices = {"0": _("Off"), "1": _("On")}, default="0")
+		config.pc.sd_sharpness.addNotifier(self.updateSDfeatures)
+		config.pc.sd_noise.addNotifier(self.updateSDfeatures)
+		config.pc.initial_window_width = ConfigSelection(choices = {"0": _("0"), "720": _("720"), "1280": _("1280"), "1366": _("1366"), "1600": _("1600"), "1680": _("1680"), "1920": _("1920")}, default="0")
+		config.pc.initial_window_height = ConfigSelection(choices = {"0": _("0"), "576": _("576"), "720": _("720"), "768": _("768"), "1050": _("1050"), "1080": _("1080"), "1200": _("1200")}, default="0")
+
+		config.pc.prebuffer_metronom_hevc = ConfigSelection(choices = {"180000": _("2.0"), "189000": _("2.1"), "198000": _("2.2"), "207000": _("2.3"), "216000": _("2.4"), "225000": _("2.5")}, default="216000")
+		config.pc.prebuffer_metronom_avc = ConfigSelection(choices = {"126000": _("1.4"), "135000": _("1.5"), "144000": _("1.6"), "153000": _("1.7"), "162000": _("1.8"), "171000": _("1.9")}, default="162000")
+		config.pc.prebuffer_metronom_mpeg2 = ConfigSelection(choices = {"90000": _("1"), "99000": _("1.1"), "108000": _("1.2"), "117000": _("1.3"), "126000": _("1.4"), "135000": _("1.5")}, default="126000")
+
+		config.pc.prebuffer_metronom_hevc.addNotifier(self.updateBufMetronom)
+		config.pc.prebuffer_metronom_avc.addNotifier(self.updateBufMetronom)
+		config.pc.prebuffer_metronom_mpeg2.addNotifier(self.updateBufMetronom)
 
-	def isWidescreenMode(self, port, mode):
-		return mode in self.widescreen_modes
-
-	def setMode(self, port, mode, rate, force=None):
-		print("[VideoHardware] setMode - port:", port, "mode:", mode, "rate:", rate)
+	def setMode(self, port, rate, force=None):
+		print("[VideoHardware] setMode - port:", port, "rate:", rate)
 		# we can ignore "port"
-		self.current_mode = mode
-		self.current_port = port
-		modes = self.rates[mode][rate]
-
-		mode_50 = modes.get(50)
-		mode_60 = modes.get(60)
-		mode_24 = modes.get(24)
+		mode_50 = self.rates.get(50)
+		mode_60 = self.rates.get(60)
+		mode_24 = self.rates.get(24)
 
 		if mode_50 is None or force == 60:
 			mode_50 = mode_60
@@ -207,116 +108,26 @@
 			if force == 50:
 				mode_24 = mode_50
 
-		try:
-			open("/proc/stb/video/videomode_50hz", "w").write(mode_50)
-			open("/proc/stb/video/videomode_60hz", "w").write(mode_60)
-		except IOError:
-			try:
-				# fallback if no possibility to setup 50/60 hz mode
-				open("/proc/stb/video/videomode", "w").write(mode_50)
-			except IOError:
-				print("[VideoHardware] setting videomode failed.")
-
-		try:
-			open("/etc/videomode", "w").write(mode_50) # use 50Hz mode (if available) for booting
-		except IOError:
-			print("[VideoHardware] writing initial videomode to /etc/videomode failed.")
-
-		if BoxInfo.getItem("Has24hz"):
-			try:
-				open("/proc/stb/video/videomode_24hz", "w").write(mode_24)
-			except IOError:
-				print("[VideoHardware] cannot open /proc/stb/video/videomode_24hz")
-
+		self.updateDeinterlace(None)
+		self.updateSDfeatures(None)
+		self.updateBufMetronom(None)
 		self.updateAspect(None)
 
 	def saveMode(self, port, mode, rate):
 		print("[VideoHardware] saveMode", port, mode, rate)
-		config.av.videoport.value = port
-		config.av.videoport.save()
-		if port in config.av.videomode:
-			config.av.videomode[port].value = mode
-			config.av.videomode[port].save()
-		if mode in config.av.videorate:
-			config.av.videorate[mode].value = rate
-			config.av.videorate[mode].save()
-
-	def isPortAvailable(self, port):
-		# fixme
-		return True
-
-	def isPortUsed(self, port):
-		if port == "DVI":
-			self.readPreferredModes()
-			return len(self.modes_preferred) != 0
-		else:
-			return True
-
-	def getPortList(self):
-		return [port for port in self.modes if self.isPortAvailable(port)]
 
-	# get a list with all modes, with all rates, for a given port.
-	def getModeList(self, port):
-		print("[VideoHardware] getModeList for port", port)
-		res = []
-		for mode in self.modes[port]:
-			# list all rates which are completely valid
-			rates = [rate for rate in self.rates[mode] if self.isModeAvailable(port, mode, rate)]
-
-			# if at least one rate is ok, add this mode
-			if len(rates):
-				res.append((mode, rates))
-		return res
+		config.av.videorate.value = rate
+		config.av.videorate.save()
 
 	def createConfig(self, *args):
 		has_hdmi = HardwareInfo().has_hdmi()
 		lst = []
 
-		config.av.videomode = ConfigSubDict()
-		config.av.videorate = ConfigSubDict()
-
-		# create list of output ports
-		portlist = self.getPortList()
-		for port in portlist:
-			descr = port
-			if descr == "DVI" and has_hdmi:
-				descr = "HDMI"
-			elif descr == "DVI-PC" and has_hdmi:
-				descr = "HDMI-PC"
-			if "HDMI" in descr:
-				lst.insert(0, (port, descr))
-			else:
-				lst.append((port, descr))
-
-			# create list of available modes
-			modes = self.getModeList(port)
-			if len(modes):
-				config.av.videomode[port] = ConfigSelection(choices=[mode for (mode, rates) in modes])
-			for (mode, rates) in modes:
-				ratelist = []
-				for rate in rates:
-					if rate == "auto":
-						if BoxInfo.getItem("Has24hz"):
-							ratelist.append((rate, mode == "2160p30" and "auto (25Hz/30Hz/24Hz)" or "auto (50Hz/60Hz/24Hz)"))
-					else:
-						ratelist.append((rate, rate == "multi" and (mode == "2160p30" and "multi (25Hz/30Hz)" or "multi (50Hz/60Hz)") or rate))
-				config.av.videorate[mode] = ConfigSelection(choices=ratelist)
-		config.av.videoport = ConfigSelection(default="DVI", choices=lst)
+		config.av.videorate = ConfigSelection(choices = self.rates)
 
 	def setConfiguredMode(self):
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print("[VideoHardware] current port not available, not setting videomode")
-			return
-
-		mode = config.av.videomode[port].value
-
-		if mode not in config.av.videorate:
-			print("[VideoHardware] current mode not available, not setting videomode")
-			return
-
-		rate = config.av.videorate[mode].value
-		self.setMode(port, mode, rate)
+		rate = config.av.videorate.value
+		self.setMode("DVI-PC", rate)
 
 	def updateAspect(self, cfgelement):
 		# determine aspect = {any,4:3,16:9,16:10}
@@ -339,54 +150,58 @@
 		#     nonlinear       use nonlinear
 		#     scale           use bestfit
 
-		port = config.av.videoport.value
-		if port not in config.av.videomode:
-			print("[VideoHardware] current port not available, not setting videomode")
-			return
-		mode = config.av.videomode[port].value
-
-		force_widescreen = self.isWidescreenMode(port, mode)
-
-		is_widescreen = force_widescreen or config.av.aspect.value in ("16_9", "16_10")
-		is_auto = config.av.aspect.value == "auto"
-		policy2 = "policy" # use main policy
-
-		if is_widescreen:
-			if force_widescreen:
-				aspect = "16:9"
-			else:
-				aspect = {"16_9": "16:9", "16_10": "16:10"}[config.av.aspect.value]
-			policy_choices = {"pillarbox": "panscan", "panscan": "letterbox", "nonlinear": "nonlinear", "scale": "bestfit", "full": "full", "auto": "auto"}
-			policy = policy_choices[config.av.policy_43.value]
-			policy2_choices = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit", "full": "full", "auto": "auto"}
-			policy2 = policy2_choices[config.av.policy_169.value]
-		elif is_auto:
-			aspect = "any"
-			if "auto" in config.av.policy_43.choices:
-				policy = "auto"
-			else:
-				policy = "bestfit"
+		valstr = config.av.aspect.value
+		if valstr == "auto":
+			val = 0
+		elif valstr == "4_3":
+			val = 2
+		elif valstr == "16_9":
+			val = 3
+		elif valstr == "16_10":
+			val = 3
+		eAVSwitch.getInstance().setAspectRatio(val)
+
+		valstr = config.av.policy_43.value
+		if valstr == "zoom":
+			val = 4
+		elif valstr == "pillarbox":
+			val = 3
+		elif valstr == "panscan":
+			val = 2
+		elif valstr == "nonlinear":
+			val = 1
 		else:
-			aspect = "4:3"
-			policy = {"letterbox": "letterbox", "panscan": "panscan", "scale": "bestfit", "full": "full", "auto": "auto"}[config.av.policy_169.value]
+			val = 0
+		eAVSwitch.getInstance().setPolicy43(val)
 
-		if not config.av.wss.value:
-			wss = "auto(4:3_off)"
+		valstr = config.av.policy_169.value
+		if valstr == "zoom":
+			val = 3
+		elif valstr == "letterbox":
+			val = 2
+		elif valstr == "panscan":
+			val = 1
 		else:
-			wss = "auto"
-
-		print("[VideoHardware] -> setting aspect, policy, policy2, wss", aspect, policy, policy2, wss)
-		open("/proc/stb/video/aspect", "w").write(aspect)
-		open("/proc/stb/video/policy", "w").write(policy)
-		try:
-			open("/proc/stb/denc/0/wss", "w").write(wss)
-		except IOError:
-			pass
-		try:
-			open("/proc/stb/video/policy2", "w").write(policy2)
-		except IOError:
-			pass
-
+			val = 0
+			eAVSwitch.getInstance().setPolicy169(val)
+			eAVSwitch.getInstance().setZoom(int(config.pc.image4_3_zoom_x.value), int(config.pc.image4_3_zoom_y.value), int(config.pc.image16_9_zoom_x.value), int(config.pc.image16_9_zoom_y.value))
+			eAVSwitch.getInstance().updateScreen()
+
+	def updateSoundMode(self, cfgelement):
+		print("**************** -> Update Sound Mode!")
+
+	def updateDeinterlace(self, cfgelement):
+		print("**************** -> Uupdate deinterlace!")
+		eAVSwitch.getInstance().setDeinterlace(int(config.av.deinterlace.value), int(config.av.deinterlace_sd.value), int(config.av.deinterlace_hd.value))
+
+	def updateSDfeatures(self, cfgelement):
+		print("**************** -> Update SD features!")
+		eAVSwitch.getInstance().setSDfeatures(int(config.pc.sd_sharpness.value), int(config.pc.sd_noise.value))
+
+	def updateBufMetronom(self, cfgelement):
+		print("**************** -> Update Prebuffer Metronom!")
+		eAVSwitch.getInstance().setBufMetronom(int(config.pc.prebuffer_metronom_hevc.value), int(config.pc.prebuffer_metronom_avc.value), int(config.pc.prebuffer_metronom_mpeg2.value))
 
+config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
diff -ruN o/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py pc/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py
--- o/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/Videomode/VideoWizard.py	2025-07-11 16:39:46.972636023 +0300
@@ -3,9 +3,9 @@
 from Screens.Rc import Rc
 from Plugins.SystemPlugins.Videomode.VideoHardware import video_hw
 
-from Components.Pixmap import Pixmap
+from Components.Pixmap import Pixmap, MovingPixmap, MultiPixmap
 from Components.config import config, ConfigBoolean, configfile
-from Components.SystemInfo import BoxInfo
+from Components.SystemInfo import SystemInfo
 
 from Tools.Directories import resolveFilename, SCOPE_PLUGINS
 from Tools.HardwareInfo import HardwareInfo
@@ -14,9 +14,28 @@
 
 
 class VideoWizardSummary(WizardSummary):
+	skin = (
+	"""<screen name="VideoWizardSummary" position="0,0" size="132,64" id="1">
+		<widget name="text" position="6,4" size="120,40" font="Regular;12" transparent="1" />
+		<widget source="parent.list" render="Label" position="6,40" size="120,21" font="Regular;14">
+			<convert type="StringListSelection" />
+		</widget>
+		<!--widget name="pic" pixmap="%s" position="6,22" zPosition="10" size="64,64" transparent="1" alphatest="on"/-->
+	</screen>""",
+	"""<screen name="VideoWizardSummary" position="0,0" size="96,64" id="2">
+		<widget name="text" position="0,4" size="96,40" font="Regular;12" transparent="1" />
+		<widget source="parent.list" render="Label" position="0,40" size="96,21" font="Regular;14">
+			<convert type="StringListSelection" />
+		</widget>
+		<!--widget name="pic" pixmap="%s" position="0,22" zPosition="10" size="64,64" transparent="1" alphatest="on"/-->
+	</screen>""")
+	#% (resolveFilename(SCOPE_PLUGINS, "SystemPlugins/Videomode/lcd_Scart.png"))
+
 	def __init__(self, session, parent):
 		WizardSummary.__init__(self, session, parent)
 
+		#self["pic"] = Pixmap()
+
 	def setLCDPicCallback(self):
 		self.parent.setLCDTextCallback(self.setText)
 
@@ -26,27 +45,22 @@
 
 class VideoWizard(WizardLanguage, Rc):
 	skin = """
-		<screen position="fill" title="Welcome..." flags="wfNoBorder" >
-			<panel name="WizardMarginsTemplate"/>
-			<panel name="WizardPictureLangTemplate"/>
-			<panel name="RemoteControlTemplate"/>
-			<panel position="left" size="10,*" />
-			<panel position="right" size="10,*" />
-			<panel position="fill">
-				<widget name="text" position="top" size="*,270" font="Regular;23" valign="center" />
-				<panel position="fill">
-					<panel position="left" size="150,*">
-						<widget name="portpic" position="top" zPosition="10" size="150,150" transparent="1" alphatest="on"/>
-					</panel>
-					<panel position="fill" layout="stack">
-						<widget source="list" render="Listbox" position="fill" scrollbarMode="showOnDemand" >
-							<convert type="StringList" />
-						</widget>
-						<!--<widget name="config" position="fill" zPosition="1" scrollbarMode="showOnDemand" />-->
-					</panel>
-				</panel>
-			</panel>
-		</screen>"""
+		<screen position="0,0" size="720,576" title="Welcome..." flags="wfNoBorder" >
+			<widget name="text" position="153,50" size="340,270" font="Regular;23" />
+			<widget source="list" render="Listbox" position="200,300" size="290,200" scrollbarMode="showOnDemand" >
+				<convert type="StringList" />
+			</widget>
+			<widget name="config" position="50,300" zPosition="1" size="440,200" transparent="1" scrollbarMode="showOnDemand" />
+			<widget name="wizard" pixmap="skin_default/wizard.png" position="40,50" zPosition="10" size="110,174" transparent="1" alphatest="on"/>
+			<ePixmap pixmap="skin_default/buttons/button_red.png" position="40,225" zPosition="0" size="15,16" transparent="1" alphatest="on" />
+			<widget name="languagetext" position="55,225" size="95,30" font="Regular;18" />
+			<widget name="portpic" pixmap="%s" position="50,300" zPosition="10" size="150,150" transparent="1" alphatest="on"/>
+			<widget name="rc" pixmaps="skin_default/rc.png,skin_default/rcold.png" position="500,50" zPosition="10" size="154,500" transparent="1" alphatest="on"/>
+			<widget name="arrowdown" pixmap="skin_default/arrowdown.png" position="0,0" zPosition="11" size="37,70" transparent="1" alphatest="on"/>
+			<widget name="arrowdown2" pixmap="skin_default/arrowdown.png" position="0,0" zPosition="11" size="37,70" transparent="1" alphatest="on"/>
+			<widget name="arrowup" pixmap="skin_default/arrowup.png" position="-100,-100" zPosition="11" size="37,70" transparent="1" alphatest="on"/>
+			<widget name="arrowup2" pixmap="skin_default/arrowup.png" position="-100,-100" zPosition="11" size="37,70" transparent="1" alphatest="on"/>
+		</screen>""" % (resolveFilename(SCOPE_PLUGINS, "SystemPlugins/Videomode/Scart.png"))
 
 	def __init__(self, session):
 		# FIXME anyone knows how to use relative paths from the plugin's directory?
@@ -68,7 +82,6 @@
 		return VideoWizardSummary
 
 	def markDone(self):
-		self.hw.saveMode(self.port, self.mode, self.rate)
 		config.misc.videowizardenabled.value = 0
 		config.misc.videowizardenabled.save()
 		configfile.save()
@@ -136,7 +149,7 @@
 		ratesList = self.listRates(mode)
 		print("[VideoWizard] ratesList:", ratesList)
 		if self.port == "DVI" and mode in ("720p", "1080i", "1080p", "2160p", "2160p30"):
-			if BoxInfo.getItem("Has24hz"):
+			if SystemInfo["Has24hz"]:
 				self.rate = "auto"
 				self.hw.setMode(port=self.port, mode=mode, rate="auto")
 			else:
diff -ruN o/lib/python/Plugins/SystemPlugins/VideoTune/Makefile.am pc/lib/python/Plugins/SystemPlugins/VideoTune/Makefile.am
--- o/lib/python/Plugins/SystemPlugins/VideoTune/Makefile.am	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/VideoTune/Makefile.am	2025-07-11 16:39:46.972636023 +0300
@@ -4,4 +4,4 @@
 
 install_PYTHON =	\
 	__init__.py \
-	plugin.py VideoFinetune.py testbeeld-4k.mvi
+	plugin.py VideoFinetune.py
diff -ruN o/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py pc/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py
--- o/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/VideoTune/VideoFinetune.py	2025-07-11 16:39:46.972636023 +0300
@@ -3,7 +3,7 @@
 from Components.Sources.CanvasSource import CanvasSource
 from Components.ActionMap import ActionMap, NumberActionMap
 from Components.Console import Console
-from Components.SystemInfo import BoxInfo
+from Components.SystemInfo import SystemInfo
 from Tools.Directories import fileExists, resolveFilename, SCOPE_PLUGINS
 from enigma import gFont, getDesktop, gMainDC, eSize, RT_HALIGN_RIGHT, RT_WRAP
 
@@ -78,37 +78,6 @@
 		gMainDC.getInstance().setResolution(self.xres, self.yres)
 		getDesktop(0).resize(eSize(self.xres, self.yres))
 
-
-class FullUHDTestScreen(OverscanTestScreen):
-	skin = """<screen position="0,0" size="0,0"/>"""
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-		self.oldref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
-		self.session.nav.stopService()
-		Console().ePopen("/usr/bin/showiframe %s" % resolveFilename(SCOPE_PLUGINS, "SystemPlugins/VideoTune/testbeeld-4k.mvi"))
-		self.hide()
-		self.onClose.append(self.__close)
-
-		self["actions"] = NumberActionMap(["InputActions", "OkCancelActions"],
-		{
-			"1": self.keyNumber,
-			"2": self.keyNumber,
-			"3": self.keyNumber,
-			"4": self.keyNumber,
-			"5": self.keyNumber,
-			"6": self.keyNumber,
-			"7": self.keyNumber,
-			"8": self.keyNumber,
-			"9": self.keyNumber,
-			"ok": self.ok,
-			"cancel": self.cancel
-		})
-
-	def __close(self):
-		self.session.nav.playService(self.oldref)
-
-
 class VideoFinetune(Screen):
 	skin = """
 		<screen position="fill">
@@ -117,10 +86,6 @@
 
 	def __init__(self, session):
 		Screen.__init__(self, session)
-
-		port = config.av.videoport.value
-		self.hasUHD = port and config.av.videomode[port].value.startswith("2160")
-
 		self["Canvas"] = CanvasSource()
 
 		self.basic_colors = [RGB(255, 255, 255), RGB(255, 255, 0), RGB(0, 255, 255), RGB(0, 255, 0), RGB(255, 0, 255), RGB(255, 0, 0), RGB(0, 0, 255), RGB(0, 0, 0)]
@@ -377,30 +342,17 @@
 		c.flush()
 
 	def testpic_overscan(self):
-		self.next = BoxInfo.getItem("HasFullHDSkinSupport") and self.testpic_fullhd or self.testpic_pixels
+		self.next = SystemInfo["HasFullHDSkinSupport"] and self.testpic_fullhd or self.testpic_pixels
 		self.hide()
 		self.session.openWithCallback(self.testpicCallback, OverscanTestScreen)
 
 	def testpic_fullhd(self):
-		if BoxInfo.getItem("HasFullHDSkinSupport"):
-			self.next = self.hasUHD and self.testpic_uhd or self.testpic_pixels
+		if SystemInfo["HasFullHDSkinSupport"]:
+			self.next = self.testpic_brightness
 			self.hide()
 			self.session.openWithCallback(self.testpicCallback, FullHDTestScreen)
 		else:
-			self.testpic_pixels()
-
-	def testpic_uhd(self):
-		if self.hasUHD:
-			self.next = self.testpic_pixels
-			self.hide()
-			self.session.openWithCallback(self.testpicCallback, FullUHDTestScreen)
-		else:
-			self.testpic_pixels()
-
-	def testpic_pixels(self):
-		self.next = self.testpic_brightness
-		self.hide()
-		self.session.openWithCallback(self.testpicCallback, PixelsTestScreen)
+			return 0
 
 	def testpicCallback(self, key):
 		if key:
@@ -410,87 +362,3 @@
 				self.keyNumber(key)
 		else:
 			self.close()
-
-
-class PixelsTestScreen(Screen):
-	skin = """
-		<screen position="fill">
-			<widget source="Canvas" render="Canvas" position="fill" zPosition="2"/>
-		</screen>"""
-
-	def __init__(self, session):
-		Screen.__init__(self, session)
-
-		self["Canvas"] = CanvasSource()
-		self.fontsize = getDesktop(0).size().height() == 1080 and 30 or 20
-		self.xres, self.yres = getDesktop(0).size().width(), getDesktop(0).size().height()
-
-		self["actions"] = NumberActionMap(["InputActions", "OkCancelActions", "ColorActions"],
-		{
-			"1": self.keyNumber,
-			"2": self.keyNumber,
-			"3": self.keyNumber,
-			"4": self.keyNumber,
-			"5": self.keyNumber,
-			"6": self.keyNumber,
-			"7": self.keyNumber,
-			"8": self.keyNumber,
-			"red": self.togglered,
-			"green": self.togglegreen,
-			"yellow": self.intro,
-			"blue": self.toggleblue,
-			"ok": self.ok,
-			"cancel": self.cancel,
-			"left": self.left,
-			"right": self.right,
-		})
-		self.intro()
-
-	def intro(self):
-		c = self["Canvas"]
-		c.fill(0, 0, self.xres, self.yres, RGB(0, 0, 0))
-		c.writeText(self.xres // 10, self.yres // 6 - self.fontsize * 2, self.xres * 3 // 5, 40, RGB(255, 128, 255), RGB(0, 0, 0), gFont("Regular", self.fontsize * 2),
-			_("Pixels\n"))
-		c.writeText(self.xres // 10, self.yres // 6, self.xres // 2, self.yres * 4 // 6, RGB(255, 255, 255), RGB(0, 0, 0), gFont("Regular", self.fontsize),
-			_("Can be used to test defect pixels on TV screen.\n\n"
-			"Available color test screens:\n\n"
-			"red\ngreen\nblue\nwhite\nblack\ncyan\nmagenta\nyellow\n\n"
-			"Screens change with left/right buttons or use red, green, blue to toggle.\n"
-			"Yellow for returning back to this intro"),
-			RT_WRAP)
-		c.flush()
-		self.color = 8
-
-	def left(self):
-		self.setArea((7, 2, 4, 0, 8, 3, 5, 1, 6)[self.color])
-
-	def right(self):
-		self.setArea((3, 7, 1, 5, 2, 6, 8, 0, 4)[self.color])
-
-	def togglered(self):
-		self.setArea(self.color ^ 4)
-
-	def togglegreen(self):
-		self.setArea(self.color ^ 2)
-
-	def toggleblue(self):
-		self.setArea(self.color ^ 1)
-
-	def setArea(self, color):
-		if color == 8:
-			self.intro()
-		else:
-			self.color = color & 7
-			self.show()
-			c = self["Canvas"]
-			c.fill(0, 0, self.xres, self.yres, RGB(color & 4 and 255, color & 2 and 255, color & 1 and 255))
-			c.flush()
-
-	def ok(self):
-		self.close(True)
-
-	def cancel(self):
-		self.close(False)
-
-	def keyNumber(self, key):
-		self.close(key)
diff -ruN o/lib/python/Plugins/SystemPlugins/WirelessLan/plugin.py pc/lib/python/Plugins/SystemPlugins/WirelessLan/plugin.py
--- o/lib/python/Plugins/SystemPlugins/WirelessLan/plugin.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/WirelessLan/plugin.py	2025-07-11 16:39:46.973635968 +0300
@@ -279,7 +279,7 @@
 		currentListEntry = None
 		currentListIndex = None
 
-		for ap in self.oldlist.keys():
+		for ap in list(self.oldlist.keys()):
 			data = self.oldlist[ap]['data']
 			if data is not None:
 				tmpList.append(data)
diff -ruN o/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py pc/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py
--- o/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Plugins/SystemPlugins/WirelessLan/Wlan.py	2025-07-11 16:39:46.973635968 +0300
@@ -206,7 +206,7 @@
 					'key': "",
 				}
 
-		for (k, v) in wsconf.items():
+		for (k, v) in list(wsconf.items()):
 			print("[wsconf][%s] %s" % (k, v))
 
 		return wsconf
@@ -323,7 +323,7 @@
 					'key': config.plugins.wlan.psk.value,
 				}
 
-			for (key, item) in wsconfig.items():
+			for (key, item) in list(wsconfig.items()):
 				if item == "None" or item == "":
 					if key == 'hiddenessid':
 						wsconfig['hiddenessid'] = False
diff -ruN o/lib/python/Screens/About.py pc/lib/python/Screens/About.py
--- o/lib/python/Screens/About.py	2025-07-11 16:39:11.176577838 +0300
+++ pc/lib/python/Screens/About.py	2025-07-11 16:39:46.973635968 +0300
@@ -37,8 +37,6 @@
 		AboutText += _("CPU: ") + cpu + "\n"
 		AboutText += _("Image: ") + about.getImageTypeString() + "\n"
 		AboutText += _("OE Version: ") + about.getOEVersionString() + "\n"
-		AboutText += _("Build date: ") + about.getBuildDateString() + "\n"
-		AboutText += _("Last update: ") + about.getUpdateDateString() + "\n"
 
 		# [WanWizard] Removed until we find a reliable way to determine the installation date
 		# AboutText += _("Installed: ") + about.getFlashDateString() + "\n"
@@ -50,32 +48,15 @@
 
 		AboutText += _("Kernel version: ") + about.getKernelVersionString() + "\n"
 
-		AboutText += _("DVB driver version: ") + about.getDriverInstalledDate() + "\n"
-
-		GStreamerVersion = about.getGStreamerVersionString().replace("GStreamer", "")
-		self["GStreamerVersion"] = StaticText(GStreamerVersion)
-
-		ffmpegVersion = about.getffmpegVersionString()
+		ffmpegVersion = _("FFmpeg version: 7:") + about.getffmpegVersionString()
 		self["ffmpegVersion"] = StaticText(ffmpegVersion)
+		AboutText += ffmpegVersion + "\n"
 
-		player = None
-
-		if os.path.isfile('/var/lib/opkg/info/enigma2-plugin-systemplugins-servicemp3.list'):
-			if GStreamerVersion:
-				player = _("Media player") + ": Gstreamer, " + _("version") + " " + GStreamerVersion
-		if os.path.isfile('/var/lib/opkg/info/enigma2-plugin-systemplugins-servicehisilicon.list'):
-			if os.path.isdir("/usr/lib/hisilicon") and glob.glob("/usr/lib/hisilicon/libavcodec.so.*"):
-				player = _("Media player") + ": ffmpeg, " + _("Hardware Accelerated")
-			elif ffmpegVersion and ffmpegVersion[0].isdigit():
-				player = _("Media player") + ": ffmpeg, " + _("version") + " " + ffmpegVersion
-
-		if player is None:
-				player = _("Media player") + ": " + _("Not Installed")
-
-		AboutText += player + "\n"
+		libxineVersion = _("LibXine version: ") + about.getlibxineVersionString()
+		self["libxineVersion"] = StaticText(libxineVersion)
+		AboutText += libxineVersion + "\n"
 
 		AboutText += _("Python version: ") + about.getPythonVersionString() + "\n"
-
 		AboutText += _("Enigma (re)starts: %d\n") % config.misc.startCounter.value
 		AboutText += _("Uptime: %s\n") % about.getBoxUptime()
 		AboutText += _("Enigma debug level: %d\n") % eGetEnigmaDebugLvl()
@@ -121,6 +102,7 @@
 		AboutText += hddinfo + "\n\n" + _("Network Info:")
 		for x in about.GetIPsFromNetworkInterfaces():
 			AboutText += "\n" + x[0] + ": " + x[1]
+		AboutText += '\n\n' + _("Uptime") + ": " + about.getBoxUptime()
 		if BoxInfo.getItem("HasHDMI-CEC") and config.hdmicec.enabled.value:
 			address = config.hdmicec.fixed_physical_address.value if config.hdmicec.fixed_physical_address.value != "0.0.0.0" else _("not set")
 			AboutText += "\n\n" + _("HDMI-CEC address") + ": " + address
@@ -480,17 +462,17 @@
 		self.close()
 
 	def getDebugFilesList(self):
-		return [x for x in sorted(glob.glob("/home/root/enigma.*.debuglog"), key=lambda x: os.path.isfile(x) and os.path.getmtime(x))]
+		return [x for x in sorted(glob.glob("/media/hdd/enigma.*.debuglog"), key=lambda x: os.path.isfile(x) and os.path.getmtime(x))]
 
 	def getLogFilesList(self):
-		home_root = "/home/root/enigma2_crash.log"
+		home_root = "/media/hdd/enigma2_crash.log"
 		tmp = "/tmp/enigma2_crash.log"
-		return [x for x in sorted(glob.glob("/mnt/hdd/*.log"), key=lambda x: os.path.isfile(x) and os.path.getmtime(x))] + (os.path.isfile(home_root) and [home_root] or []) + (os.path.isfile(tmp) and [tmp] or [])
+		return [x for x in sorted(glob.glob("/media/hdd/*.log"), key=lambda x: os.path.isfile(x) and os.path.getmtime(x))] + (os.path.isfile(home_root) and [home_root] or []) + (os.path.isfile(tmp) and [tmp] or [])
 
 	def updateOptions(self):
 		self.titles = ["dmesg", "ifconfig", "df", "top", "ps", "messages", "enigma info", "BoxInfo"]
-		self.commands = ["dmesg", "ifconfig", "df -h", "top -n 1", "ps -l", "cat /var/volatile/log/messages", "cat /usr/lib/enigma.info", "boxinfo"]
-		install_log = "/home/root/autoinstall.log"
+		self.commands = ["dmesg", "ifconfig", "df -h", "top -n 1", "ps -l", "cat /var/volatile/log/messages", "cat /usr/local/e2/lib/enigma.info", "boxinfo"]
+		install_log = "/media/hdd/autoinstall.log"
 		if os.path.isfile(install_log):
 				self.titles.append("%s" % install_log)
 				self.commands.append("cat %s" % install_log)
diff -ruN o/lib/python/Screens/AudioSelection.py pc/lib/python/Screens/AudioSelection.py
--- o/lib/python/Screens/AudioSelection.py	2025-07-11 16:39:11.176577838 +0300
+++ pc/lib/python/Screens/AudioSelection.py	2025-07-11 16:39:46.973635968 +0300
@@ -20,7 +20,7 @@
 
 from enigma import iPlayableService, eTimer, eSize, eDVBDB, eServiceReference, eServiceCenter, iServiceInformation
 
-FOCUS_CONFIG, FOCUS_STREAMS = range(2)
+FOCUS_CONFIG, FOCUS_STREAMS = list(range(2))
 [PAGE_AUDIO, PAGE_SUBTITLES] = ["audio", "subtitles"]
 
 selectionpng = LoadPixmap(cached=True, path=resolveFilename(SCOPE_GUISKIN, "icons/audioselectionmark.png"))
@@ -436,6 +436,20 @@
 		self.skinName = ["AudioSelection"]
 
 
+import xml.etree.cElementTree
+from Screens.Setup import setupdom
+from enigma import eTimer
+from Components.Label import Label
+
+def findSetupText(text):
+	xmldata = setupdom.getroot()
+	for subtitlesection in xmldata:
+		if subtitlesection.attrib["key"] == 'subtitlesetup':
+			for d in subtitlesection:
+				if d.text == text:
+					return _(d.attrib['text'])
+	return ""
+
 class QuickSubtitlesConfigMenu(ConfigListScreen, Screen):
 	skin = """
 	<screen position="50,50" size="480,305" title="Subtitle settings" backgroundColor="#7f000000" flags="wfNoBorder">
diff -ruN o/lib/python/Screens/Dish.py pc/lib/python/Screens/Dish.py
--- o/lib/python/Screens/Dish.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/Dish.py	2025-07-11 16:39:46.973635968 +0300
@@ -211,7 +211,7 @@
 					return nim.turningspeedH.float
 			elif nimConfig.configMode.value == "advanced":
 				if self.cur_orbpos != INVALID_POSITION:
-					if self.cur_orbpos in nimConfig.advanced.sat.keys():
+					if self.cur_orbpos in list(nimConfig.advanced.sat.keys()):
 						currSat = nimConfig.advanced.sat[self.cur_orbpos]
 						lnbnum = int(currSat.lnb.value)
 						currLnb = lnbnum and nimConfig.advanced.lnb[lnbnum]
diff -ruN o/lib/python/Screens/EpgSelection.py pc/lib/python/Screens/EpgSelection.py
--- o/lib/python/Screens/EpgSelection.py	2025-07-11 16:39:11.177577785 +0300
+++ pc/lib/python/Screens/EpgSelection.py	2025-07-11 16:39:46.974635914 +0300
@@ -75,8 +75,8 @@
 			self.setTitle(_("Multi EPG"))
 			self.skinName = "EPGSelectionMulti"
 			self.type = EPG_TYPE_MULTI
-			self["key_yellow"] = StaticText(pgettext("button label, 'previous screen'", "Prev"))
-			self["key_blue"] = StaticText(pgettext("button label, 'next screen'", "Next"))
+			self["key_yellow"] = StaticText(_("Prev"))
+			self["key_blue"] = StaticText(_("Next"))
 			self["now_button"] = Pixmap()
 			self["next_button"] = Pixmap()
 			self["more_button"] = Pixmap()
diff -ruN o/lib/python/Screens/FlashImage.py pc/lib/python/Screens/FlashImage.py
--- o/lib/python/Screens/FlashImage.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/FlashImage.py	2025-07-11 16:39:46.974635914 +0300
@@ -107,7 +107,7 @@
 					print("[FlashImage] getImageBrandList Error: Unable to load json data from URL '%s'!" % url)
 				if self.imageBrandList:
 					self.imageBrandList.update({self.selectedImage[0]: self.selectedImage[1]})
-					self.models = set([self.imageBrandList[image]['model'] for image in self.imageBrandList.keys()])
+					self.models = set([self.imageBrandList[image]['model'] for image in list(self.imageBrandList.keys())])
 					if len(self.imageBrandList) > 1:
 						self["key_blue"].setText(_("Other Images"))
 		if not self.imagesList:
@@ -141,13 +141,13 @@
 					pass
 
 		list = []
-		for catagorie in conditional_sort(self.imagesList.keys(), lambda w: _("Downloaded Images") not in w and _("Fullbackup Images") not in w):
+		for catagorie in conditional_sort(list(self.imagesList.keys()), lambda w: _("Downloaded Images") not in w and _("Fullbackup Images") not in w):
 			if catagorie in self.expanded:
 				list.append(ChoiceEntryComponent('expanded', ((str(catagorie)), "Expander")))
 				for image in reversed(sorted(self.imagesList[catagorie].keys())):
 					list.append(ChoiceEntryComponent('verticalline', ((str(self.imagesList[catagorie][image]['name'])), str(self.imagesList[catagorie][image]['link']))))
 			else:
-				for image in self.imagesList[catagorie].keys():
+				for image in list(self.imagesList[catagorie].keys()):
 					list.append(ChoiceEntryComponent('expandable', ((str(catagorie)), "Expander")))
 					break
 		if list:
@@ -199,7 +199,7 @@
 
 	def otherImages(self):
 		if len(self.imageBrandList) > 1:
-			self.session.openWithCallback(self.otherImagesCallback, ChoiceBox, list=[(key, self.imageBrandList[key]) for key in self.imageBrandList.keys()], windowTitle=_("Select an image brand"))
+			self.session.openWithCallback(self.otherImagesCallback, ChoiceBox, list=[(key, self.imageBrandList[key]) for key in list(self.imageBrandList.keys())], windowTitle=_("Select an image brand"))
 
 	def otherImagesCallback(self, image):
 		if image:
@@ -285,7 +285,7 @@
 			imagesList = getImagelist()
 			currentimageslot = getCurrentImage()
 			choices = []
-			slotdict = {k: v for k, v in BoxInfo.getItem("canMultiBoot").items() if not v['device'].startswith('/dev/sd')}
+			slotdict = {k: v for k, v in list(BoxInfo.getItem("canMultiBoot").items()) if not v['device'].startswith('/dev/sd')}
 			for x in range(1, len(slotdict) + 1):
 				choices.append(((_("slot%s - %s (current image) with, backup") if x == currentimageslot else _("slot%s - %s, with backup")) % (x, imagesList[x]['imagename']), (x, "with backup")))
 			for x in range(1, len(slotdict) + 1):
diff -ruN o/lib/python/Screens/Hotkey.py pc/lib/python/Screens/Hotkey.py
--- o/lib/python/Screens/Hotkey.py	2025-07-11 16:39:11.178577730 +0300
+++ pc/lib/python/Screens/Hotkey.py	2025-07-11 16:39:46.974635914 +0300
@@ -236,8 +236,8 @@
 	hotkey.functions.append((_("PowerMenu"), "Menu/shutdown", "Power"))
 	hotkey.functions.append((_("Standby"), "Module/Screens.Standby/Standby", "Power"))
 	hotkey.functions.append((_("Restart"), "Module/Screens.Standby/TryQuitMainloop/2", "Power"))
-	hotkey.functions.append((_("Restart enigma"), "Module/Screens.Standby/TryQuitMainloop/3", "Power"))
-	hotkey.functions.append((_("Deep standby"), "Module/Screens.Standby/TryQuitMainloop/1", "Power"))
+	hotkey.functions.append((_("Quit"), "Module/Screens.Standby/TryQuitMainloop/3", "Power"))
+	hotkey.functions.append((_("Shutdown"), "Module/Screens.Standby/TryQuitMainloop/1", "Power"))
 	hotkey.functions.append((_("Usage Setup"), "Setup/usage", "Setup"))
 	hotkey.functions.append((_("User interface"), "Setup/userinterface", "Setup"))
 	hotkey.functions.append((_("Recording Setup"), "Setup/recording", "Setup"))
diff -ruN o/lib/python/Screens/InfoBarGenerics.py pc/lib/python/Screens/InfoBarGenerics.py
--- o/lib/python/Screens/InfoBarGenerics.py	2025-07-11 16:39:11.178577730 +0300
+++ pc/lib/python/Screens/InfoBarGenerics.py	2025-07-11 16:39:46.975635859 +0300
@@ -626,8 +626,7 @@
 	def mayShowEndTimer(self):
 		self.mayShow = True
 		if self.getBufferValue() == 0:
-			self["status"].setText(_("No data received yet"))
-			self.show()
+			self.hide()
 
 	def getBufferValue(self):
 		service = self.session.nav.getCurrentService()
@@ -3815,8 +3814,7 @@
 	def goStandby(self):
 		if not Screens.Standby.inStandby:
 			print("[InfoBarPowersaver] goto standby")
-			self.session.open(Screens.Standby.Standby)
-
+			self.session.open(Screens.Standby.TryQuitMainloop, 1)
 
 class InfoBarHDMI:
 	def HDMIIn(self):
diff -ruN o/lib/python/Screens/PluginBrowser.py pc/lib/python/Screens/PluginBrowser.py
--- o/lib/python/Screens/PluginBrowser.py	2025-07-11 16:39:11.179577676 +0300
+++ pc/lib/python/Screens/PluginBrowser.py	2025-07-11 16:39:46.975635859 +0300
@@ -58,7 +58,6 @@
 		self.firsttime = True
 
 		self["key_red"] = self["red"] = Label(_("Remove plugins"))
-		self["key_green"] = self["green"] = Label(_("Download plugins"))
 		self["key_menu"] = StaticText(_("MENU"))
 		self.list = []
 		self["list"] = PluginList(self.list)
@@ -72,7 +71,6 @@
 		self["PluginDownloadActions"] = ActionMap(["ColorActions"],
 		{
 			"red": self.delete,
-			"green": self.download
 		})
 		self["DirectionActions"] = ActionMap(["DirectionActions"],
 		{
@@ -544,7 +542,7 @@
 
 			self.plugins[split[0]].append((PluginDescriptor(name=x[3], description=x[2], icon=verticallineIcon), split[1], x[1]))
 
-		for x in self.plugins.keys():
+		for x in list(self.plugins.keys()):
 			if x in self.expanded:
 				list.append(PluginCategoryComponent(x, expandedIcon, self.listWidth))
 				list.extend([PluginDownloadComponent(plugin[0], plugin[1], plugin[2], self.listWidth) for plugin in self.plugins[x]])
diff -ruN o/lib/python/Screens/Satconfig.py pc/lib/python/Screens/Satconfig.py
--- o/lib/python/Screens/Satconfig.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/Satconfig.py	2025-07-11 16:39:46.976635805 +0300
@@ -149,7 +149,7 @@
 				self.list.append(self.configMode)
 				warning_text = _(" Warning: the selected tuner should not use SCR Unicable type for LNBs because each tuner need a own SCR number.")
 				if self.nimConfig.configMode.value == "simple":			#simple setup
-					self.diseqcModeEntry = (self.indent % pgettext("Satellite configuration mode", "Mode"), self.nimConfig.diseqcMode, _("Select how the satellite dish is set up. i.e. fixed dish, single LNB, DiSEqC switch, positioner, etc."))
+					self.diseqcModeEntry = (_("Satellite configuration mode"), self.nimConfig.diseqcMode, _("Select how the satellite dish is set up. i.e. fixed dish, single LNB, DiSEqC switch, positioner, etc."))
 					self.list.append(self.diseqcModeEntry)
 					if self.nimConfig.diseqcMode.value in ("single", "toneburst_a_b", "diseqc_a_b", "diseqc_a_b_c_d"):
 						self.createSimpleSetup(self.list, self.nimConfig.diseqcMode.value)
@@ -204,7 +204,7 @@
 					else:
 						cur_orb_pos = self.nimConfig.advanced.sats.orbital_position
 						if cur_orb_pos is not None:
-							if cur_orb_pos not in self.nimConfig.advanced.sat.keys():
+							if cur_orb_pos not in list(self.nimConfig.advanced.sat.keys()):
 								cur_orb_pos = next(iter(self.nimConfig.advanced.sat)) # get first key
 							self.fillListWithAdvancedSatEntrys(self.nimConfig.advanced.sat[cur_orb_pos])
 					self.have_advanced = True
@@ -536,7 +536,7 @@
 		self.list.append(self.configMode)
 		self.advancedSatsEntry = (self.indent % _("Satellite"), self.nimConfig.advanced.sats)
 		self.list.append(self.advancedSatsEntry)
-		for x in self.nimConfig.advanced.sat.keys():
+		for x in list(self.nimConfig.advanced.sat.keys()):
 			Sat = self.nimConfig.advanced.sat[x]
 			self.fillListWithAdvancedSatEntrys(Sat)
 		self["config"].list = self.list
diff -ruN o/lib/python/Screens/Screen.py pc/lib/python/Screens/Screen.py
--- o/lib/python/Screens/Screen.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/Screen.py	2025-07-11 16:39:46.976635805 +0300
@@ -17,7 +17,7 @@
 
 
 class Screen(dict):
-	NO_SUSPEND, SUSPEND_STOPS, SUSPEND_PAUSES = range(3)
+	NO_SUSPEND, SUSPEND_STOPS, SUSPEND_PAUSES = list(range(3))
 	ALLOW_SUSPEND = NO_SUSPEND
 	globalScreen = None
 
@@ -298,7 +298,7 @@
 				val.downstream_elements.changed((val.CHANGED_DEFAULT,))
 
 	def deleteGUIScreen(self):
-		for (name, val) in self.items():
+		for (name, val) in list(self.items()):
 			if isinstance(val, GUIComponent):
 				val.GUIdelete()
 
diff -ruN o/lib/python/Screens/StartWizard.py pc/lib/python/Screens/StartWizard.py
--- o/lib/python/Screens/StartWizard.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/StartWizard.py	2025-07-11 16:39:46.976635805 +0300
@@ -108,7 +108,7 @@
 		self["AboutScrollLabel"] = ScrollLabel("", showscrollbar=False)
 		self["header"] = Label(_("Autoinstalling please wait for packages being updated"))
 
-		self.logfile = open('/home/root/autoinstall.log', 'w')
+		self.logfile = open('/media/hdd/autoinstall.log', 'w')
 		self.container = eConsoleAppContainer()
 		self.container.appClosed.append(self.appClosed)
 		self.container.dataAvail.append(self.dataAvail)
@@ -159,7 +159,7 @@
 				self.dataAvail("An error occurred during installing %s - Please try again later\n" % self.package)
 			else:
 				self.dataAvail("An error occurred during opkg update - Please try again later\n")
-		installed = [line.strip().split(":", 1)[1].strip() for line in open('/var/lib/opkg/status').readlines() if line.startswith('Package:')]
+		installed = [line.strip().split(":", 1)[1].strip() for line in open('/var/lib/dpkg/status').readlines() if line.startswith('Package:')]
 		self.packages = [package for package in self.packages if package not in installed]
 		if self.packages:
 			self.run_console()
diff -ruN o/lib/python/Screens/VirtualKeyBoard.py pc/lib/python/Screens/VirtualKeyBoard.py
--- o/lib/python/Screens/VirtualKeyBoard.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/VirtualKeyBoard.py	2025-07-11 16:39:46.976635805 +0300
@@ -1048,7 +1048,7 @@
 
 	def localeMenu(self):
 		languages = []
-		for locale, data in self.locales.items():
+		for locale, data in list(self.locales.items()):
 			languages.append((data[0] + "  -  " + data[1] + "  (" + locale + ")", locale))
 		languages = sorted(languages)
 		index = 0
diff -ruN o/lib/python/Screens/Wizard.py pc/lib/python/Screens/Wizard.py
--- o/lib/python/Screens/Wizard.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Screens/Wizard.py	2025-07-11 16:39:46.976635805 +0300
@@ -309,7 +309,7 @@
 	def getStepWithID(self, id):
 		print("getStepWithID:", id)
 		count = 0
-		for x in self.wizard.keys():
+		for x in list(self.wizard.keys()):
 			if self.wizard[x]["id"] == id:
 				print("result:", count)
 				return count
@@ -503,7 +503,7 @@
 		self.condition = True
 		exec(self.wizard[self.currStep]["condition"])
 		if not self.condition:
-			print("keys*******************:", self.wizard[self.currStep].keys())
+			print("keys*******************:", list(self.wizard[self.currStep].keys()))
 			if "laststep" in self.wizard[self.currStep]: # exit wizard, if condition of laststep doesn't hold
 				self.markDone()
 				self.exit()
diff -ruN o/lib/python/skin.py pc/lib/python/skin.py
--- o/lib/python/skin.py	2025-07-11 16:39:11.180577621 +0300
+++ pc/lib/python/skin.py	2025-07-11 16:39:46.977635750 +0300
@@ -437,7 +437,7 @@
 	size = None
 	pos = None
 	font = None
-	for attrib, value in node.items():  # Walk all attributes.
+	for attrib, value in list(node.items()):  # Walk all attributes.
 		if attrib not in ignore:
 			if attrib in filenames:
 				value = resolveFilename(SCOPE_CURRENT_SKIN, value, path_prefix=skinPath)
@@ -1332,10 +1332,10 @@
 	def processScreen(widget, context):
 		for w in widget:
 			conditional = w.attrib.get("conditional")
-			if conditional and not [i for i in conditional.split(",") if i in screen.keys()]:
+			if conditional and not [i for i in conditional.split(",") if i in list(screen.keys())]:
 				continue
 			objecttypes = w.attrib.get("objectTypes", "").split(",")
-			if len(objecttypes) > 1 and (objecttypes[0] not in screen.keys() or not [i for i in objecttypes[1:] if i == screen[objecttypes[0]].__class__.__name__]):
+			if len(objecttypes) > 1 and (objecttypes[0] not in list(screen.keys()) or not [i for i in objecttypes[1:] if i == screen[objecttypes[0]].__class__.__name__]):
 				continue
 			p = processors.get(w.tag, processNone)
 			try:
diff -ruN o/lib/python/StartEnigma.py pc/lib/python/StartEnigma.py
--- o/lib/python/StartEnigma.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/StartEnigma.py	2025-07-11 16:39:46.977635750 +0300
@@ -123,10 +123,10 @@
 
 def dump(dir, p=""):
 	if isinstance(dir, dict):
-		for (entry, val) in dir.items():
+		for (entry, val) in list(dir.items()):
 			dump(val, p + "(dict)/" + entry)
 	if hasattr(dir, "__dict__"):
-		for name, value in dir.__dict__.items():
+		for name, value in list(dir.__dict__.items()):
 			if str(value) not in had:
 				had[str(value)] = 1
 				dump(value, p + "/" + str(name))
diff -ruN o/lib/python/Tools/KeyBindings.py pc/lib/python/Tools/KeyBindings.py
--- o/lib/python/Tools/KeyBindings.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Tools/KeyBindings.py	2025-07-11 16:39:46.977635750 +0300
@@ -428,7 +428,7 @@
 
 def removeKeyBinding(key, context, action, wild=True):
 	if wild and action == "*":
-		for ctx, action in keyBindings.keys():
+		for ctx, action in list(keyBindings.keys()):
 			if ctx == context:
 				removeKeyBinding(key, context, action, False)
 		return
diff -ruN o/lib/python/Tools/Multiboot.py pc/lib/python/Tools/Multiboot.py
--- o/lib/python/Tools/Multiboot.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Tools/Multiboot.py	2025-07-11 16:39:46.977635750 +0300
@@ -117,7 +117,7 @@
 				return int(slot[0])
 			else:
 				device = getparam(open('/sys/firmware/devicetree/base/chosen/bootargs', 'r').read(), 'root')
-				for slot in BoxInfo.getItem("canMultiBoot").keys():
+				for slot in list(BoxInfo.getItem("canMultiBoot").keys()):
 					if BoxInfo.getItem("canMultiBoot")[slot]['device'] == device:
 						return slot
 
@@ -129,7 +129,7 @@
 def deleteImage(slot):
 	tmp.dir = tempfile.mkdtemp(prefix="Multiboot")
 	Console().ePopen('mount %s %s' % (BoxInfo.getItem("canMultiBoot")[slot]['device'], tmp.dir))
-	enigma2binaryfile = os.path.join(os.sep.join(filter(None, [tmp.dir, BoxInfo.getItem("canMultiBoot")[slot].get('rootsubdir', '')])), 'usr/bin/enigma2')
+	enigma2binaryfile = os.path.join(os.sep.join([_f for _f in [tmp.dir, BoxInfo.getItem("canMultiBoot")[slot].get('rootsubdir', '')] if _f]), 'usr/bin/enigma2')
 	if os.path.exists(enigma2binaryfile):
 		os.rename(enigma2binaryfile, '%s.bak' % enigma2binaryfile)
 	Console().ePopen('umount %s' % tmp.dir)
@@ -141,7 +141,7 @@
 	for slot in BoxInfo.getItem("canMultiBoot"):
 		tmp.dir = tempfile.mkdtemp(prefix="Multiboot")
 		Console().ePopen('mount %s %s' % (BoxInfo.getItem("canMultiBoot")[slot]['device'], tmp.dir))
-		enigma2binaryfile = os.path.join(os.sep.join(filter(None, [tmp.dir, BoxInfo.getItem("canMultiBoot")[slot].get('rootsubdir', '')])), 'usr/bin/enigma2')
+		enigma2binaryfile = os.path.join(os.sep.join([_f for _f in [tmp.dir, BoxInfo.getItem("canMultiBoot")[slot].get('rootsubdir', '')] if _f]), 'usr/bin/enigma2')
 		if os.path.exists('%s.bak' % enigma2binaryfile):
 			os.rename('%s.bak' % enigma2binaryfile, enigma2binaryfile)
 		Console().ePopen('umount %s' % tmp.dir)
@@ -169,7 +169,7 @@
 				Console().ePopen('mount -t ubifs %s %s' % (BoxInfo.getItem("canMultiBoot")[slot]['device'], tmp.dir))
 			else:
 				Console().ePopen('mount %s %s' % (BoxInfo.getItem("canMultiBoot")[slot]['device'], tmp.dir))
-			imagedir = os.sep.join(filter(None, [tmp.dir, BoxInfo.getItem("canMultiBoot")[slot].get('rootsubdir', '')]))
+			imagedir = os.sep.join([_f for _f in [tmp.dir, BoxInfo.getItem("canMultiBoot")[slot].get('rootsubdir', '')] if _f])
 			if os.path.isfile(os.path.join(imagedir, 'usr/bin/enigma2')):
 				imagelist[slot] = {'imagename': getSlotImageInfo(slot, imagedir=imagedir)}
 			elif os.path.isfile(os.path.join(imagedir, 'usr/bin/enigma2.bak')):
diff -ruN o/lib/python/Tools/NumericalTextInput.py pc/lib/python/Tools/NumericalTextInput.py
--- o/lib/python/Tools/NumericalTextInput.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Tools/NumericalTextInput.py	2025-07-11 16:39:46.978635696 +0300
@@ -44,93 +44,93 @@
 	"cs_CZ": (
 		(None, None, None),
 		(None, None, None),
-		("abc2\u00E1\u010DABC\u00C1\u010C", "ABC2\u00C1\u010C", "abc2\u00E1\u010D"),
-		("def3\u010F\u00E9\u011BDEF\u010E\u00C9\u011A", "DEF3\u010E\u00C9\u011A", "def3\u010F\u00E9\u011B"),
-		("ghi4\u00EDGHI\u00CD", "GHI4\u00CD", "ghi4\u00ED"),
-		(None, None, None),
-		("mno6\u0148\u00F3MNO\u0147\u00D3", "MNO6\u0147\u00D3", "mno6\u0148\u00F3"),
-		("pqrs7\u0159\u0161PQRS\u0158\u0160", "PQRS7\u0158\u0160", "pqrs7\u0159\u0161"),
-		("tuv8\u0165\u00FA\u016FTUV\u0164\u00DA\u016E", "TUV8\u0164\u00DA\u016E", "tuv8\u0165\u00FA\u016F"),
-		("wxyz9\u00FD\u017EWXYZ\u00DD\u017D", "WXYZ9\u00DD\u017D", "wxyz9\u00FD\u017E")
+		("abc2\\u00E1\\u010DABC\\u00C1\\u010C", "ABC2\\u00C1\\u010C", "abc2\\u00E1\\u010D"),
+		("def3\\u010F\\u00E9\\u011BDEF\\u010E\\u00C9\\u011A", "DEF3\\u010E\\u00C9\\u011A", "def3\\u010F\\u00E9\\u011B"),
+		("ghi4\\u00EDGHI\\u00CD", "GHI4\\u00CD", "ghi4\\u00ED"),
+		(None, None, None),
+		("mno6\\u0148\\u00F3MNO\\u0147\\u00D3", "MNO6\\u0147\\u00D3", "mno6\\u0148\\u00F3"),
+		("pqrs7\\u0159\\u0161PQRS\\u0158\\u0160", "PQRS7\\u0158\\u0160", "pqrs7\\u0159\\u0161"),
+		("tuv8\\u0165\\u00FA\\u016FTUV\\u0164\\u00DA\\u016E", "TUV8\\u0164\\u00DA\\u016E", "tuv8\\u0165\\u00FA\\u016F"),
+		("wxyz9\\u00FD\\u017EWXYZ\\u00DD\\u017D", "WXYZ9\\u00DD\\u017D", "wxyz9\\u00FD\\u017E")
 	),
 	"de_DE": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u00E4\u00E0\u00E5\u01012ABC\u00C4\u00C0\u00C5\u0100", "ABC\u00C42", "abc\u00E42"),
-		("def\u0111\u00E9\u01133DEF\u0110\u00C9\u0112", "DEF\u0110\u00C9\u01123", "def\u0111\u00E9\u01133"),
+		("abc\\u00E4\\u00E0\\u00E5\\u01012ABC\\u00C4\\u00C0\\u00C5\\u0100", "ABC\\u00C42", "abc\\u00E42"),
+		("def\\u0111\\u00E9\\u01133DEF\\u0110\\u00C9\\u0112", "DEF\\u0110\\u00C9\\u01123", "def\\u0111\\u00E9\\u01133"),
 		(None, None, None),
 		(None, None, None),
-		("mno\u00F66MNO\u00D6", "MNO\u00D66", "mno\u00F66"),
-		("pqrs\u00DF7PQRS", "PQRS7", "pqrs\u00DF7"),
-		("tuv\u00FC8TUV\u00DC", "TUV\u00DC8", "tuv\u00FC8"),
+		("mno\\u00F66MNO\\u00D6", "MNO\\u00D66", "mno\\u00F66"),
+		("pqrs\\u00DF7PQRS", "PQRS7", "pqrs\\u00DF7"),
+		("tuv\\u00FC8TUV\\u00DC", "TUV\\u00DC8", "tuv\\u00FC8"),
 		(None, None, None)
 	),
 	"es_ES": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u00E1\u00E0\u00E72ABC\u00C1\u00C0\u00C7", "ABC\u00C1\u00C0\u00C72", "abc\u00E1\u00E0\u00E72"),
-		("def\u00E9\u00E83DEF\u00C9\u00C8", "DEF\u00C9\u00C83", "def\u00E9\u00E83"),
-		("ghi\u00ED\u00EF4GHI\u00CD\u00CF", "GHI\u00CD\u00CF4", "ghi\u00ED\u00EF4"),
+		("abc\\u00E1\\u00E0\\u00E72ABC\\u00C1\\u00C0\\u00C7", "ABC\\u00C1\\u00C0\\u00C72", "abc\\u00E1\\u00E0\\u00E72"),
+		("def\\u00E9\\u00E83DEF\\u00C9\\u00C8", "DEF\\u00C9\\u00C83", "def\\u00E9\\u00E83"),
+		("ghi\\u00ED\\u00EF4GHI\\u00CD\\u00CF", "GHI\\u00CD\\u00CF4", "ghi\\u00ED\\u00EF4"),
 		(None, None, None),
-		("mno\u00F1\u00F3\u00F26MNO\u00D1\u00D3\u00D2", "MNO\u00D1\u00D3\u00D26", "mno\u00F1\u00F3\u00F26"),
+		("mno\\u00F1\\u00F3\\u00F26MNO\\u00D1\\u00D3\\u00D2", "MNO\\u00D1\\u00D3\\u00D26", "mno\\u00F1\\u00F3\\u00F26"),
 		(None, None, None),
-		("tuv\u00FA\u00FC8TUV\u00DA\u00DC", "TUV\u00DA\u00DC8", "tuv\u00FA\u00FC8"),
+		("tuv\\u00FA\\u00FC8TUV\\u00DA\\u00DC", "TUV\\u00DA\\u00DC8", "tuv\\u00FA\\u00FC8"),
 		(None, None, None)
 	),
 	"et_EE": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u00E42ABC\u00C4", "ABC\u00C42", "abc\u00E42"),
+		("abc\\u00E42ABC\\u00C4", "ABC\\u00C42", "abc\\u00E42"),
 		(None, None, None),
 		(None, None, None),
 		(None, None, None),
-		("mno\u00F5\u00F66MNO\u00D5\u00D6", "MNO\u00D5\u00D66", "mno\u00F5\u00F66"),
-		("pqrs\u01617PQRS\u0160", "PQRS\u01607", "pqrs\u01617"),
-		("tuv\u00FC8TUV\u00DC", "TUV\u00DC8", "tuv\u00FC8"),
-		("wxyz\u017E9WXYZ\u017D", "WXYZ\u017D9", "wxyz\u017E9")
+		("mno\\u00F5\\u00F66MNO\\u00D5\\u00D6", "MNO\\u00D5\\u00D66", "mno\\u00F5\\u00F66"),
+		("pqrs\\u01617PQRS\\u0160", "PQRS\\u01607", "pqrs\\u01617"),
+		("tuv\\u00FC8TUV\\u00DC", "TUV\\u00DC8", "tuv\\u00FC8"),
+		("wxyz\\u017E9WXYZ\\u017D", "WXYZ\\u017D9", "wxyz\\u017E9")
 	),
 	"fa_IR": (
-		("\u06F0" + PUNCTUATION0, "\u06F0" + PUNCTUATION0, "\u06F0" + PUNCTUATION0),
-		("\u06F1" + PUNCTUATION1, "\u06F1" + PUNCTUATION1, "\u06F1" + PUNCTUATION1),
-		("\u0628\u067E\u062A\u0629\u062B\u06F2abc2DEF", "\u0628\u067E\u062A\u0629\u062B\u06F2ABC2", "\u0628\u067E\u062A\u0629\u062B\u06F2abc2"),
-		("\u0627\u0623\u0625\u0622\u0624\u0626\u0621\u06F3def3DEF", "\u0627\u0623\u0625\u0622\u0624\u0626\u0621\u06FDEF3", "\u0627\u0623\u0625\u0622\u0624\u0626\u0621\u06F3def3"),
-		("\u0633\u0634\u0635\u0636\u06F4ghi4GHI", "\u0633\u0634\u0635\u0636\u06F4GHI4", "\u0633\u0634\u0635\u0636\u06F4ghi4"),
-		("\u062F\u0630\u0631\u0632\u0698\u06F5jkl5JKL", "\u062F\u0630\u0631\u0632\u0698\u06F5JKL5", "\u062F\u0630\u0631\u0632\u0698\u06F5jkl5"),
-		("\u062C\u0686\u062D\u062E\u06F6mno6MNO", "\u062C\u0686\u062D\u062E\u06F6MNO6", "\u062C\u0686\u062D\u062E\u06F6mno6"),
-		("\u0646\u0648\u0647\u06CC\u06F7pqrs7PQRS", "\u0646\u0648\u0647\u06CC\u06F7PQRS7", "\u0646\u0648\u0647\u06CC\u06F7pqrs7"),
-		("\u0641\u0642\u06A9\u06AF\u0644\u0645\u0643\u06F8tuv8TUV", "\u0641\u0642\u06A9\u06AF\u0644\u0645\u0643\u06F8TUV8", "\u0641\u0642\u06A9\u06AF\u0644\u0645\u0643\u06F8tuv8"),
-		("\u0637\u0638\u0639\u063A\u06F9wxyz9WXYZ", "\u0637\u0638\u0639\u063A\u06F9WXYZ9", "\u0637\u0638\u0639\u063A\u06F9wxyz9"),
+		("\\u06F0" + PUNCTUATION0, "\\u06F0" + PUNCTUATION0, "\\u06F0" + PUNCTUATION0),
+		("\\u06F1" + PUNCTUATION1, "\\u06F1" + PUNCTUATION1, "\\u06F1" + PUNCTUATION1),
+		("\\u0628\\u067E\\u062A\\u0629\\u062B\\u06F2abc2DEF", "\\u0628\\u067E\\u062A\\u0629\\u062B\\u06F2ABC2", "\\u0628\\u067E\\u062A\\u0629\\u062B\\u06F2abc2"),
+		("\\u0627\\u0623\\u0625\\u0622\\u0624\\u0626\\u0621\\u06F3def3DEF", "\\u0627\\u0623\\u0625\\u0622\\u0624\\u0626\\u0621\\u06FDEF3", "\\u0627\\u0623\\u0625\\u0622\\u0624\\u0626\\u0621\\u06F3def3"),
+		("\\u0633\\u0634\\u0635\\u0636\\u06F4ghi4GHI", "\\u0633\\u0634\\u0635\\u0636\\u06F4GHI4", "\\u0633\\u0634\\u0635\\u0636\\u06F4ghi4"),
+		("\\u062F\\u0630\\u0631\\u0632\\u0698\\u06F5jkl5JKL", "\\u062F\\u0630\\u0631\\u0632\\u0698\\u06F5JKL5", "\\u062F\\u0630\\u0631\\u0632\\u0698\\u06F5jkl5"),
+		("\\u062C\\u0686\\u062D\\u062E\\u06F6mno6MNO", "\\u062C\\u0686\\u062D\\u062E\\u06F6MNO6", "\\u062C\\u0686\\u062D\\u062E\\u06F6mno6"),
+		("\\u0646\\u0648\\u0647\\u06CC\\u06F7pqrs7PQRS", "\\u0646\\u0648\\u0647\\u06CC\\u06F7PQRS7", "\\u0646\\u0648\\u0647\\u06CC\\u06F7pqrs7"),
+		("\\u0641\\u0642\\u06A9\\u06AF\\u0644\\u0645\\u0643\\u06F8tuv8TUV", "\\u0641\\u0642\\u06A9\\u06AF\\u0644\\u0645\\u0643\\u06F8TUV8", "\\u0641\\u0642\\u06A9\\u06AF\\u0644\\u0645\\u0643\\u06F8tuv8"),
+		("\\u0637\\u0638\\u0639\\u063A\\u06F9wxyz9WXYZ", "\\u0637\\u0638\\u0639\\u063A\\u06F9WXYZ9", "\\u0637\\u0638\\u0639\\u063A\\u06F9wxyz9"),
 	),
 	"fi_FI": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u00E4\u00E5\u00E1\u00E2\u010D2ABC\u00C4\u00C5\u00C1\u00C2\u010C", "ABC\u00C4\u00C5\u00C1\u00C2\u010C2", "abc\u00E4\u00E5\u00E1\u00E2\u010D2"),
-		("def\u00E9\u01113DEF\u00C9\u0110", "DEF\u00C9\u01103", "def\u00E9\u01113"),
-		("ghi\u01E7\u01E54GHI\u01E6\u01E4", "GHI\u01E6\u01E44", "ghi\u01E7\u01E54"),
-		("jkl\u01E95JKL\u01E8", "JKL\u01E85", "jkl\u01E95"),
-		("mno\u00F6\u00F8\u014B\u00F56MNO\u00D6\u00D8\u014A\u00D5", "MNO\u00D6\u00D8\u014A\u00D56", "mno\u00F6\u00F8\u014B\u00F56"),
-		("pqrs\u01617PQRS\u0160", "PQRS\u01607", "pqrs\u01617"),
-		("tuv\u00FC\u01678TUV\u00DC\u0166", "TUV\u00DC\u01668", "tuv\u00FC\u01678"),
-		("wxyz\u017E\u0292\u01EF9WXYZ\u017D\u01B7\u01EE", "WXYZ\u017D\u01B7\u01EE9", "wxyz\u017E\u0292\u01EF9")
+		("abc\\u00E4\\u00E5\\u00E1\\u00E2\\u010D2ABC\\u00C4\\u00C5\\u00C1\\u00C2\\u010C", "ABC\\u00C4\\u00C5\\u00C1\\u00C2\\u010C2", "abc\\u00E4\\u00E5\\u00E1\\u00E2\\u010D2"),
+		("def\\u00E9\\u01113DEF\\u00C9\\u0110", "DEF\\u00C9\\u01103", "def\\u00E9\\u01113"),
+		("ghi\\u01E7\\u01E54GHI\\u01E6\\u01E4", "GHI\\u01E6\\u01E44", "ghi\\u01E7\\u01E54"),
+		("jkl\\u01E95JKL\\u01E8", "JKL\\u01E85", "jkl\\u01E95"),
+		("mno\\u00F6\\u00F8\\u014B\\u00F56MNO\\u00D6\\u00D8\\u014A\\u00D5", "MNO\\u00D6\\u00D8\\u014A\\u00D56", "mno\\u00F6\\u00F8\\u014B\\u00F56"),
+		("pqrs\\u01617PQRS\\u0160", "PQRS\\u01607", "pqrs\\u01617"),
+		("tuv\\u00FC\\u01678TUV\\u00DC\\u0166", "TUV\\u00DC\\u01668", "tuv\\u00FC\\u01678"),
+		("wxyz\\u017E\\u0292\\u01EF9WXYZ\\u017D\\u01B7\\u01EE", "WXYZ\\u017D\\u01B7\\u01EE9", "wxyz\\u017E\\u0292\\u01EF9")
 	),
 	"lv_LV": (
 		(None, None, None),
 		(None, None, None),
-		("a\u0101bc\u010D2A\u0100BC\u010C", "A\u0100BC\u010C2", "a\u0101bc\u010D2"),
-		("de\u0113f3DE\u0112F", "DE\u0112F3", "de\u0113f3"),
-		("g\u0123hi\u012B4G\u0122HI\u012A", "G\u0122HI\u012A4", "g\u0123hi\u012B4"),
-		("jk\u0137l\u013C5JK\u0136L\u013B", "JK\u0136L\u013B5", "jk\u0137l\u013C5"),
-		("mn\u0146o6MN\u0145O", "MN\u0145O6", "mn\u0146o6"),
-		("prs\u01617qPRS\u0160Q", "PRS\u01607Q", "prs\u01617q"),
-		("tu\u016Bv8TU\u016AV", "TU\u016AV8", "tu\u016Bv8"),
-		("z\u017E9wxyWXYZ\u017D", "Z\u017D9WXY", "z\u017E9wxy")
+		("a\\u0101bc\\u010D2A\\u0100BC\\u010C", "A\\u0100BC\\u010C2", "a\\u0101bc\\u010D2"),
+		("de\\u0113f3DE\\u0112F", "DE\\u0112F3", "de\\u0113f3"),
+		("g\\u0123hi\\u012B4G\\u0122HI\\u012A", "G\\u0122HI\\u012A4", "g\\u0123hi\\u012B4"),
+		("jk\\u0137l\\u013C5JK\\u0136L\\u013B", "JK\\u0136L\\u013B5", "jk\\u0137l\\u013C5"),
+		("mn\\u0146o6MN\\u0145O", "MN\\u0145O6", "mn\\u0146o6"),
+		("prs\\u01617qPRS\\u0160Q", "PRS\\u01607Q", "prs\\u01617q"),
+		("tu\\u016Bv8TU\\u016AV", "TU\\u016AV8", "tu\\u016Bv8"),
+		("z\\u017E9wxyWXYZ\\u017D", "Z\\u017D9WXY", "z\\u017E9wxy")
 	),
 	"nl_NL": (
 		(None, None, None),
 		(None, None, None),
 		(None, None, None),
-		("def\u00EB3DEF\u00CB", "DEF\u00CB3", "def\u00EB3"),
-		("ghi\u00EF4GHI\u00CF", "GHI\u00CF4", "ghi\u00EF4"),
+		("def\\u00EB3DEF\\u00CB", "DEF\\u00CB3", "def\\u00EB3"),
+		("ghi\\u00EF4GHI\\u00CF", "GHI\\u00CF4", "ghi\\u00EF4"),
 		(None, None, None),
 		(None, None, None),
 		(None, None, None),
@@ -140,62 +140,62 @@
 	"pl_PL": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u0105\u01072ABC\u0104\u0106", "ABC\u0104\u01062", "abc\u0105\u01072"),
-		("def\u01193DEF\u0118", "DEF\u01183", "def\u01193"),
+		("abc\\u0105\\u01072ABC\\u0104\\u0106", "ABC\\u0104\\u01062", "abc\\u0105\\u01072"),
+		("def\\u01193DEF\\u0118", "DEF\\u01183", "def\\u01193"),
 		(None, None, None),
-		("jkl\u01425JKL\u0141", "JKL\u01415", "jkl\u01425"),
-		("mno\u0144\u00F36MNO\u0143\u00D3", "MNO\u0143\u00D36", "mno\u0144\u00F36"),
-		("pqrs\u015B7PQRS\u015A", "PQRS\u015A7", "pqrs\u015B7"),
+		("jkl\\u01425JKL\\u0141", "JKL\\u01415", "jkl\\u01425"),
+		("mno\\u0144\\u00F36MNO\\u0143\\u00D3", "MNO\\u0143\\u00D36", "mno\\u0144\\u00F36"),
+		("pqrs\\u015B7PQRS\\u015A", "PQRS\\u015A7", "pqrs\\u015B7"),
 		(None, None, None),
-		("wxyz\u017A\u017C9WXYZ\u0179\u017B", "WXYZ\u0179\u017B9", "wxyz\u017A\u017C9")
+		("wxyz\\u017A\\u017C9WXYZ\\u0179\\u017B", "WXYZ\\u0179\\u017B9", "wxyz\\u017A\\u017C9")
 	),
 	"ru_RU": (
 		(None, None, None),
 		(None, None, None),
-		("\u0430\u0431\u0432\u0433abc2\u0410\u0411\u0412\u0413ABC", "\u0410\u0411\u0412\u0413ABC2", "\u0430\u0431\u0432\u0433abc2"),
-		("\u0434\u0435\u0451\u0436\u0437def3\u0414\u0415\u0431\u0416\u0417DEF", "\u0414\u0415\u0431\u0416\u0417DEF3", "\u0434\u0435\u0451\u0436\u0437def3"),
-		("\u0438\u0439\u043A\u043Bghi4\u0418\u0419\u041A\u041BGHI", "\u0418\u0419\u041A\u041BGHI4", "\u0438\u0439\u043A\u043Bghi4"),
-		("\u043C\u043D\u043E\u043Fjkl5\u041C\u041D\u041E\u041FJKL", "\u041C\u041D\u041E\u041FJKL5", "\u043C\u043D\u043E\u043Fjkl5"),
-		("\u0440\u0441\u0442\u0443mno6\u0420\u0421\u0422\u0423MNO", "\u0420\u0421\u0422\u0423MNO6", "\u0440\u0441\u0442\u0443mno6"),
-		("\u0444\u0445\u0446\u0447pqrs7\u0424\u0425\u0426\u0427PQRS", "\u0424\u0425\u0426\u0427PQRS7", "\u0444\u0445\u0446\u0447pqrs7"),
-		("\u0448\u0449\u044A\u044Btuv8\u0428\u0429\u042C\u042BTUV", "\u0428\u0429\u042A\u042BTUV8", "\u0448\u0449\u044A\u044Btuv8"),
-		("\u044C\u044D\u044E\u044Fwxyz9\u042C\u042D\u042E\u042FWXYZ", "\u042C\u042D\u042E\u042FWXYZ9", "\u044C\u044D\u044E\u044Fwxyz9")
+		("\\u0430\\u0431\\u0432\\u0433abc2\\u0410\\u0411\\u0412\\u0413ABC", "\\u0410\\u0411\\u0412\\u0413ABC2", "\\u0430\\u0431\\u0432\\u0433abc2"),
+		("\\u0434\\u0435\\u0451\\u0436\\u0437def3\\u0414\\u0415\\u0431\\u0416\\u0417DEF", "\\u0414\\u0415\\u0431\\u0416\\u0417DEF3", "\\u0434\\u0435\\u0451\\u0436\\u0437def3"),
+		("\\u0438\\u0439\\u043A\\u043Bghi4\\u0418\\u0419\\u041A\\u041BGHI", "\\u0418\\u0419\\u041A\\u041BGHI4", "\\u0438\\u0439\\u043A\\u043Bghi4"),
+		("\\u043C\\u043D\\u043E\\u043Fjkl5\\u041C\\u041D\\u041E\\u041FJKL", "\\u041C\\u041D\\u041E\\u041FJKL5", "\\u043C\\u043D\\u043E\\u043Fjkl5"),
+		("\\u0440\\u0441\\u0442\\u0443mno6\\u0420\\u0421\\u0422\\u0423MNO", "\\u0420\\u0421\\u0422\\u0423MNO6", "\\u0440\\u0441\\u0442\\u0443mno6"),
+		("\\u0444\\u0445\\u0446\\u0447pqrs7\\u0424\\u0425\\u0426\\u0427PQRS", "\\u0424\\u0425\\u0426\\u0427PQRS7", "\\u0444\\u0445\\u0446\\u0447pqrs7"),
+		("\\u0448\\u0449\\u044A\\u044Btuv8\\u0428\\u0429\\u042C\\u042BTUV", "\\u0428\\u0429\\u042A\\u042BTUV8", "\\u0448\\u0449\\u044A\\u044Btuv8"),
+		("\\u044C\\u044D\\u044E\\u044Fwxyz9\\u042C\\u042D\\u042E\\u042FWXYZ", "\\u042C\\u042D\\u042E\\u042FWXYZ9", "\\u044C\\u044D\\u044E\\u044Fwxyz9")
 	),
 	"sv_SE": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u00E5\u00E4\u00E0\u00E6\u00E1\u010D2ABC\u00C5\u00C4\u00C0\u00C6\u00C1\u010C", "ABC\u00C5\u00C4\u00C0\u00C6\u00C1\u010C2", "abc\u00E5\u00E4\u00E0\u00E6\u00E1\u010D2"),
-		("def\u00E9\u01113DEF\u00C9\u0110", "DEF\u00C9\u01103", "def\u00E9\u01113"),
-		("ghi\u00EF4GHI\u00CF", "GHI\u00CF4", "ghi\u00EF4"),
-		(None, None, None),
-		("mno\u00F6\u00F8\u014B6MNO\u00D6\u00D8\u014A", "MNO\u00D6\u00D8\u014A6", "mno\u00F6\u00F8\u014B6"),
-		("pqrs\u01617PQRS\u0160", "PQRS\u01607", "pqrs\u01617"),
-		("tuv\u00FC\u01678TUV\u00DC\u0166", "TUV\u00DC\u01668", "tuv\u00FC\u01678"),
-		("wxyz\u017E9WXYZ\u017D", "WXYZ\u017D9", "wxyz\u017E9")
+		("abc\\u00E5\\u00E4\\u00E0\\u00E6\\u00E1\\u010D2ABC\\u00C5\\u00C4\\u00C0\\u00C6\\u00C1\\u010C", "ABC\\u00C5\\u00C4\\u00C0\\u00C6\\u00C1\\u010C2", "abc\\u00E5\\u00E4\\u00E0\\u00E6\\u00E1\\u010D2"),
+		("def\\u00E9\\u01113DEF\\u00C9\\u0110", "DEF\\u00C9\\u01103", "def\\u00E9\\u01113"),
+		("ghi\\u00EF4GHI\\u00CF", "GHI\\u00CF4", "ghi\\u00EF4"),
+		(None, None, None),
+		("mno\\u00F6\\u00F8\\u014B6MNO\\u00D6\\u00D8\\u014A", "MNO\\u00D6\\u00D8\\u014A6", "mno\\u00F6\\u00F8\\u014B6"),
+		("pqrs\\u01617PQRS\\u0160", "PQRS\\u01607", "pqrs\\u01617"),
+		("tuv\\u00FC\\u01678TUV\\u00DC\\u0166", "TUV\\u00DC\\u01668", "tuv\\u00FC\\u01678"),
+		("wxyz\\u017E9WXYZ\\u017D", "WXYZ\\u017D9", "wxyz\\u017E9")
 	),
 	"sk_SK": (
 		(None, None, None),
 		(None, None, None),
-		("abc\u00E1\u010D\u00E42ABC\u00C1\u010C\u00C4", "ABC\u00C1\u010C\u00C42", "abc\u00E1\u010D\u00E42"),
-		("def\u010F\u00E93DEF\u010E\u00C9", "DEF\u010E\u00C93", "def\u010F\u00E93"),
-		("ghi\u00ED4GHI\u00CD", "GHI\u00CD4", "ghiGHI\u00CD4"),
-		("jkl\u013A\u013E5JKL\u0139\u013D", "JKL\u0139\u013D5", "jkl\u013A\u013E5"),
-		("mno\u0148\u00F3\u00F4\u00F6\u01516MNO\u0147\u00D3\u00D4\u00D6\u0150", "MNO\u0147\u00D3\u00D4\u00D6\u01506", "mno\u0148\u00F3\u00F4\u00F6\u01516"),
-		("pqrs\u0155\u01617PQRS\u0154\u0160", "PQRS\u0154\u01607", "pqrs\u0155\u01617"),
-		("tuv\u0165\u00FA\u00FC\u01718TUV\u0164\u00DA\u00DC\u0170", "TUV\u0164\u00DA\u00DC\u01708", "tuv\u0165\u00FA\u00FC\u01718"),
-		("wxyz\u00FD\u017E9WXYZ\u00DD\u017D", "WXYZ\u00DD\u017D9", "wxyz\u00FD\u017E9")
+		("abc\\u00E1\\u010D\\u00E42ABC\\u00C1\\u010C\\u00C4", "ABC\\u00C1\\u010C\\u00C42", "abc\\u00E1\\u010D\\u00E42"),
+		("def\\u010F\\u00E93DEF\\u010E\\u00C9", "DEF\\u010E\\u00C93", "def\\u010F\\u00E93"),
+		("ghi\\u00ED4GHI\\u00CD", "GHI\\u00CD4", "ghiGHI\\u00CD4"),
+		("jkl\\u013A\\u013E5JKL\\u0139\\u013D", "JKL\\u0139\\u013D5", "jkl\\u013A\\u013E5"),
+		("mno\\u0148\\u00F3\\u00F4\\u00F6\\u01516MNO\\u0147\\u00D3\\u00D4\\u00D6\\u0150", "MNO\\u0147\\u00D3\\u00D4\\u00D6\\u01506", "mno\\u0148\\u00F3\\u00F4\\u00F6\\u01516"),
+		("pqrs\\u0155\\u01617PQRS\\u0154\\u0160", "PQRS\\u0154\\u01607", "pqrs\\u0155\\u01617"),
+		("tuv\\u0165\\u00FA\\u00FC\\u01718TUV\\u0164\\u00DA\\u00DC\\u0170", "TUV\\u0164\\u00DA\\u00DC\\u01708", "tuv\\u0165\\u00FA\\u00FC\\u01718"),
+		("wxyz\\u00FD\\u017E9WXYZ\\u00DD\\u017D", "WXYZ\\u00DD\\u017D9", "wxyz\\u00FD\\u017E9")
 	),
 	"uk_UA": (
 		(None, None, None),
 		(None, None, None),
-		("\u0430\u0431\u0432\u0433\u0491abc2\u0410\u0411\u0412\u0413\u0490ABC", "\u0410\u0411\u0412\u0413\u0490ABC2", "\u0430\u0431\u0432\u0433\u0491abc2"),
-		("\u0434\u0435\u0454\u0436\u0437def3\u0414\u0415\u0404\u0416\u0417DEF", "\u0414\u0415\u0404\u0416\u0417\u0401DEF3", "\u0434\u0435\u0454\u0436\u0437def3"),
-		("\u0438\u0456\u0457\u0439\u043A\u043Bghi4\u0418\u0406\u0407\u0419\u041A\u041BGHI", "\u0418\u0406\u0407\u0419\u041A\u041BGHI4", "\u0438\u0456\u0457\u0439\u043A\u043Bghi4"),
-		("\u043C\u043D\u043E\u043Fjkl5\u041C\u041D\u041E\u041FJKL", "\u041C\u041D\u041E\u041FDJKL5", "\u043C\u043D\u043E\u043Fjkl5"),
-		("\u0440\u0441\u0442\u0443mno6\u0420\u0421\u0422\u0423MNO", "\u0420\u0421\u0422\u0423MNO6", "\u0440\u0441\u0442\u0443mno6"),
-		("\u0444\u0445\u0446\u0447pqrs7\u0424\u0425\u0426\u0427PQRS", "\u0424\u0425\u0426\u0427PQRS7", "\u0444\u0445\u0446\u0447pqrs7"),
-		("\u0448\u0449tuv8\u0428\u0429TUV", "\u0428\u0429TUV8", "\u0448\u0449tuv8"),
-		("\u044E\u044F\u044Cwxyz9\u042E\u042F\u042CWXYZ", "\u042E\u042F\u042CWXYZ9", "\u044E\u044F\u044Cwxyz9")
+		("\\u0430\\u0431\\u0432\\u0433\\u0491abc2\\u0410\\u0411\\u0412\\u0413\\u0490ABC", "\\u0410\\u0411\\u0412\\u0413\\u0490ABC2", "\\u0430\\u0431\\u0432\\u0433\\u0491abc2"),
+		("\\u0434\\u0435\\u0454\\u0436\\u0437def3\\u0414\\u0415\\u0404\\u0416\\u0417DEF", "\\u0414\\u0415\\u0404\\u0416\\u0417\\u0401DEF3", "\\u0434\\u0435\\u0454\\u0436\\u0437def3"),
+		("\\u0438\\u0456\\u0457\\u0439\\u043A\\u043Bghi4\\u0418\\u0406\\u0407\\u0419\\u041A\\u041BGHI", "\\u0418\\u0406\\u0407\\u0419\\u041A\\u041BGHI4", "\\u0438\\u0456\\u0457\\u0439\\u043A\\u043Bghi4"),
+		("\\u043C\\u043D\\u043E\\u043Fjkl5\\u041C\\u041D\\u041E\\u041FJKL", "\\u041C\\u041D\\u041E\\u041FDJKL5", "\\u043C\\u043D\\u043E\\u043Fjkl5"),
+		("\\u0440\\u0441\\u0442\\u0443mno6\\u0420\\u0421\\u0422\\u0423MNO", "\\u0420\\u0421\\u0422\\u0423MNO6", "\\u0440\\u0441\\u0442\\u0443mno6"),
+		("\\u0444\\u0445\\u0446\\u0447pqrs7\\u0424\\u0425\\u0426\\u0427PQRS", "\\u0424\\u0425\\u0426\\u0427PQRS7", "\\u0444\\u0445\\u0446\\u0447pqrs7"),
+		("\\u0448\\u0449tuv8\\u0428\\u0429TUV", "\\u0428\\u0429TUV8", "\\u0448\\u0449tuv8"),
+		("\\u044E\\u044F\\u044Cwxyz9\\u042E\\u042F\\u042CWXYZ", "\\u042E\\u042F\\u042CWXYZ9", "\\u044E\\u044F\\u044Cwxyz9")
 	)
 }
 
diff -ruN o/lib/python/Tools/Transponder.py pc/lib/python/Tools/Transponder.py
--- o/lib/python/Tools/Transponder.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Tools/Transponder.py	2025-07-11 16:39:46.978635696 +0300
@@ -257,7 +257,7 @@
 			eDVBFrontendParametersATSC.System_DVB_C_ANNEX_B: "DVB-C ANNEX B"}.get(tp.get("system"))
 	elif tunertype != "None":
 		print("ConvertToHumanReadable: no or unknown tunertype in tpdata dict for tunertype:", tunertype)
-	for k, v in tp.items():
+	for k, v in list(tp.items()):
 		if k not in ret:
 			ret[k] = v
 	return ret
diff -ruN o/lib/python/Tools/XMLTools.py pc/lib/python/Tools/XMLTools.py
--- o/lib/python/Tools/XMLTools.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/python/Tools/XMLTools.py	2025-07-11 16:39:46.978635696 +0300
@@ -27,7 +27,7 @@
 
 
 def stringToXML(text):
-	illegal_xml_chars_RE = re.compile('[\x00-\x08\x0b\x0c\x0e-\x1F\uD800-\uDFFF\uFFFE\uFFFF]')
+	illegal_xml_chars_RE = re.compile('[\x00-\x08\x0b\x0c\x0e-\x1F\\uD800-\\uDFFF\\uFFFE\\uFFFF]')
 	if isinstance(text, (bytes, bytearray)):
 		text = illegal_xml_chars_RE.sub('', text.decode('utf-8'))
 	else:
diff -ruN o/lib/service/servicedvb.cpp pc/lib/service/servicedvb.cpp
--- o/lib/service/servicedvb.cpp	2025-07-11 16:39:11.181577568 +0300
+++ pc/lib/service/servicedvb.cpp	2025-07-11 16:39:46.979635641 +0300
@@ -191,7 +191,6 @@
 	eBouquet *bouquet = NULL;
 	if ((err = db->getBouquet(ref, bouquet)) != 0)
 	{
-		eDebug("[eStaticServiceDVBBouquetInformation] getName failed.. getBouquet failed!");
 		return -1;
 	}
 
@@ -1061,6 +1060,8 @@
 		CONNECT(m_service_handler.serviceEvent, eDVBServicePlay::serviceEvent);
 	CONNECT(m_service_handler_timeshift.serviceEvent, eDVBServicePlay::serviceEventTimeshift);
 	CONNECT(m_event_handler.m_eit_changed, eDVBServicePlay::gotNewEvent);
+	xineLib = cXineLib::getInstance();
+	xine_connection = CONNECT(xineLib->m_event, eDVBServicePlay::video_event);
 	CONNECT(m_subtitle_sync_timer->timeout, eDVBServicePlay::checkSubtitleTiming);
 	CONNECT(m_nownext_timer->timeout, eDVBServicePlay::updateEpgCacheNowNext);
 }
@@ -1090,6 +1091,7 @@
 			meta.updateMeta(m_reference.path);
 		}
 	}
+	xine_connection.disconnect();
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 }
 
@@ -1234,6 +1236,29 @@
 			m_event((iPlayableService*)this, evUpdatedInfo);
 
 		m_event((iPlayableService*)this, evNewProgramInfo);
+
+		ePtr<iDVBDemux> demux;
+		if ((!m_is_pvr && !m_service_handler.getDataDemux(demux)) & !m_timeshift_enabled)
+		{
+			printf("Start live TV!\n");
+
+			demux->createTSRecorder(m_openpliPC_record);
+			if (!m_openpliPC_record)
+				return;
+
+			if (m_openpliPC_fd < 0)
+			{
+				m_openpliPC_record = 0;
+				return;
+			}
+			m_openpliPC_record->setTargetFD(m_openpliPC_fd);
+			m_openpliPC_record->setTargetFilename(m_openpliPC_file);
+			m_openpliPC_record->enableAccessPoints(false);
+			updateTimeshiftPids(); // workaround to set PIDs
+			m_openpliPC_record->start();
+
+			printf("Start live TV END\n");
+		}
 		break;
 	}
 	case eDVBServicePMTHandler::eventPreStart:
@@ -1380,6 +1405,9 @@
 	else
 		m_event(this, evStart);
 
+	m_openpliPC_file = std::string("/tmp/ENIGMA_FIFO");
+	m_openpliPC_fd = ::open(m_openpliPC_file.c_str(), O_RDWR);
+
 	if (m_is_stream)
 	{
 		/*
@@ -1395,11 +1423,11 @@
 
 		type = eDVBServicePMTHandler::streamclient;
 	}
-
+/*
 	m_first_program_info = 1;
 	ePtr<iTsSource> source = createTsSource(service, packetsize);
 	ret = m_service_handler.tuneExt(service, source, service.path.c_str(), m_cue, false, m_dvb_service, type, scrambled);
-
+*/
 	if (m_is_pvr)
 	{
 		/* inject EIT if there is a stored one */
@@ -1415,6 +1443,18 @@
 		}
 		m_event(this, evStart);
 	}
+
+	cXineLib *xineLib = cXineLib::getInstance();
+	if (m_timeshift_changed)
+		xineLib->setScrambled(false);
+	else
+		xineLib->setScrambled(scrambled);
+
+	m_first_program_info = 1;
+	ePtr<iTsSource> source = createTsSource(service, packetsize);
+	ret = m_service_handler.tuneExt(service, source, service.path.c_str(), m_cue, false, m_dvb_service, type, scrambled);
+
+//	return 0;
 	return ret;
 }
 
@@ -1457,6 +1497,18 @@
 
 	stopTimeshift(); /* in case timeshift was enabled, remove buffer etc. */
 
+	if (m_openpliPC_record)
+	{
+		m_openpliPC_record->stop();
+		m_openpliPC_record = 0;
+	}
+	if (m_openpliPC_fd > 0)
+	{
+		printf("close(m_openpliPC_fd) %d\n", m_openpliPC_fd);
+		close(m_openpliPC_fd);
+		m_openpliPC_fd = -1;
+	}
+
 	m_service_handler_timeshift.free();
 	m_service_handler.free();
 
@@ -1634,7 +1686,7 @@
 {
 	eDebug("[eDVBServicePlay] seekTo %lld", to);
 
-	if (!m_decode_demux)
+	if (!m_decode_demux) /*??????????????????*/
 		return -1;
 
 	ePtr<iDVBPVRChannel> pvr_channel;
@@ -1649,6 +1701,9 @@
 	m_dvb_subtitle_pages.clear();
 	m_subtitle_pages.clear();
 
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->SeekTo(to);
+
 	return 0;
 }
 
@@ -1678,6 +1733,10 @@
 	m_cue->seekTo(mode, to);
 	m_dvb_subtitle_pages.clear();
 	m_subtitle_pages.clear();
+
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->VideoRewT(to/90*direction);
+
 	return 0;
 }
 
@@ -1694,12 +1753,9 @@
 	int r = 0;
 
 		/* if there is a decoder, use audio or video PTS */
-	if (m_decoder)
-	{
-		r = m_decoder->getPTS(0, pos);
-		if (r)
-			return r;
-	}
+	r = xineLib->getPTS(pos);
+	if (r)
+		return r;
 
 		/* fixup */
 	return pvr_channel->getCurrentPosition(m_decode_demux, pos, m_decoder);
@@ -1899,22 +1955,21 @@
 	switch (w)
 	{
 	case sVideoHeight:
-		if (m_decoder) return m_decoder->getVideoHeight();
+		return xineLib->getVideoHeight();
 		break;
 	case sVideoWidth:
-		if (m_decoder) return m_decoder->getVideoWidth();
+		return xineLib->getVideoWidth();
 		break;
 	case sFrameRate:
-		if (m_decoder) return m_decoder->getVideoFrameRate();
+		return xineLib->getVideoFrameRate();
 		break;
 	case sProgressive:
-		if (m_decoder) return m_decoder->getVideoProgressive();
+		return xineLib->getProgressive();
 		break;
 	case sAspect:
 	{
 		int aspect = -1;
-		if (m_decoder)
-			aspect = m_decoder->getVideoAspect();
+		aspect = xineLib->getVideoAspect();
 		if (aspect == -1 && no_program_info)
 			break;
 		else if (aspect == -1 && !program.videoStreams.empty() && program.videoStreams[0].component_tag != -1)
@@ -2142,6 +2197,9 @@
 	if (m_decoder->set())
 		return -5;
 
+	cXineLib *xineLib = cXineLib::getInstance();
+	xineLib->selectAudioStream(i); // switch audio track
+
 	return ret;
 }
 
@@ -2234,7 +2292,12 @@
 
 	m_current_audio_pid = apid;
 
-	if ((m_is_primary || !m_noaudio) && m_decoder->setAudioPID(apid, apidtype))
+	bool amode = false;  // if == true, radio mode
+
+	if (program.videoStreams.empty())
+		amode = true;
+
+	if ((m_is_primary || !m_noaudio) && m_decoder->setAudioPID(apid, apidtype, amode))
 	{
 		eDebug("[eDVBServicePlay] set audio pid %04x failed", apid);
 		return -4;
@@ -2795,7 +2858,7 @@
 
 void eDVBServicePlay::updateTimeshiftPids()
 {
-	if (!m_record)
+	if (!m_openpliPC_record)
 		return;
 
 	eDVBServicePMTHandler::program program;
@@ -2860,13 +2923,16 @@
 				);
 
 		for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
-			m_record->addPID(*i);
+	//		if (m_openpliPC_record)
+			m_openpliPC_record->addPID(*i);
 
 		for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
-			m_record->removePID(*i);
+	//		if (m_openpliPC_record)
+			m_openpliPC_record->removePID(*i);
 
 		if (timing_pid != -1)
-			m_record->setTimingPID(timing_pid, timing_pid_type, timing_stream_type);
+	//		if (m_openpliPC_record)
+			m_openpliPC_record->setTimingPID(timing_pid, timing_pid_type, timing_stream_type);
 	}
 }
 
@@ -2890,6 +2956,32 @@
 	/* free the timeshift service handler, we need the resources */
 	m_service_handler_timeshift.free();
 
+//Start LiveTV OpenPLiPC
+	start();
+
+	ePtr<iDVBDemux> demux;
+	if (!m_is_pvr && !m_service_handler.getDataDemux(demux))
+	{
+		printf("Start live TV, end Timeshift!\n");
+
+		demux->createTSRecorder(m_openpliPC_record);
+		if (!m_openpliPC_record)
+			return;
+
+		if (m_openpliPC_fd < 0)
+		{
+			m_openpliPC_record = 0;
+			return;
+		}
+		m_openpliPC_record->setTargetFD(m_openpliPC_fd);
+		m_openpliPC_record->setTargetFilename(m_openpliPC_file);
+		m_openpliPC_record->enableAccessPoints(false);
+		updateTimeshiftPids(); // workaround to set PIDs
+		m_openpliPC_record->start();
+
+		printf("Start live TV END\n");
+	}
+
 	updateDecoder(true);
 }
 
@@ -2965,11 +3057,24 @@
 	eDebug("[eDVBServicePlay] switchToTimeshift, in pause mode now.");
 	pause();
 	updateDecoder(true); /* mainly to switch off PCR, and to set pause */
+
+// stop openpliPC
+	if (m_openpliPC_record)
+	{
+		m_openpliPC_record->stop();
+		m_openpliPC_record = 0;
+	}
+	if (m_openpliPC_fd > 0)
+	{
+		printf("Switch from Live TV to Timeshift, close(m_openpliPC_fd) %d\n", m_openpliPC_fd);
+		close(m_openpliPC_fd);
+		m_openpliPC_fd = -1;
+	}
 }
 
 void eDVBServicePlay::updateDecoder(bool sendSeekableStateChanged)
 {
-	int vpid = -1, vpidtype = -1, pcrpid = -1, tpid = -1, achannel = -1, ac3_delay=-1, pcm_delay=-1;
+	int vpid = -1, vpidtype = -1, pcrpid = -1, tpid = -1, achannel = -1, ac3_delay=-1, pcm_delay=-1, vstreamtype=-1;
 	bool mustPlay = false;
 
 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
@@ -2991,6 +3096,7 @@
 				{
 					vpid = i->pid;
 					vpidtype = i->type;
+					vstreamtype = i->orig_streamtype;
 				}
 				if (i != program.videoStreams.begin())
 					eDebugNoNewLine(", ");
@@ -3069,7 +3175,11 @@
 			setPCMDelay(pcm_delay == -1 ? 0 : pcm_delay);
 		}
 
-		m_decoder->setVideoPID(vpid, vpidtype);
+		/* Viewing recordings and video in PVR Mode */
+		if (m_is_pvr)
+			vstreamtype = 0;
+
+		m_decoder->setVideoPID(vpid, vpidtype, vstreamtype);
 		m_have_video_pid = (vpid > 0 && vpid < 0x2000);
 
 		if (!m_noaudio)
@@ -3148,6 +3258,12 @@
 
 	if (sendSeekableStateChanged)
 		m_event((iPlayableService*)this, evSeekableStatusChanged);
+
+	if (m_is_paused) // need?
+	{
+		unpause();
+		pause();
+	}
 }
 
 void eDVBServicePlay::loadCuesheet()
@@ -3516,7 +3632,10 @@
 	{
 		int subtitledelay = 0;
 		pts_t pts;
-		m_decoder->getPTS(0, pts);
+		pts_t pos = 0;
+//		xineLib->getPTS(pos);
+		xineLib->getPTS(pts);
+
 		if (m_is_pvr || m_timeshift_enabled)
 		{
 			eDebug("[eDVBServicePlay] Subtitle in recording/timeshift");
@@ -3552,10 +3671,6 @@
 	{
 		return;
 	}
-	if (m_decoder)
-	{
-		m_decoder->getPTS(0, pos);
-	}
 
 	while (1)
 	{
@@ -3578,6 +3693,8 @@
 		else
 			return;
 
+		xineLib->getPTS(pos);
+
 		// If subtitle is overdue or within 20ms the video timing then display it.
 		// If not, pause subtitle processing until the subtitle should be shown
 		int diff = show_time - pos;
@@ -3609,8 +3726,7 @@
 	if (m_subtitle_widget)
 	{
 		pts_t pos = 0;
-		if (m_decoder)
-			m_decoder->getPTS(0, pos);
+		xineLib->getPTS(pos);
 
 		// Where subtitles are delivered out of sync with video, only treat subtitles in the past as having bad timing.
 		// Those that are delivered too early are cached for displaying at the appropriate later time
@@ -3730,7 +3846,7 @@
 		if (!m_noaudio)
 			selectAudioStream();
 		else
-			m_decoder->setAudioPID(-1, -1);
+			m_decoder->setAudioPID(-1, -1, -1);
 
 		m_decoder->set();
 	}
diff -ruN o/lib/service/servicedvbfcc.cpp pc/lib/service/servicedvbfcc.cpp
--- o/lib/service/servicedvbfcc.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/service/servicedvbfcc.cpp	2025-07-11 16:39:46.979635641 +0300
@@ -371,7 +371,6 @@
 		setAC3Delay(ac3_delay == -1 ? 0 : ac3_delay);
 		setPCMDelay(pcm_delay == -1 ? 0 : pcm_delay);
 
-		m_decoder->setVideoPID(vpid, vpidtype);
 		selectAudioStream();
 
 		if (!(m_is_pvr || m_is_stream || m_timeshift_active))
diff -ruN o/lib/service/servicedvb.h pc/lib/service/servicedvb.h
--- o/lib/service/servicedvb.h	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/service/servicedvb.h	2025-07-11 16:39:46.980635587 +0300
@@ -9,6 +9,8 @@
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
 #include <lib/dvb/radiotext.h>
+#include <lib/dvb/filepush.h>
+#include <lib/gdi/xineLib.h>
 
 class eStaticServiceDVBInformation;
 class eStaticServiceDVBBouquetInformation;
@@ -248,6 +250,11 @@
 	ePtr<iDVBTSRecorder> m_record;
 	std::set<int> m_pids_active;
 
+		/* openpliPC */
+	ePtr<iDVBTSRecorder> m_openpliPC_record;
+	std::string m_openpliPC_file;
+	int m_openpliPC_fd;
+
 	void updateTimeshiftPids();
 
 	void resetTimeshift(int start);
@@ -321,6 +328,9 @@
 	void video_event(struct iTSMPEGDecoder::videoEvent);
 
 	virtual ePtr<iTsSource> createTsSource(eServiceReferenceDVB &ref, int packetsize = 188);
+
+	sigc::connection xine_connection;
+	cXineLib* xineLib;
 };
 
 class eStaticServiceDVBBouquetInformation: public iStaticServiceInformation
diff -ruN o/lib/service/servicedvd.cpp pc/lib/service/servicedvd.cpp
--- o/lib/service/servicedvd.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/service/servicedvd.cpp	2025-07-11 16:39:46.980635587 +0300
@@ -1030,7 +1030,7 @@
 	if (f == NULL)
 	{
 		// Determine cue filename
-		filename = "/home/root/.dvdcuts/";
+		filename = "/media/hdd/.dvdcuts/";
 		if (m_ddvd_titlestring[0] != '\0')
 			filename += m_ddvd_titlestring;
 		else
@@ -1125,8 +1125,8 @@
 	if (f == NULL)
 	{
 		// Determine cue filename
-		filename = "/home/root/.dvdcuts";
-		if (stat("/home/root", &st) == 0 && stat(filename.c_str(), &st) != 0)
+		filename = "/media/hdd/.dvdcuts";
+		if (stat("/media/hdd", &st) == 0 && stat(filename.c_str(), &st) != 0)
 			if (mkdir(filename.c_str(), 0755))
 				return; // cannot create directory so no point in trying to save cue data
 			
diff -ruN o/lib/service/servicehdmi.cpp pc/lib/service/servicehdmi.cpp
--- o/lib/service/servicehdmi.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/service/servicehdmi.cpp	2025-07-11 16:39:46.981635532 +0300
@@ -123,9 +123,9 @@
 RESULT eServiceHDMI::start()
 {
 	m_decoder = new eTSMPEGDecoder(NULL, m_decoder_index);
-	m_decoder->setVideoPID(1, 0);
+	m_decoder->setVideoPID(1, 0, 0);
 	if (!m_noaudio)
-		m_decoder->setAudioPID(1, 0);
+		m_decoder->setAudioPID(1, 0, 0);
 	m_decoder->play();
 	m_event(this, evStart);
 	return 0;
diff -ruN o/lib/service/servicets.cpp pc/lib/service/servicets.cpp
--- o/lib/service/servicets.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/service/servicets.cpp	2025-07-11 16:39:46.981635532 +0300
@@ -251,8 +251,8 @@
 			return -1;
 		}
 	}
-	m_decoder->setVideoPID(m_vpid, eDVBVideo::MPEG2);
-	m_decoder->setAudioPID(m_apid, eDVBAudio::aMPEG);
+	m_decoder->setVideoPID(m_vpid, eDVBVideo::MPEG2, 0);
+	m_decoder->setAudioPID(m_apid, eDVBAudio::aMPEG, 0);
 	m_streamthread = new eStreamThread();
 	CONNECT(m_streamthread->m_event, eServiceTS::recv_event);
 	m_decoder->pause();
@@ -421,7 +421,7 @@
 	if (m_audioInfo) {
 		m_apid = m_audioInfo->audioStreams[i].pid;
 		eDebug("[servicets] audio track %d PID 0x%02x type %d\n", i, m_apid, m_audioInfo->audioStreams[i].type);
-		m_decoder->setAudioPID(m_apid, m_audioInfo->audioStreams[i].type);
+		m_decoder->setAudioPID(m_apid, m_audioInfo->audioStreams[i].type, 0);
 		m_decoder->set();
 		return 0;
 	} else {
diff -ruN o/lib/service/servicewebts.cpp pc/lib/service/servicewebts.cpp
--- o/lib/service/servicewebts.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/lib/service/servicewebts.cpp	2025-07-11 16:39:46.981635532 +0300
@@ -376,10 +376,10 @@
 			PID_SET = 1;
 			m_decodedemux->flush();
 			if (H264)
-				m_decoder->setVideoPID(VPID, eDVBVideo::MPEG4_H264);
+				m_decoder->setVideoPID(VPID, eDVBVideo::MPEG4_H264, 0);
 			else
-				m_decoder->setVideoPID(VPID, eDVBVideo::MPEG2);
-			m_decoder->setAudioPID(APID, eDVBAudio::aMPEG);
+				m_decoder->setVideoPID(VPID, eDVBVideo::MPEG2, 0);
+			m_decoder->setAudioPID(APID, eDVBAudio::aMPEG, 0);
 			m_decoder->pause();
 			m_event(this, evStart);
 			m_decoder->play();
@@ -529,7 +529,7 @@
 	if (m_audioInfo) {
 		m_apid = m_audioInfo->audioStreams[i].pid;
 		eDebug("[ServiceWebTS] audio track %d PID 0x%02x type %d\n", i, m_apid, m_audioInfo->audioStreams[i].type);
-		m_decoder->setAudioPID(m_apid, m_audioInfo->audioStreams[i].type);
+		m_decoder->setAudioPID(m_apid, m_audioInfo->audioStreams[i].type, 0);
 		m_decoder->set();
 		return 0;
 	} else {
diff -ruN o/main/bsod.cpp pc/main/bsod.cpp
--- o/main/bsod.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/main/bsod.cpp	2025-07-11 16:39:46.982635478 +0300
@@ -128,7 +128,7 @@
 		 * alone because we may be in a crash loop and writing this file
 		 * all night long may damage the flash. Also, usually the first
 		 * crash log is the most interesting one. */
-		crashlog_name = "/home/root/enigma2_crash.log";
+		crashlog_name = "/media/hdd/enigma2_crash.log";
 		if ((access(crashlog_name.c_str(), F_OK) == 0) ||
 		    ((f = fopen(crashlog_name.c_str(), "wb")) == NULL))
 		{
diff -ruN o/main/enigma.cpp pc/main/enigma.cpp
--- o/main/enigma.cpp	2025-07-08 10:32:50.000000000 +0300
+++ pc/main/enigma.cpp	2025-07-11 16:39:46.982635478 +0300
@@ -153,8 +153,6 @@
 				eDebug("[quitMainloop] FP_CLEAR_WAKEUP_TIMER failed: %m");
 			close(fd);
 		}
-		else
-			eDebug("[quitMainloop] open /dev/dbox/fp0 for wakeup timer clear failed: %m");
 	}
 	exit_code = exitCode;
 	eApp->quit(0);
diff -ruN o/main/Makefile.am pc/main/Makefile.am
--- o/main/Makefile.am	2025-07-08 10:32:50.000000000 +0300
+++ pc/main/Makefile.am	2025-07-11 16:39:46.983635424 +0300
@@ -45,7 +45,8 @@
 	@ALSA_LIBS@ \
 	@AVAHI_LIBS@ \
 	@LIBDL_LIBS@ \
-	-ltuxtxt32bpp
+	@X11_LIBS@ \
+	-ltuxtxt32bpp -lnl-3 -lnl-genl-3 -ldvbcsa
 
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
diff -ruN o/po/xml2po.py pc/po/xml2po.py
--- o/po/xml2po.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/po/xml2po.py	2025-07-11 16:39:46.983635424 +0300
@@ -1,6 +1,6 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
-from __future__ import print_function
+
 
 import sys
 import os
diff -ruN o/po/xml2po-python3.py pc/po/xml2po-python3.py
--- o/po/xml2po-python3.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/po/xml2po-python3.py	2025-07-11 16:39:46.984635369 +0300
@@ -69,7 +69,7 @@
 		k.replace("\\n", "\"\n\"")
 		if c:
 			for l in c.split('\n'):
-				print(("#. ", l))
+				print("#. ", l)
 		print('msgid "' + k + '"')
 		print('msgstr ""')
 
diff -ruN o/tests/enigma.py pc/tests/enigma.py
--- o/tests/enigma.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/tests/enigma.py	2025-07-11 16:39:46.985635315 +0300
@@ -309,7 +309,7 @@
 
 chroot = "."
 
-for (x, (y, z)) in Tools.Directories.defaultPaths.items():
+for (x, (y, z)) in list(Tools.Directories.defaultPaths.items()):
 	Tools.Directories.defaultPaths[x] = (chroot + y, z)
 
 Tools.Directories.defaultPaths[Tools.Directories.SCOPE_SKIN] = ("../data/", Tools.Directories.PATH_DONTCREATE)
diff -ruN o/tools/enigma2.sh.in pc/tools/enigma2.sh.in
--- o/tools/enigma2.sh.in	2025-07-08 10:32:50.000000000 +0300
+++ pc/tools/enigma2.sh.in	2025-07-11 16:39:46.985635315 +0300
@@ -1,146 +1,43 @@
 #!/bin/sh
 
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-datarootdir=@datarootdir@
-
-if [ -d /home/root ]; then
-	export HOME=/home/root
-	cd
-fi
-
-# any debuglevel passed?
-if [ -z $ENIGMA_DEBUG_LVL ]; then
-	DEBUG_LVL=3
-else
-	DEBUG_LVL=$ENIGMA_DEBUG_LVL
-fi
-
-# LC_ALL available?
-if [ -z $LC_ALL ]; then
-	export LC_ALL=en_GB.utf8
-fi
+HDD="/media/hdd"
+PREFIX="/usr/local/e2/bin"
+# Ubuntu does not use this file if it was created by you.
+FI="/etc/network/interfaces"
 
 LIBS=@libdir@/libopen.so.0.0.0
+nice -n -10 $PREFIX/enigma2 > /tmp/BootLogEnigma2 2>&1
 
 # enigma main loop
-while : ; do
-	# show bootlogo on enigma2 start
-	if [ -x @bindir@/showiframe ]; then
-		if [ -f @sysconfdir@/enigma2/backdrop.mvi ]; then
-			@bindir@/showiframe @sysconfdir@/enigma2/backdrop.mvi
-		elif [ -f @sysconfdir@/enigma2/bootlogo.mvi ]; then
-			@bindir@/showiframe @sysconfdir@/enigma2/bootlogo.mvi
-		elif [ -f @datadir@/bootlogo.mvi ]; then
-			@bindir@/showiframe @datadir@/bootlogo.mvi
-		fi
-	fi
-
-	# hook to execute scripts always before enigma2 start
-	if [ -x @bindir@/enigma2_pre_start.sh ]; then
-		@bindir@/enigma2_pre_start.sh
-	fi
-
-	# start enigma
-	sync
-	if [ $DEBUG_LVL -lt 4 ]; then
-		LD_PRELOAD=$LIBS ENIGMA_DEBUG_LVL=$DEBUG_LVL @bindir@/enigma2
-	else
-		# remove old logfiles
-		keep=5;
-		for file in `ls -t /home/root/enigma.*.debuglog`; do let "keep--"; if [ "$keep" -lt "0" ]; then rm $file; fi; done
-		# todays log file
-		file="/home/root/enigma.$(date +%Y%m%d).debuglog"
-		LD_PRELOAD=$LIBS ENIGMA_DEBUG_LVL=$DEBUG_LVL @bindir@/enigma2 >> $file 2>&1
-	fi
-
 
-	# enigma2 exit codes:
+	# e2pc exit codes:
 	#
-	#  1 - halt
+	#  1 - poweroff
 	#  2 - reboot
-	#  3 - restart enigma in normal mode
-	#  4 - front processor upgrade
-	#  5 - install new settings
-	#  6 - restart enigma in debug mode
-	#  7 - manufacturer reset
-	# 42 - restart for unattended update
-	# 43 - restart for network restore
-	# 44 - restart for autobackup restore
+	#  3 - quit e2pc
 	#
 	# >128 signal
 
 	ret=$?
 	case $ret in
 		1)
-			/sbin/halt
+			rm -f $FI
+			/sbin/poweroff
 			;;
 		2)
+			rm -f $FI
 			/sbin/reboot
 			;;
 		3)
-			DEBUG_LVL=3
-			;;
-		4)
-			/sbin/rmmod lcd
-			/usr/sbin/fpupgrade --upgrade 2>&1 | tee /home/root/fpupgrade.log
-			sleep 1;
-			/sbin/rmmod fp
-			/sbin/modprobe fp
-			/sbin/reboot
-			;;
-		5)
-			if ! grep -q config.misc.RestartUI /etc/enigma2/settings; then
-				echo "config.misc.RestartUI=true" >>/etc/enigma2/settings
-			fi
-			;;
-		6)
-			DEBUG_LVL=4
-			;;
-		7)
-			rm -R /etc/enigma2
-			;;
-		42)
-			df -P | grep -v "tmpfs " | awk '{print $6}' | tail -n +3 > /tmp/upgrade_mountpoints.txt
-			while read line; do
-				if [  -f $line/var/lib/opkg/status ]; then
-				DESTS=$DESTS" --add-dest "$line":"$line
-			fi
-			done < /tmp/upgrade_mountpoints.txt
-			# bind the console (when available)
-			[ -f /sys/class/vtconsole/vtcon1/bind ] && echo 1 > /sys/class/vtconsole/vtcon1/bind
-			prevupd=0
-			currupd=999
-			opkg update 2>&1 | tee /home/root/opkgupgrade.log
-			# check if we need to upgrade busybox first
-			if [ "$(opkg list-upgradable busybox)" != "" ]; then
-				opkg update busybox 2>&1 | tee -a /home/root/opkgupgrade.log
-			fi
-			# update all other packages
-			while [ $currupd -gt 0 -a $currupd -ne $prevupd ]; do
-				opkg upgrade $DESTS 2>&1 | tee -a /home/root/opkgupgrade.log
-				prevupd=$currupd
-				currupd=`opkg list-upgradable | wc -l`
-				echo "===> $currupd PACKAGE(S) REMAINING" >> /home/root/opkgupgrade.log
-			done
-			/sbin/reboot
-			;;
-		43)
-			# restore only network from autobackup
-			[ -f /sys/class/vtconsole/vtcon1/bind ] && echo 1 > /sys/class/vtconsole/vtcon1/bind
-			/etc/init.d/settings-restore.sh network
-			break
-			;;
-		44)
-			# restore autobackup
-			[ -f /sys/class/vtconsole/vtcon1/bind ] && echo 1 > /sys/class/vtconsole/vtcon1/bind
-			/etc/init.d/settings-restore.sh
-			[ -f /etc/init.d/softcam ] && /etc/init.d/softcam restart
-			break
+			rm -f $FI
 			;;
 		*)
-			break
 			;;
 	esac
 
-done
+# Case crash - restart once.
+if [ -f "$(find $HDD/ -name "enigma2_crash_*.log")" ]; then
+	mv -f $HDD/enigma2_crash_*.log /tmp # Part of restart mechanism. See log in /tmp.
+	sleep 5
+	$PREFIX/enigma2 # Loopback.
+fi
diff -ruN o/tools/host_tools/FormatConverter/datasource.py pc/tools/host_tools/FormatConverter/datasource.py
--- o/tools/host_tools/FormatConverter/datasource.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/tools/host_tools/FormatConverter/datasource.py	2025-07-11 16:39:46.986635260 +0300
@@ -15,11 +15,11 @@
 		return "N/A"
 
 	def getStatus(self):
-		text = str(len(self.transponderlist.keys())) + " Satellites" + "\n"
+		text = str(len(list(self.transponderlist.keys()))) + " Satellites" + "\n"
 		return text
 
 	def printAll(self):
-		for sat in self.transponderlist.keys():
+		for sat in list(self.transponderlist.keys()):
 			print("***********")
 			print("sat:", sat, self.satnames[sat])
 			for transponder in self.transponderlist[sat]:
@@ -41,7 +41,7 @@
 			self.satnames[satpos] = satname
 
 	def addTransponder(self, satpos, transponder):
-		if len(transponder.keys()) >= 6:
+		if len(list(transponder.keys())) >= 6:
 			self.transponderlist[satpos].append(transponder)
 
 
@@ -90,7 +90,7 @@
 			counttransponder = 0
 			if action == "copy":
 				self.destination.clear()
-			for satpos in self.source.transponderlist.keys():
+			for satpos in list(self.source.transponderlist.keys()):
 				countsat += 1
 				self.destination.addSat(self.source.satnames[satpos], satpos)
 				for transponder in self.source.transponderlist[satpos]:
@@ -103,7 +103,7 @@
 		sources = []
 		for source in self.datasources:
 			if source != self:
-				list.append(source.getName() + (" (%d sats)" % len(source.transponderlist.keys())))
+				list.append(source.getName() + (" (%d sats)" % len(list(source.transponderlist.keys()))))
 				sources.append(source)
 		choice = inputChoices(list)
 		if choice is None:
diff -ruN o/tools/host_tools/FormatConverter/main.py pc/tools/host_tools/FormatConverter/main.py
--- o/tools/host_tools/FormatConverter/main.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/tools/host_tools/FormatConverter/main.py	2025-07-11 16:39:46.986635260 +0300
@@ -21,7 +21,7 @@
 	os.system("/usr/bin/clear")
 	list = []
 	for index in range(len(datasources)):
-		list.append(datasources[index].getName() + (" (%d sats)" % len(datasources[index].transponderlist.keys())))
+		list.append(datasources[index].getName() + (" (%d sats)" % len(list(datasources[index].transponderlist.keys()))))
 	index = inputChoices(list, "q", "quit")
 	if index is None:
 		break
diff -ruN o/tools/host_tools/FormatConverter/satxml.py pc/tools/host_tools/FormatConverter/satxml.py
--- o/tools/host_tools/FormatConverter/satxml.py	2025-07-08 10:32:50.000000000 +0300
+++ pc/tools/host_tools/FormatConverter/satxml.py	2025-07-11 16:39:46.986635260 +0300
@@ -49,7 +49,7 @@
 							entry = str(transponder.getAttribute(param))
 							if entry != "":
 								parameters[param] = entry
-						if len(parameters.keys()) > 1:
+						if len(list(parameters.keys())) > 1:
 							self.addTransponder(satpos, parameters)
 		print(self.transponderlist)
 
